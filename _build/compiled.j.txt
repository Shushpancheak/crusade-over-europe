// this script was compiled with wurst 1.8.0.0-jenkins-Wurst-1091
globals
group w=null
location u=null
integer array r
force s=null
location t=null
location i=null
location S=null
location c=null
rect o=null
rect O=null
group l=null
group b=null
location y=null
boolean array p
boolean array e
rect q=null
rect a=null
rect n=null
rect d=null
rect f=null
rect R=null
rect T=null
rect Y=null
rect G=null
rect g=null
rect h=null
rect F=null
rect k=null
rect j=null
rect x=null
rect v=null
rect m=null
rect Q=null
rect W=null
rect E=null
rect Z=null
rect U=null
rect I=null
rect P=null
rect A=null
rect D=null
rect H=null
rect J=null
rect K=null
rect L=null
rect X=null
rect C=null
rect V=null
rect B=null
rect N=null
rect M=null
rect ww=null
rect uw=null
rect rw=null
rect sw=null
rect tw=null
rect iw=null
rect Sw=null
rect cw=null
rect ow=null
rect Ow=null
rect lw=null
rect bw=null
rect yw=null
rect pw=null
rect ew=null
rect qw=null
rect aw=null
rect nw=null
rect dw=null
rect fw=null
rect Rw=null
rect Tw=null
rect Yw=null
rect Gw=null
rect gw=null
rect hw=null
rect Fw=null
rect kw=null
rect jw=null
rect xw=null
rect vw=null
rect mw=null
rect Qw=null
rect Ww=null
rect Ew=null
rect Zw=null
rect Uw=null
rect Iw=null
rect Pw=null
rect Aw=null
rect Dw=null
rect Hw=null
rect Jw=null
rect Kw=null
rect Lw=null
rect Xw=null
rect Cw=null
rect Vw=null
rect Bw=null
rect Nw=null
rect Mw=null
rect wu=null
rect uu=null
rect ru=null
rect su=null
rect tu=null
rect iu=null
rect Su=null
rect cu=null
rect ou=null
rect Ou=null
rect lu=null
rect bu=null
rect yu=null
rect pu=null
rect eu=null
rect qu=null
rect au=null
rect nu=null
rect du=null
rect fu=null
rect Ru=null
rect Tu=null
rect Yu=null
rect Gu=null
rect gu=null
rect hu=null
rect Fu=null
rect ku=null
rect ju=null
rect xu=null
rect vu=null
rect mu=null
rect Qu=null
rect Wu=null
rect Eu=null
rect Zu=null
rect Uu=null
rect Iu=null
rect Pu=null
rect Au=null
rect Du=null
rect Hu=null
rect Ju=null
rect Ku=null
rect Lu=null
rect Xu=null
rect Cu=null
rect Vu=null
rect Bu=null
rect Nu=null
rect Mu=null
rect wr=null
rect ur=null
rect rr=null
rect sr=null
rect tr=null
rect ir=null
rect Sr=null
rect cr=null
rect lr=null
rect br=null
rect yr=null
rect pr=null
rect er=null
rect qr=null
rect ar=null
rect nr=null
rect dr=null
rect fr=null
rect Rr=null
rect Tr=null
rect Yr=null
rect Gr=null
rect gr=null
rect hr=null
rect Fr=null
rect kr=null
rect jr=null
rect xr=null
rect vr=null
rect mr=null
rect Qr=null
rect Wr=null
rect Er=null
rect Zr=null
rect Ur=null
rect Ir=null
rect Pr=null
rect Ar=null
rect Dr=null
rect Hr=null
rect Jr=null
rect Kr=null
rect Lr=null
rect Xr=null
rect Cr=null
rect Vr=null
rect Br=null
rect Nr=null
rect Mr=null
rect ws=null
rect us=null
rect rs=null
rect ss=null
rect ts=null
rect is=null
rect Ss=null
rect cs=null
rect os=null
rect Os=null
rect ls=null
rect bs=null
rect ys=null
rect ps=null
rect es=null
rect qs=null
rect as=null
rect ns=null
rect ds=null
sound fs=null
trigger Rs=null
trigger Ts=null
trigger Ys=null
trigger Gs=null
trigger gs=null
trigger hs=null
trigger Fs=null
trigger ks=null
trigger js=null
trigger xs=null
trigger vs=null
trigger ms=null
trigger Qs=null
trigger Ws=null
trigger Es=null
trigger Zs=null
trigger Us=null
trigger Is=null
trigger Ps=null
trigger As=null
trigger Ds=null
trigger Hs=null
trigger Js=null
trigger Ks=null
trigger Ls=null
trigger Xs=null
trigger Cs=null
trigger Vs=null
trigger Bs=null
trigger Ns=null
trigger Ms=null
trigger wt=null
trigger ut=null
trigger rt=null
trigger st=null
trigger tt=null
trigger St=null
trigger ct=null
trigger ot=null
trigger Ot=null
trigger lt=null
trigger bt=null
trigger yt=null
trigger pt=null
trigger et=null
trigger qt=null
trigger at=null
trigger nt=null
trigger dt=null
trigger ft=null
trigger Rt=null
trigger Tt=null
trigger Yt=null
trigger Gt=null
trigger gt=null
trigger ht=null
trigger Ft=null
trigger kt=null
trigger jt=null
trigger xt=null
trigger vt=null
trigger mt=null
trigger Qt=null
trigger Wt=null
trigger Et=null
trigger Zt=null
trigger Ut=null
trigger It=null
trigger Pt=null
trigger At=null
trigger Dt=null
trigger Ht=null
trigger Jt=null
trigger Kt=null
trigger Lt=null
trigger Xt=null
trigger Ct=null
trigger Vt=null
trigger Bt=null
trigger Nt=null
trigger Mt=null
trigger wi=null
trigger ui=null
trigger ri=null
trigger si=null
trigger ti=null
trigger ii=null
trigger Si=null
trigger ci=null
trigger oi=null
trigger Oi=null
trigger li=null
trigger bi=null
trigger yi=null
trigger pi=null
trigger ei=null
trigger qi=null
trigger ai=null
trigger ni=null
trigger di=null
trigger fi=null
trigger Ri=null
trigger Ti=null
trigger Yi=null
trigger Gi=null
trigger gi=null
trigger hi=null
trigger Fi=null
trigger ki=null
trigger ji=null
trigger xi=null
trigger vi=null
trigger mi=null
trigger Qi=null
trigger Wi=null
trigger Ei=null
trigger Zi=null
trigger Ui=null
trigger Ii=null
trigger Pi=null
trigger Ai=null
trigger Di=null
trigger Hi=null
trigger Ji=null
trigger Ki=null
trigger Li=null
trigger Xi=null
trigger Ci=null
trigger Vi=null
trigger Bi=null
trigger Ni=null
trigger Mi=null
trigger wS=null
trigger uS=null
trigger rS=null
integer sS=0
string array tS
player iS=null
integer SS=0
integer array cS
integer oS=0
integer OS=0
integer lS=0
integer bS=0
integer yS=0
integer pS=0
integer eS=0
integer qS=0
integer aS=0
integer nS=0
integer dS=0
real fS=0.
real array RS
integer array TS
real array YS
real array GS
real array gS
real array hS
integer array FS
playerevent kS=null
trigger jS=null
trigger xS=null
trigger vS=null
integer array mS
integer QS=0
integer WS=0
integer ES=0
integer array ZS
integer array US
boolean IS=false
group PS=null
integer array AS
integer DS=0
integer HS=0
integer JS=0
filterfunc KS=null
integer LS=0
integer array XS
integer array CS
integer array VS
string array BS
integer NS=0
integer MS=0
real wc=0.
integer array uc
integer array rc
integer array sc
integer array tc
integer ic=0
hashtable Sc=null
force cc=null
force oc=null
force Oc=null
force lc=null
force array bc
integer array yc
integer array pc
integer array ec
timer qc=null
real ac=0.
group nc=null
hashtable dc=null
hashtable fc=null
hashtable Rc=null
integer array Tc
integer Yc=0
boolean Gc=false
boolean gc=false
boolean hc=false
timer Fc=null
real kc=0.
rect jc=null
rect xc=null
region vc=null
real mc=0.
real Qc=0.
integer Wc=0
integer Ec=0
integer Zc=0
integer array Uc
integer array Ic
integer array Pc
integer array Ac
integer array Dc
integer array Hc
integer array Jc
integer array Kc
integer array Lc
multiboard array Xc
integer Cc=0
trigger Vc=null
group Bc=null
unit array Nc
integer Mc=0
integer array wo
player array uo
player ro=null
playercolor so=null
playercolor io=null
playercolor So=null
playercolor co=null
playercolor array oo
group Oo=null
unit lo=null
integer bo=0
real yo=0.
trigger array po
integer eo=0
real array qo
integer ao=0
string array no
string array do
string array fo
string array Ro
string array To
string array Yo
string array Go
string array go
string array ho
string array Fo
string array ko
string array jo
string array xo
string array vo
string array mo
string array Qo
string array Wo
hashtable Eo=null
timer array Zo
integer Uo=0
integer Io=0
integer Po=0
trigger Ao=null
trigger Do=null
unit array Ho
integer Jo=0
integer Ko=0
integer Lo=0
integer array Xo
integer Co=0
integer Vo=0
integer Bo=0
integer No=0
integer array Mo
integer wO=0
integer array uO
integer array rO
integer array sO
integer tO=0
integer iO=0
integer array SO
integer array cO
integer oO=0
integer OO=0
integer array lO
integer bO=0
integer yO=0
integer array pO
integer array eO
integer qO=0
integer aO=0
integer array nO
integer array dO
integer fO=0
integer RO=0
integer array TO
integer array YO
integer GO=0
integer gO=0
integer array hO
integer FO=0
integer array kO
integer array jO
integer xO=0
integer vO=0
integer array mO
integer array QO
integer WO=0
integer EO=0
integer array ZO
integer array UO
integer IO=0
integer PO=0
integer array AO
integer DO=0
integer HO=0
integer array JO
integer KO=0
integer LO=0
integer array XO
integer array CO
integer VO=0
integer BO=0
integer array NO
integer array MO
integer wl=0
integer ul=0
integer array rl
integer array sl
integer tl=0
integer il=0
integer array Sl
integer cl=0
integer ol=0
integer array Ol
integer ll=0
integer bl=0
integer array yl
integer array pl
integer el=0
integer ql=0
integer array al
integer nl=0
integer dl=0
integer array fl
real array Rl
real array Tl
boolean array Yl
real array Gl
integer array gl
real array hl
real array Fl
string array kl
string array jl
unit array xl
string array vl
integer array ml
integer array Ql
integer array Wl
real array El
real array Zl
integer array Ul
integer array Il
real array Pl
real array Al
real array Dl
real array Hl
integer array Jl
real array Kl
integer array Ll
integer array Xl
integer array Cl
integer array Vl
integer array Bl
integer array Nl
integer array Ml
integer array wb
integer array ub
integer array rb
integer array sb
integer array tb
integer array ib
integer array Sb
unit array cb
timer array ob
real array Ob
integer array lb
integer array bb
integer array yb
integer array pb
integer array eb
integer array qb
integer array ab
unit array nb
integer array db
integer array fb
integer array Rb
integer array Tb
integer array Yb
integer array Gb
integer array gb
boolean array hb
integer array Fb
integer array kb
player array jb
unit array xb
integer array vb
unit array mb
integer array Qb
real array Wb
real array Eb
unit array Zb
integer array Ub
player array Ib
boolean array Pb
integer array Ab
integer array Db
boolean array Hb
unit array Jb
unit array Kb
integer Lb=0
string array Xb
integer Cb=0
integer Vb=0
integer Bb=0
integer array Nb
integer array Mb
integer array wy
integer array uy
integer array ry
integer array sy
integer array ty
integer array iy
integer array Sy
integer array cy
integer array oy
integer array Oy
integer array ly
integer array by
integer array yy
integer array py
integer array ey
integer array qy
integer array ay
integer array ny
integer array dy
integer array fy
integer array Ry
integer array Ty
code Yy=null
code Gy=null
code gy=null
code hy=null
code Fy=null
code ky=null
code jy=null
code xy=null
code vy=null
code my=null
code Qy=null
code Wy=null
code Ey=null
code Zy=null
code Uy=null
code Iy=null
code Py=null
code Ay=null
code Dy=null
code Hy=null
code Jy=null
code Ky=null
code Ly=null
code Xy=null
code Cy=null
code Vy=null
code By=null
code Ny=null
code My=null
code wp=null
code up=null
code rp=null
code sp=null
code tp=null
code ip=null
code Sp=null
code cp=null
code op=null
code Op=null
code lp=null
code bp=null
code yp=null
code pp=null
code ep=null
code qp=null
code ap=null
code np=null
code dp=null
code fp=null
code Rp=null
code Tp=null
code Yp=null
code Gp=null
code gp=null
code hp=null
code Fp=null
code kp=null
code jp=null
code xp=null
code vp=null
code mp=null
code Qp=null
code Wp=null
code Ep=null
code Zp=null
code Up=null
code Ip=null
code Pp=null
code Ap=null
code Dp=null
code Hp=null
code Jp=null
code Kp=null
code Lp=null
code Xp=null
code Cp=null
code Vp=null
code Bp=null
code Np=null
code Mp=null
code we=null
code ue=null
code re=null
code se=null
code te=null
code ie=null
code Se=null
code ce=null
code oe=null
code Oe=null
code le=null
code be=null
code ye=null
code pe=null
code ee=null
code qe=null
code ae=null
code ne=null
code de=null
code fe=null
code Re=null
code Te=null
code Ye=null
code Ge=null
code ge=null
code he=null
code Fe=null
code ke=null
code je=null
code xe=null
code ve=null
code me=null
code Qe=null
code We=null
code Ee=null
code Ze=null
code Ue=null
code Ie=null
code Pe=null
code Ae=null
code De=null
code He=null
code Je=null
code Ke=null
code Le=null
code Xe=null
code Ce=null
code Ve=null
code Be=null
code Ne=null
code Me=null
code wq=null
code uq=null
code rq=null
code sq=null
code tq=null
code iq=null
code Sq=null
code cq=null
code oq=null
code Oq=null
code lq=null
code bq=null
code yq=null
code pq=null
code eq=null
code qq=null
code aq=null
code nq=null
code dq=null
code fq=null
code Rq=null
code Tq=null
code Yq=null
code Gq=null
code gq=null
code hq=null
code Fq=null
code kq=null
code jq=null
code xq=null
code vq=null
code mq=null
code Qq=null
code Wq=null
code Eq=null
code Zq=null
code Uq=null
code Iq=null
code Pq=null
code Aq=null
code Dq=null
code Hq=null
code Jq=null
code Kq=null
code Lq=null
code Xq=null
code Cq=null
code Vq=null
code Bq=null
code Nq=null
code Mq=null
code wa=null
code ua=null
code ra=null
code sa=null
code ta=null
code ia=null
code Sa=null
code ca=null
code oa=null
code Oa=null
code la=null
code ba=null
code ya=null
code pa=null
code ea=null
code qa=null
code aa=null
code na=null
code da=null
code fa=null
code Ra=null
code Ta=null
code Ya=null
code Ga=null
code ga=null
code ha=null
code Fa=null
code ka=null
code ja=null
code xa=null
code va=null
code ma=null
code Qa=null
code Wa=null
code Ea=null
code Za=null
code Ua=null
code Ia=null
code Pa=null
code Aa=null
code Da=null
code Ha=null
code Ja=null
code Ka=null
code La=null
code Xa=null
code Ca=null
code Va=null
code Ba=null
code Na=null
code Ma=null
code wn=null
code un=null
code rn=null
code sn=null
code tn=null
code Sn=null
code cn=null
code on=null
code On=null
code ln=null
code bn=null
code yn=null
code pn=null
code en=null
code qn=null
code an=null
code nn=null
code dn=null
code fn=null
code Rn=null
code Tn=null
code Yn=null
code Gn=null
code gn=null
code hn=null
code Fn=null
code kn=null
code jn=null
code xn=null
code vn=null
code mn=null
code Qn=null
code Wn=null
code En=null
code Zn=null
code Un=null
code In=null
code Pn=null
code An=null
code Dn=null
code Hn=null
code Jn=null
code Kn=null
code Ln=null
code Xn=null
code Cn=null
code Vn=null
code Bn=null
code Nn=null
code Mn=null
code wd=null
code ud=null
code rd=null
code sd=null
code td=null
code id=null
code Sd=null
code cd=null
code od=null
code Od=null
code ld=null
code bd=null
code yd=null
code pd=null
code ed=null
code qd=null
code ad=null
code nd=null
code dd=null
code fd=null
code Rd=null
code Td=null
code Yd=null
code Gd=null
code gd=null
code hd=null
code Fd=null
code kd=null
code jd=null
code xd=null
code vd=null
code md=null
code Qd=null
code Wd=null
code Ed=null
code Zd=null
code Ud=null
code Id=null
code Pd=null
code Ad=null
code Dd=null
code Hd=null
code Jd=null
code Kd=null
code Ld=null
code Xd=null
code Cd=null
code Vd=null
code Bd=null
code Nd=null
code Md=null
code wf=null
code uf=null
code rf=null
code sf=null
code tf=null
code Sf=null
code cf=null
code of=null
code Of=null
code lf=null
code bf=null
code yf=null
code pf=null
code ef=null
code qf=null
code af=null
code nf=null
code df=null
code ff=null
code Rf=null
code Tf=null
code Yf=null
code Gf=null
code gf=null
code hf=null
code Ff=null
code kf=null
code jf=null
code xf=null
code vf=null
code mf=null
code Qf=null
code Wf=null
code Ef=null
code Zf=null
code Uf=null
code If=null
code Pf=null
code Af=null
code Df=null
code Hf=null
code Jf=null
code Kf=null
code Lf=null
code Xf=null
code Cf=null
code Vf=null
code Bf=null
code Nf=null
code Mf=null
code wR=null
code uR=null
code rR=null
code sR=null
code tR=null
code iR=null
unit SR=null
multiboard cR=null
timer oR=null
unit OR=null
trigger lR=null
rect bR=null
endglobals
function FR takes nothing returns nothing
local player gR=Player(3)
local unit hR=CreateUnit(gR,1211118391,-30468.2,30345.3,270.516)
call SetHeroLevel(hR,15,false)
call SetUnitState(hR,UNIT_STATE_MANA,85.)
set hR=CreateUnit(gR,1211118406,-30252.3,29576.9,270.316)
call SetHeroLevel(hR,15,false)
set gR=null
set hR=null
endfunction
function FT takes nothing returns nothing
local player gT=Player(22)
local unit hT=CreateUnit(gT,1211118391,-29948.2,29831.1,270.025)
call SetHeroLevel(hT,15,false)
call SetUnitState(hT,UNIT_STATE_MANA,85.)
set hT=CreateUnit(gT,1211118406,-29699.3,29565.4,269.787)
call SetHeroLevel(hT,15,false)
set gT=null
set hT=null
endfunction
function GR takes nothing returns nothing
local player TR=Player(2)
local unit YR=CreateUnit(TR,1211118391,-30324.4,30466.1,270.380)
call SetHeroLevel(YR,15,false)
call SetUnitState(YR,UNIT_STATE_MANA,85.)
set YR=CreateUnit(TR,1211118406,-30346.6,29573.7,270.406)
call SetHeroLevel(YR,15,false)
set TR=null
set YR=null
endfunction
function GT takes nothing returns nothing
local player TT=Player(19)
local unit YT=CreateUnit(TT,1211118391,-29820.0,29950.4,269.903)
call SetHeroLevel(YT,15,false)
call SetUnitState(YT,UNIT_STATE_MANA,85.)
set YT=CreateUnit(TT,1211118406,-29707.1,29309.8,269.793)
call SetHeroLevel(YT,15,false)
set TT=null
set YT=null
endfunction
function HR takes nothing returns nothing
local player AR=Player(8)
local unit DR=CreateUnit(AR,1211118391,-29946.0,30342.9,270.023)
call SetHeroLevel(DR,15,false)
call SetUnitState(DR,UNIT_STATE_MANA,85.)
set DR=CreateUnit(AR,1211118406,-30137.9,29561.1,270.206)
call SetHeroLevel(DR,15,false)
set AR=null
set DR=null
endfunction
function LR takes nothing returns nothing
local player JR=Player(9)
local unit KR=CreateUnit(JR,1211118391,-29693.5,30338.3,269.785)
call SetHeroLevel(KR,15,false)
call SetUnitState(KR,UNIT_STATE_MANA,85.)
set KR=CreateUnit(JR,1211118406,-30045.2,29554.8,270.118)
call SetHeroLevel(KR,15,false)
set JR=null
set KR=null
endfunction
function MR takes nothing returns nothing
local player BR=Player(11)
local unit NR=CreateUnit(BR,1211118391,-29827.0,30210.1,269.911)
call SetHeroLevel(NR,15,false)
call SetUnitState(NR,UNIT_STATE_MANA,85.)
set NR=CreateUnit(BR,1211118406,-30125.9,29321.4,270.196)
call SetHeroLevel(NR,15,false)
set BR=null
set NR=null
endfunction
function PR takes nothing returns nothing
local player UR=Player(7)
local unit IR=CreateUnit(UR,1211118391,-29818.2,30468.8,269.903)
call SetHeroLevel(IR,15,false)
call SetUnitState(IR,UNIT_STATE_MANA,85.)
set IR=CreateUnit(UR,1211118406,-29998.9,29444.3,270.074)
call SetHeroLevel(IR,15,false)
set UR=null
set IR=null
endfunction
function QR takes nothing returns nothing
local player vR=Player(5)
local unit mR=CreateUnit(vR,1211118391,-29950.2,30589.5,270.027)
call SetHeroLevel(mR,15,false)
call SetUnitState(mR,UNIT_STATE_MANA,85.)
set mR=CreateUnit(vR,1211118406,-30283.9,29308.8,270.348)
call SetHeroLevel(mR,15,false)
set vR=null
set mR=null
endfunction
function RR takes nothing returns nothing
local player dR=Player(1)
local unit fR=CreateUnit(dR,1211118391,-30205.9,30601.1,270.267)
call SetHeroLevel(fR,15,false)
call SetUnitState(fR,UNIT_STATE_MANA,85.)
set fR=CreateUnit(dR,1211118406,-30199.1,29448.7,270.266)
call SetHeroLevel(fR,15,false)
set dR=null
set fR=null
endfunction
function RT takes nothing returns nothing
local player dT=Player(18)
local unit fT=CreateUnit(dT,1211118391,-29691.7,30077.9,269.782)
call SetHeroLevel(fT,15,false)
call SetUnitState(fT,UNIT_STATE_MANA,85.)
set fT=CreateUnit(dT,1211118406,-29792.0,29571.7,269.875)
call SetHeroLevel(fT,15,false)
set dT=null
set fT=null
endfunction
function VR takes nothing returns nothing
local player XR=Player(10)
local unit CR=CreateUnit(XR,1211118391,-30338.2,30210.1,270.394)
call SetHeroLevel(CR,15,false)
call SetUnitState(CR,UNIT_STATE_MANA,85.)
set CR=CreateUnit(XR,1211118406,-29904.6,29442.8,269.983)
call SetHeroLevel(CR,15,false)
set XR=null
set CR=null
endfunction
function ZR takes nothing returns nothing
local player WR=Player(6)
local unit ER=CreateUnit(WR,1211118391,-29693.7,30597.0,269.786)
call SetHeroLevel(ER,15,false)
call SetUnitState(ER,UNIT_STATE_MANA,85.)
set ER=CreateUnit(WR,1211118406,-30199.8,29310.0,270.267)
call SetHeroLevel(ER,15,false)
set WR=null
set ER=null
endfunction
function bT takes nothing returns nothing
local player OT=Player(15)
local unit lT=CreateUnit(OT,1211118391,-30467.2,29834.7,270.519)
call SetHeroLevel(lT,15,false)
call SetUnitState(lT,UNIT_STATE_MANA,85.)
set lT=CreateUnit(OT,1211118406,-29874.4,29559.4,269.954)
call SetHeroLevel(lT,15,false)
set OT=null
set lT=null
endfunction
function eT takes nothing returns nothing
local player yT=Player(16)
local unit pT=CreateUnit(yT,1211118391,-30203.1,29826.8,270.268)
call SetHeroLevel(pT,15,false)
call SetUnitState(pT,UNIT_STATE_MANA,85.)
set pT=CreateUnit(yT,1211118406,-29780.4,29300.3,269.864)
call SetHeroLevel(pT,15,false)
set yT=null
set pT=null
endfunction
function iT takes nothing returns nothing
local player sT=Player(13)
local unit tT=CreateUnit(sT,1211118391,-30204.3,30080.3,270.268)
call SetHeroLevel(tT,15,false)
call SetUnitState(tT,UNIT_STATE_MANA,85.)
set tT=CreateUnit(sT,1211118406,-30039.0,29306.5,270.112)
call SetHeroLevel(tT,15,false)
set sT=null
set tT=null
endfunction
function nR takes nothing returns nothing
local player qR=Player(0)
local unit aR=CreateUnit(qR,1211118391,-30470.9,30602.5,270.516)
call SetHeroLevel(aR,15,false)
call SetUnitState(aR,UNIT_STATE_MANA,85.)
set aR=CreateUnit(qR,1211118406,-30360.2,29312.6,270.421)
call SetHeroLevel(aR,15,false)
set qR=null
set aR=null
endfunction
function nT takes nothing returns nothing
local player qT=Player(17)
local unit aT=CreateUnit(qT,1211118391,-29951.6,30084.7,270.028)
call SetHeroLevel(aT,15,false)
call SetUnitState(aT,UNIT_STATE_MANA,85.)
set aT=CreateUnit(qT,1211118406,-29862.1,29302.2,269.942)
call SetHeroLevel(aT,15,false)
set qT=null
set aT=null
endfunction
function oT takes nothing returns nothing
local player ST=Player(14)
local unit cT=CreateUnit(ST,1211118391,-30339.8,29950.4,270.397)
call SetHeroLevel(cT,15,false)
call SetUnitState(cT,UNIT_STATE_MANA,85.)
set cT=CreateUnit(ST,1211118406,-29968.7,29556.2,270.045)
call SetHeroLevel(cT,15,false)
set ST=null
set cT=null
endfunction
function rT takes nothing returns nothing
local player wT=Player(12)
local unit uT=CreateUnit(wT,1211118391,-30464.7,30089.7,270.515)
call SetHeroLevel(uT,15,false)
call SetUnitState(uT,UNIT_STATE_MANA,85.)
set uT=CreateUnit(wT,1211118406,-29962.2,29311.8,270.038)
call SetHeroLevel(uT,15,false)
set wT=null
set uT=null
endfunction
function xR takes nothing returns nothing
local player kR=Player(4)
local unit jR=CreateUnit(kR,1211118391,-30204.6,30339.2,270.267)
call SetHeroLevel(jR,15,false)
call SetUnitState(jR,UNIT_STATE_MANA,85.)
set jR=CreateUnit(kR,1211118406,-30106.5,29439.8,270.177)
call SetHeroLevel(jR,15,false)
set kR=null
set jR=null
endfunction
function xT takes nothing returns nothing
local player kT=Player(23)
local unit jT=CreateUnit(kT,1211118391,-29689.5,29824.6,269.779)
call SetHeroLevel(jT,15,false)
call SetUnitState(jT,UNIT_STATE_MANA,85.)
set jT=CreateUnit(kT,1211118406,-29815.4,29434.4,269.898)
call SetHeroLevel(jT,15,false)
set kT=null
set jT=null
endfunction
function QT takes nothing returns nothing
call nR()
call RR()
call GR()
call FR()
call xR()
call QR()
call ZR()
call PR()
call HR()
call LR()
call VR()
call MR()
call rT()
call iT()
call oT()
call bT()
call eT()
call nT()
call RT()
call GT()
call FT()
call xT()
endfunction
function eR takes nothing returns nothing
local integer pR=0
set pR=0
loop
exitwhen pR>8192
call CreateGroup()
set pR=pR+1
endloop
call CreateForce()
call CreateGroup()
call CreateForce()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateForce()
call CreateForce()
call CreateForce()
call CreateTimer()
call CreateForce()
call CreateGroup()
set w=CreateGroup()
call CreateGroup()
call CreateForce()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateTimer()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set r[pR]=0
set pR=pR+1
endloop
set s=CreateForce()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
call CreateGroup()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
call CreateForce()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
set l=CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
call CreateGroup()
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set pR=pR+1
endloop
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateForce()
call CreateForce()
set pR=0
loop
exitwhen pR>1
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>1
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>1
set pR=pR+1
endloop
set b=CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
set pR=0
loop
exitwhen pR>24
set p[pR]=false
set pR=pR+1
endloop
set pR=0
loop
exitwhen pR>24
set e[pR]=false
set pR=pR+1
endloop
endfunction
function AI takes nothing returns nothing
local trigger UI
local playerunitevent II
local integer PI
set ti=CreateTrigger()
set UI=ti
set II=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set PI=0
loop
call TriggerRegisterPlayerUnitEvent(UI,Player(PI),II,null)
set PI=PI+1
exitwhen PI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ti,Condition(Dq))
call TriggerAddAction(ti,Hq)
set UI=null
set II=null
endfunction
function BL takes nothing returns nothing
local trigger XL
local playerunitevent CL
local integer VL
set uS=CreateTrigger()
set XL=uS
set CL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set VL=0
loop
call TriggerRegisterPlayerUnitEvent(XL,Player(VL),CL,null)
set VL=VL+1
exitwhen VL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(uS,Condition(Un))
call TriggerAddAction(uS,In)
set XL=null
set CL=null
endfunction
function BU takes nothing returns nothing
local trigger XU
local playerunitevent CU
local integer VU
set Nt=CreateTrigger()
set XU=Nt
set CU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set VU=0
loop
call TriggerRegisterPlayerUnitEvent(XU,Player(VU),CU,null)
set VU=VU+1
exitwhen VU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Nt,Condition(jq))
call TriggerAddAction(Nt,xq)
set XU=null
set CU=null
endfunction
function CF takes nothing returns nothing
local trigger KF
local playerunitevent LF
local integer XF
set Hs=CreateTrigger()
set KF=Hs
set LF=EVENT_PLAYER_UNIT_SPELL_CAST
set XF=0
loop
call TriggerRegisterPlayerUnitEvent(KF,Player(XF),LF,null)
set XF=XF+1
exitwhen XF==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Hs,Condition(ap))
call TriggerAddAction(Hs,np)
set KF=null
set LF=null
endfunction
function CI takes nothing returns nothing
local trigger KI
local playerunitevent LI
local integer XI
set ii=CreateTrigger()
set KI=ii
set LI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set XI=0
loop
call TriggerRegisterPlayerUnitEvent(KI,Player(XI),LI,null)
set XI=XI+1
exitwhen XI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ii,Condition(Jq))
call TriggerAddAction(ii,Kq)
set KI=null
set LI=null
endfunction
function DP takes nothing returns nothing
local trigger IP
local playerunitevent PP
local integer AP
set yi=CreateTrigger()
set IP=yi
set PP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set AP=0
loop
call TriggerRegisterPlayerUnitEvent(IP,Player(AP),PP,null)
set AP=AP+1
exitwhen AP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(yi,Condition(ia))
call TriggerAddAction(yi,Sa)
set IP=null
set PP=null
endfunction
function DZ takes nothing returns nothing
local trigger IZ
local playerunitevent PZ
local integer AZ
set Dt=CreateTrigger()
set IZ=Dt
set PZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set AZ=0
loop
call TriggerRegisterPlayerUnitEvent(IZ,Player(AZ),PZ,null)
set AZ=AZ+1
exitwhen AZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Dt,Condition(lq))
call TriggerAddAction(Dt,bq)
set IZ=null
set PZ=null
endfunction
function Dv takes nothing returns nothing
local trigger Iv
local playerunitevent Pv
local integer Av
set rt=CreateTrigger()
set Iv=rt
set Pv=EVENT_PLAYER_UNIT_DEATH
set Av=0
loop
call TriggerRegisterPlayerUnitEvent(Iv,Player(Av),Pv,null)
set Av=Av+1
exitwhen Av==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(rt,Condition(Pp))
call TriggerAddAction(rt,Ap)
set Iv=null
set Pv=null
endfunction
function EL takes nothing returns nothing
local trigger mL
local playerunitevent QL
local integer WL
set Mi=CreateTrigger()
set mL=Mi
set QL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set WL=0
loop
call TriggerRegisterPlayerUnitEvent(mL,Player(WL),QL,null)
set WL=WL+1
exitwhen WL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Mi,Condition(Qn))
call TriggerAddAction(Mi,Wn)
set mL=null
set QL=null
endfunction
function EU takes nothing returns nothing
local trigger mU
local playerunitevent QU
local integer WU
set Vt=CreateTrigger()
set mU=Vt
set QU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set WU=0
loop
call TriggerRegisterPlayerUnitEvent(mU,Player(WU),QU,null)
set WU=WU+1
exitwhen WU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Vt,Condition(gq))
call TriggerAddAction(Vt,hq)
set mU=null
set QU=null
endfunction
function EW takes nothing returns nothing
local trigger mW
local playerunitevent QW
local integer WW
set gt=CreateTrigger()
set mW=gt
set QW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set WW=0
loop
call TriggerRegisterPlayerUnitEvent(mW,Player(WW),QW,null)
set WW=WW+1
exitwhen WW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gt,Condition(xe))
call TriggerAddAction(gt,ve)
set mW=null
set QW=null
endfunction
function FP takes nothing returns nothing
local trigger GP
local playerunitevent gP
local integer hP
set li=CreateTrigger()
set GP=li
set gP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set hP=0
loop
call TriggerRegisterPlayerUnitEvent(GP,Player(hP),gP,null)
set hP=hP+1
exitwhen hP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(li,Condition(ua))
call TriggerAddAction(li,ra)
set GP=null
set gP=null
endfunction
function FY takes nothing returns nothing
local trigger GY
local playerunitevent gY
local integer hY
set hs=CreateTrigger()
set GY=hs
set gY=EVENT_PLAYER_UNIT_ATTACKED
set hY=0
loop
call TriggerRegisterPlayerUnitEvent(GY,Player(hY),gY,null)
set hY=hY+1
exitwhen hY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(hs,Condition(xy))
call TriggerAddAction(hs,vy)
set GY=null
set gY=null
endfunction
function FZ takes nothing returns nothing
local trigger GZ
local playerunitevent gZ
local integer hZ
set Pt=CreateTrigger()
set GZ=Pt
set gZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set hZ=0
loop
call TriggerRegisterPlayerUnitEvent(GZ,Player(hZ),gZ,null)
set hZ=hZ+1
exitwhen hZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Pt,Condition(Sq))
call TriggerAddAction(Pt,cq)
set GZ=null
set gZ=null
endfunction
function Gv takes nothing returns nothing
local trigger Rv
local playerunitevent Tv
local integer Yv
set ut=CreateTrigger()
set Rv=ut
set Tv=EVENT_PLAYER_UNIT_DEATH
set Yv=0
loop
call TriggerRegisterPlayerUnitEvent(Rv,Player(Yv),Tv,null)
set Yv=Yv+1
exitwhen Yv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ut,Condition(Up))
call TriggerAddAction(ut,Ip)
set Rv=null
set Tv=null
endfunction
function HL takes nothing returns nothing
local trigger PL
local playerunitevent AL
local integer DL
set wS=CreateTrigger()
set PL=wS
set AL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set DL=0
loop
call TriggerRegisterPlayerUnitEvent(PL,Player(DL),AL,null)
set DL=DL+1
exitwhen DL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(wS,Condition(En))
call TriggerAddAction(wS,Zn)
set PL=null
set AL=null
endfunction
function HT takes nothing returns nothing
set Ys=CreateTrigger()
call TriggerRegisterTimerEvent(Ys,1.00,false)
call TriggerAddAction(Ys,gy)
endfunction
function HU takes nothing returns nothing
local trigger PU
local playerunitevent AU
local integer DU
set Bt=CreateTrigger()
set PU=Bt
set AU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set DU=0
loop
call TriggerRegisterPlayerUnitEvent(PU,Player(DU),AU,null)
set DU=DU+1
exitwhen DU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Bt,Condition(Fq))
call TriggerAddAction(Bt,kq)
set PU=null
set AU=null
endfunction
function HW takes nothing returns nothing
local trigger PW
local playerunitevent AW
local integer DW
set ht=CreateTrigger()
set PW=ht
set AW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set DW=0
loop
call TriggerRegisterPlayerUnitEvent(PW,Player(DW),AW,null)
set DW=DW+1
exitwhen DW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ht,Condition(me))
call TriggerAddAction(ht,Qe)
set PW=null
set AW=null
endfunction
function Ix takes nothing returns nothing
local trigger Ex
local playerunitevent Zx
local integer Ux
set Ns=CreateTrigger()
set Ex=Ns
set Zx=EVENT_PLAYER_UNIT_SPELL_CAST
set Ux=0
loop
call TriggerRegisterPlayerUnitEvent(Ex,Player(Ux),Zx,null)
set Ux=Ux+1
exitwhen Ux==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ns,Condition(Qp))
call TriggerAddAction(Ns,Wp)
set Ex=null
set Zx=null
endfunction
function JE takes nothing returns nothing
local trigger AE
local playerunitevent DE
local integer HE
set Wt=CreateTrigger()
set AE=Wt
set DE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set HE=0
loop
call TriggerRegisterPlayerUnitEvent(AE,Player(HE),DE,null)
set HE=HE+1
exitwhen HE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Wt,Condition(Ve))
call TriggerAddAction(Wt,Be)
set AE=null
set DE=null
endfunction
function KD takes nothing returns nothing
local trigger DD
local playerunitevent HD
local integer JD
set ki=CreateTrigger()
set DD=ki
set HD=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set JD=0
loop
call TriggerRegisterPlayerUnitEvent(DD,Player(JD),HD,null)
set JD=JD+1
exitwhen JD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(ki,Ia)
set DD=null
set HD=null
endfunction
function KK takes nothing returns nothing
local trigger DK
local playerunitevent HK
local integer JK
set Li=CreateTrigger()
set DK=Li
set HK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set JK=0
loop
call TriggerRegisterPlayerUnitEvent(DK,Player(JK),HK,null)
set JK=JK+1
exitwhen JK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Li,Condition(Rn))
call TriggerAddAction(Li,Tn)
set DK=null
set HK=null
endfunction
function KQ takes nothing returns nothing
local trigger DQ
local playerunitevent HQ
local integer JQ
set dt=CreateTrigger()
set DQ=dt
set HQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set JQ=0
loop
call TriggerRegisterPlayerUnitEvent(DQ,Player(JQ),HQ,null)
set JQ=JQ+1
exitwhen JQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(dt,Condition(ne))
call TriggerAddAction(dt,de)
set DQ=null
set HQ=null
endfunction
function LW takes nothing returns nothing
set Ft=CreateTrigger()
call TriggerRegisterTimerEvent(Ft,0.10,false)
call TriggerAddAction(Ft,Ee)
endfunction
function MK takes nothing returns nothing
local trigger VK
local playerunitevent BK
local integer NK
set Xi=CreateTrigger()
set VK=Xi
set BK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set NK=0
loop
call TriggerRegisterPlayerUnitEvent(VK,Player(NK),BK,null)
set NK=NK+1
exitwhen NK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Xi,Condition(Yn))
call TriggerAddAction(Xi,Gn)
set VK=null
set BK=null
endfunction
function MQ takes nothing returns nothing
local trigger VQ
local playerunitevent BQ
local integer NQ
set ft=CreateTrigger()
set VQ=ft
set BQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set NQ=0
loop
call TriggerRegisterPlayerUnitEvent(VQ,Player(NQ),BQ,null)
set NQ=NQ+1
exitwhen NQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ft,Condition(fe))
call TriggerAddAction(ft,Re)
set VQ=null
set BQ=null
endfunction
function MZ takes nothing returns nothing
set Jt=CreateTrigger()
call TriggerRegisterTimerEvent(Jt,0.10,false)
call TriggerAddAction(Jt,qq)
endfunction
function NE takes nothing returns nothing
local trigger CE
local playerunitevent VE
local integer BE
set Et=CreateTrigger()
set CE=Et
set VE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set BE=0
loop
call TriggerRegisterPlayerUnitEvent(CE,Player(BE),VE,null)
set BE=BE+1
exitwhen BE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Et,Condition(Ne))
call TriggerAddAction(Et,Me)
set CE=null
set VE=null
endfunction
function NI takes nothing returns nothing
set Si=CreateTrigger()
call TriggerRegisterTimerEvent(Si,0.10,false)
call TriggerAddAction(Si,Xq)
endfunction
function PA takes nothing returns nothing
local trigger ZA
local playerunitevent UA
local integer IA
set fi=CreateTrigger()
set ZA=fi
set UA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set IA=0
loop
call TriggerRegisterPlayerUnitEvent(ZA,Player(IA),UA,null)
set IA=IA+1
exitwhen IA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(fi,Condition(fa))
call TriggerAddAction(fi,Ra)
set ZA=null
set UA=null
endfunction
function PD takes nothing returns nothing
local trigger ZD
local playerunitevent UD
local integer ID
set Fi=CreateTrigger()
set ZD=Fi
set UD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set ID=0
loop
call TriggerRegisterPlayerUnitEvent(ZD,Player(ID),UD,null)
set ID=ID+1
exitwhen ID==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Fi,Condition(Za))
call TriggerAddAction(Fi,Ua)
set ZD=null
set UD=null
endfunction
function PJ takes nothing returns nothing
local trigger ZJ
local playerunitevent UJ
local integer IJ
set Ui=CreateTrigger()
set ZJ=Ui
set UJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set IJ=0
loop
call TriggerRegisterPlayerUnitEvent(ZJ,Player(IJ),UJ,null)
set IJ=IJ+1
exitwhen IJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ui,Condition(sn))
call TriggerAddAction(Ui,tn)
set ZJ=null
set UJ=null
endfunction
function PT takes nothing returns nothing
set Rs=CreateTrigger()
call TriggerRegisterTimerEvent(Rs,70.00,false)
call TriggerAddAction(Rs,Gy)
endfunction
function PY takes nothing returns nothing
local trigger ZY
local playerunitevent UY
local integer IY
set Fs=CreateTrigger()
set ZY=Fs
set UY=EVENT_PLAYER_UNIT_ATTACKED
set IY=0
loop
call TriggerRegisterPlayerUnitEvent(ZY,Player(IY),UY,null)
set IY=IY+1
exitwhen IY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Fs,Condition(my))
call TriggerAddAction(Fs,Qy)
set ZY=null
set UY=null
endfunction
function Pm takes nothing returns nothing
local trigger Zm
local playerunitevent Um
local integer Im
set lt=CreateTrigger()
set Zm=lt
set Um=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Im=0
loop
call TriggerRegisterPlayerUnitEvent(Zm,Player(Im),Um,null)
set Im=Im+1
exitwhen Im==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(lt,Condition(ue))
call TriggerAddAction(lt,re)
set Zm=null
set Um=null
endfunction
function QI takes nothing returns nothing
local trigger xI
local playerunitevent vI
local integer mI
set si=CreateTrigger()
set xI=si
set vI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set mI=0
loop
call TriggerRegisterPlayerUnitEvent(xI,Player(mI),vI,null)
set mI=mI+1
exitwhen mI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(si,Condition(Pq))
call TriggerAddAction(si,Aq)
set xI=null
set vI=null
endfunction
function RH takes nothing returns nothing
local trigger nH
local playerunitevent dH
local integer fH
set xi=CreateTrigger()
set nH=xi
set dH=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set fH=0
loop
call TriggerRegisterPlayerUnitEvent(nH,Player(fH),dH,null)
set fH=fH+1
exitwhen fH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(xi,Condition(Da))
call TriggerAddAction(xi,Ha)
set nH=null
set dH=null
endfunction
function RL takes nothing returns nothing
local trigger nL
local playerunitevent dL
local integer fL
set Bi=CreateTrigger()
set nL=Bi
set dL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set fL=0
loop
call TriggerRegisterPlayerUnitEvent(nL,Player(fL),dL,null)
set fL=fL+1
exitwhen fL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Bi,Condition(jn))
call TriggerAddAction(Bi,xn)
set nL=null
set dL=null
endfunction
function RU takes nothing returns nothing
local trigger nU
local playerunitevent dU
local integer fU
set Xt=CreateTrigger()
set nU=Xt
set dU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set fU=0
loop
call TriggerRegisterPlayerUnitEvent(nU,Player(fU),dU,null)
set fU=fU+1
exitwhen fU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Xt,Condition(Rq))
call TriggerAddAction(Xt,Tq)
set nU=null
set dU=null
endfunction
function RW takes nothing returns nothing
local trigger nW
local playerunitevent dW
local integer fW
set Yt=CreateTrigger()
set nW=Yt
set dW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set fW=0
loop
call TriggerRegisterPlayerUnitEvent(nW,Player(fW),dW,null)
set fW=fW+1
exitwhen fW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Yt,Condition(he))
call TriggerAddAction(Yt,Fe)
set nW=null
set dW=null
endfunction
function SH takes nothing returns nothing
local trigger sH
local playerunitevent tH
local integer iH
set ji=CreateTrigger()
set sH=ji
set tH=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set iH=0
loop
call TriggerRegisterPlayerUnitEvent(sH,Player(iH),tH,null)
set iH=iH+1
exitwhen iH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ji,Condition(Pa))
call TriggerAddAction(ji,Aa)
set sH=null
set tH=null
endfunction
function SL takes nothing returns nothing
local trigger sL
local playerunitevent tL
local integer iL
set Ci=CreateTrigger()
set sL=Ci
set tL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set iL=0
loop
call TriggerRegisterPlayerUnitEvent(sL,Player(iL),tL,null)
set iL=iL+1
exitwhen iL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ci,Condition(gn))
call TriggerAddAction(Ci,hn)
set sL=null
set tL=null
endfunction
function SU takes nothing returns nothing
local trigger sU
local playerunitevent tU
local integer iU
set Kt=CreateTrigger()
set sU=Kt
set tU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set iU=0
loop
call TriggerRegisterPlayerUnitEvent(sU,Player(iU),tU,null)
set iU=iU+1
exitwhen iU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Kt,Condition(aq))
call TriggerAddAction(Kt,nq)
set sU=null
set tU=null
endfunction
function SW takes nothing returns nothing
local trigger sW
local playerunitevent tW
local integer iW
set Rt=CreateTrigger()
set sW=Rt
set tW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set iW=0
loop
call TriggerRegisterPlayerUnitEvent(sW,Player(iW),tW,null)
set iW=iW+1
exitwhen iW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Rt,Condition(Te))
call TriggerAddAction(Rt,Ye)
set sW=null
set tW=null
endfunction
function TE takes nothing returns nothing
local trigger dE
local playerunitevent fE
local integer RE
set vt=CreateTrigger()
set dE=vt
set fE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set RE=0
loop
call TriggerRegisterPlayerUnitEvent(dE,Player(RE),fE,null)
set RE=RE+1
exitwhen RE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(vt,Condition(He))
call TriggerAddAction(vt,Je)
set dE=null
set fE=null
endfunction
function UK takes nothing returns nothing
local trigger WK
local playerunitevent EK
local integer ZK
set Ki=CreateTrigger()
set WK=Ki
set EK=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set ZK=0
loop
call TriggerRegisterPlayerUnitEvent(WK,Player(ZK),EK,null)
set ZK=ZK+1
exitwhen ZK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ki,Condition(dn))
call TriggerAddAction(Ki,fn)
set WK=null
set EK=null
endfunction
function UQ takes nothing returns nothing
local trigger WQ
local playerunitevent EQ
local integer ZQ
set nt=CreateTrigger()
set WQ=nt
set EQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set ZQ=0
loop
call TriggerRegisterPlayerUnitEvent(WQ,Player(ZQ),EQ,null)
set ZQ=ZQ+1
exitwhen ZQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(nt,Condition(qe))
call TriggerAddAction(nt,ae)
set WQ=null
set EQ=null
endfunction
function VH takes nothing returns nothing
local trigger LH
local playerunitevent XH
local integer CH
set mi=CreateTrigger()
set LH=mi
set XH=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set CH=0
loop
call TriggerRegisterPlayerUnitEvent(LH,Player(CH),XH,null)
set CH=CH+1
exitwhen CH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(mi,Condition(La))
call TriggerAddAction(mi,Xa)
set LH=null
set XH=null
endfunction
function VP takes nothing returns nothing
local trigger LP
local playerunitevent XP
local integer CP
set pi=CreateTrigger()
set LP=pi
set XP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set CP=0
loop
call TriggerRegisterPlayerUnitEvent(LP,Player(CP),XP,null)
set CP=CP+1
exitwhen CP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(pi,Condition(ca))
call TriggerAddAction(pi,oa)
set LP=null
set XP=null
endfunction
function VY takes nothing returns nothing
local trigger LY
local playerunitevent XY
local integer CY
set ks=CreateTrigger()
set LY=ks
set XY=EVENT_PLAYER_UNIT_SPELL_CAST
set CY=0
loop
call TriggerRegisterPlayerUnitEvent(LY,Player(CY),XY,null)
set CY=CY+1
exitwhen CY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ks,Condition(Wy))
call TriggerAddAction(ks,Ey)
set LY=null
set XY=null
endfunction
function VZ takes nothing returns nothing
local trigger LZ
local playerunitevent XZ
local integer CZ
set Ht=CreateTrigger()
set LZ=Ht
set XZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set CZ=0
loop
call TriggerRegisterPlayerUnitEvent(LZ,Player(CZ),XZ,null)
set CZ=CZ+1
exitwhen CZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ht,Condition(yq))
call TriggerAddAction(Ht,pq)
set LZ=null
set XZ=null
endfunction
function Vv takes nothing returns nothing
local trigger Lv
local playerunitevent Xv
local integer Cv
set st=CreateTrigger()
set Lv=st
set Xv=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Cv=0
loop
call TriggerRegisterPlayerUnitEvent(Lv,Player(Cv),Xv,null)
set Cv=Cv+1
exitwhen Cv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(st,Condition(Dp))
call TriggerAddAction(st,Hp)
set Lv=null
set Xv=null
endfunction
function WH takes nothing returns nothing
local trigger vH
local playerunitevent mH
local integer QH
set vi=CreateTrigger()
set vH=vi
set mH=EVENT_PLAYER_UNIT_SPELL_CAST
set QH=0
loop
call TriggerRegisterPlayerUnitEvent(vH,Player(QH),mH,null)
set QH=QH+1
exitwhen QH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(vi,Condition(Ja))
call TriggerAddAction(vi,Ka)
set vH=null
set mH=null
endfunction
function WP takes nothing returns nothing
local trigger vP
local playerunitevent mP
local integer QP
set bi=CreateTrigger()
set vP=bi
set mP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set QP=0
loop
call TriggerRegisterPlayerUnitEvent(vP,Player(QP),mP,null)
set QP=QP+1
exitwhen QP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(bi,Condition(sa))
call TriggerAddAction(bi,ta)
set vP=null
set mP=null
endfunction
function WZ takes nothing returns nothing
local trigger vZ
local playerunitevent mZ
local integer QZ
set At=CreateTrigger()
set vZ=At
set mZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set QZ=0
loop
call TriggerRegisterPlayerUnitEvent(vZ,Player(QZ),mZ,null)
set QZ=QZ+1
exitwhen QZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(At,Condition(oq))
call TriggerAddAction(At,Oq)
set vZ=null
set mZ=null
endfunction
function Wk takes nothing returns nothing
local trigger vk
local playerunitevent mk
local integer Qk
set Ks=CreateTrigger()
set vk=Ks
set mk=EVENT_PLAYER_UNIT_SPELL_CAST
set Qk=0
loop
call TriggerRegisterPlayerUnitEvent(vk,Player(Qk),mk,null)
set Qk=Qk+1
exitwhen Qk==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ks,Condition(Rp))
call TriggerAddAction(Ks,Tp)
set vk=null
set mk=null
endfunction
function XA takes nothing returns nothing
local trigger JA
local playerunitevent KA
local integer LA
set Ri=CreateTrigger()
set JA=Ri
set KA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set LA=0
loop
call TriggerRegisterPlayerUnitEvent(JA,Player(LA),KA,null)
set LA=LA+1
exitwhen LA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ri,Condition(Ta))
call TriggerAddAction(Ri,Ya)
set JA=null
set KA=null
endfunction
function XG takes nothing returns nothing
local trigger JG
local playerunitevent KG
local integer LG
set ms=CreateTrigger()
set JG=ms
set KG=EVENT_PLAYER_UNIT_SPELL_CAST
set LG=0
loop
call TriggerRegisterPlayerUnitEvent(JG,Player(LG),KG,null)
set LG=LG+1
exitwhen LG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ms,Condition(Dy))
call TriggerAddAction(ms,Hy)
set JG=null
set KG=null
endfunction
function XJ takes nothing returns nothing
local trigger JJ
local playerunitevent KJ
local integer LJ
set Ii=CreateTrigger()
set JJ=Ii
set KJ=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set LJ=0
loop
call TriggerRegisterPlayerUnitEvent(JJ,Player(LJ),KJ,null)
set LJ=LJ+1
exitwhen LJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ii,Condition(Sn))
call TriggerAddAction(Ii,cn)
set JJ=null
set KJ=null
endfunction
function Xg takes nothing returns nothing
local trigger Jg
local playerunitevent Kg
local integer Lg
set Es=CreateTrigger()
set Jg=Es
set Kg=EVENT_PLAYER_UNIT_SPELL_CAST
set Lg=0
loop
call TriggerRegisterPlayerUnitEvent(Jg,Player(Lg),Kg,null)
set Lg=Lg+1
exitwhen Lg==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Es,Condition(Ny))
call TriggerAddAction(Es,My)
set Jg=null
set Kg=null
endfunction
function Xh takes nothing returns nothing
local trigger Jh
local playerunitevent Kh
local integer Lh
set Is=CreateTrigger()
set Jh=Is
set Kh=EVENT_PLAYER_UNIT_SPELL_CAST
set Lh=0
loop
call TriggerRegisterPlayerUnitEvent(Jh,Player(Lh),Kh,null)
set Lh=Lh+1
exitwhen Lh==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Is,Condition(cp))
call TriggerAddAction(Is,op)
set Jh=null
set Kh=null
endfunction
function Xm takes nothing returns nothing
local trigger Jm
local playerunitevent Km
local integer Lm
set bt=CreateTrigger()
set Jm=bt
set Km=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Lm=0
loop
call TriggerRegisterPlayerUnitEvent(Jm,Player(Lm),Km,null)
set Lm=Lm+1
exitwhen Lm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(bt,Condition(se))
call TriggerAddAction(bt,te)
set Jm=null
set Km=null
endfunction
function YD takes nothing returns nothing
local trigger fD
local playerunitevent RD
local integer TD
set gi=CreateTrigger()
set fD=gi
set RD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set TD=0
loop
call TriggerRegisterPlayerUnitEvent(fD,Player(TD),RD,null)
set TD=TD+1
exitwhen TD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gi,Condition(xa))
call TriggerAddAction(gi,va)
set fD=null
set RD=null
endfunction
function YK takes nothing returns nothing
local trigger fK
local playerunitevent RK
local integer TK
set Hi=CreateTrigger()
set fK=Hi
set RK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set TK=0
loop
call TriggerRegisterPlayerUnitEvent(fK,Player(TK),RK,null)
set TK=TK+1
exitwhen TK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Hi,Condition(en))
call TriggerAddAction(Hi,qn)
set fK=null
set RK=null
endfunction
function YQ takes nothing returns nothing
local trigger fQ
local playerunitevent RQ
local integer TQ
set qt=CreateTrigger()
set fQ=qt
set RQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set TQ=0
loop
call TriggerRegisterPlayerUnitEvent(fQ,Player(TQ),RQ,null)
set TQ=TQ+1
exitwhen TQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(qt,Condition(be))
call TriggerAddAction(qt,ye)
set fQ=null
set RQ=null
endfunction
function ZE takes nothing returns nothing
local trigger QE
local playerunitevent WE
local integer EE
set Qt=CreateTrigger()
set QE=Qt
set WE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set EE=0
loop
call TriggerRegisterPlayerUnitEvent(QE,Player(EE),WE,null)
set EE=EE+1
exitwhen EE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Qt,Condition(Xe))
call TriggerAddAction(Qt,Ce)
set QE=null
set WE=null
endfunction
function Zj takes nothing returns nothing
local trigger Qj
local playerunitevent Wj
local integer Ej
set Cs=CreateTrigger()
set Qj=Cs
set Wj=EVENT_PLAYER_UNIT_DEATH
set Ej=0
loop
call TriggerRegisterPlayerUnitEvent(Qj,Player(Ej),Wj,null)
set Ej=Ej+1
exitwhen Ej==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Cs,Condition(Fp))
call TriggerAddAction(Cs,kp)
set Qj=null
set Wj=null
endfunction
function bF takes nothing returns nothing
local trigger oF
local playerunitevent OF
local integer lF
set Ps=CreateTrigger()
set oF=Ps
set OF=EVENT_PLAYER_UNIT_SPELL_CAST
set lF=0
loop
call TriggerRegisterPlayerUnitEvent(oF,Player(lF),OF,null)
set lF=lF+1
exitwhen lF==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ps,Condition(lp))
call TriggerAddAction(Ps,bp)
set oF=null
set OF=null
endfunction
function bI takes nothing returns nothing
local trigger oI
local playerunitevent OI
local integer lI
set wi=CreateTrigger()
set oI=wi
set OI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set lI=0
loop
call TriggerRegisterPlayerUnitEvent(oI,Player(lI),OI,null)
set lI=lI+1
exitwhen lI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(wi,Condition(Qq))
call TriggerAddAction(wi,Wq)
set oI=null
set OI=null
endfunction
function bg takes nothing returns nothing
local trigger og
local playerunitevent Og
local integer lg
set Qs=CreateTrigger()
set og=Qs
set Og=EVENT_PLAYER_UNIT_SPELL_CAST
set lg=0
loop
call TriggerRegisterPlayerUnitEvent(og,Player(lg),Og,null)
set lg=lg+1
exitwhen lg==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Qs,Condition(Ky))
call TriggerAddAction(Qs,Ly)
set og=null
set Og=null
endfunction
function bh takes nothing returns nothing
local trigger oh
local playerunitevent Oh
local integer lh
set Zs=CreateTrigger()
set oh=Zs
set Oh=EVENT_PLAYER_UNIT_SPELL_CAST
set lh=0
loop
call TriggerRegisterPlayerUnitEvent(oh,Player(lh),Oh,null)
set lh=lh+1
exitwhen lh==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Zs,Condition(up))
call TriggerAddAction(Zs,rp)
set oh=null
set Oh=null
endfunction
function cE takes nothing returns nothing
local trigger tE
local playerunitevent iE
local integer SE
set jt=CreateTrigger()
set tE=jt
set iE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set SE=0
loop
call TriggerRegisterPlayerUnitEvent(tE,Player(SE),iE,null)
set SE=SE+1
exitwhen SE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(jt,Condition(Ie))
call TriggerAddAction(jt,Pe)
set tE=null
set iE=null
endfunction
function dI takes nothing returns nothing
local trigger qI
local playerunitevent aI
local integer nI
set ui=CreateTrigger()
set qI=ui
set aI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set nI=0
loop
call TriggerRegisterPlayerUnitEvent(qI,Player(nI),aI,null)
set nI=nI+1
exitwhen nI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ui,Condition(Eq))
call TriggerAddAction(ui,Zq)
set qI=null
set aI=null
endfunction
function dj takes nothing returns nothing
local trigger qj
local playerunitevent aj
local integer nj
set Xs=CreateTrigger()
set qj=Xs
set aj=EVENT_PLAYER_UNIT_DEATH
set nj=0
loop
call TriggerRegisterPlayerUnitEvent(qj,Player(nj),aj,null)
set nj=nj+1
exitwhen nj==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Xs,Condition(gp))
call TriggerAddAction(Xs,hp)
set qj=null
set aj=null
endfunction
function dx takes nothing returns nothing
local trigger qx
local playerunitevent ax
local integer nx
set Bs=CreateTrigger()
set qx=Bs
set ax=EVENT_PLAYER_UNIT_DEATH
set nx=0
loop
call TriggerRegisterPlayerUnitEvent(qx,Player(nx),ax,null)
set nx=nx+1
exitwhen nx==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Bs,Condition(vp))
call TriggerAddAction(Bs,mp)
set qx=null
set ax=null
endfunction
function eE takes nothing returns nothing
local trigger bE
local playerunitevent yE
local integer pE
set xt=CreateTrigger()
set bE=xt
set yE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set pE=0
loop
call TriggerRegisterPlayerUnitEvent(bE,Player(pE),yE,null)
set pE=pE+1
exitwhen pE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(xt,Condition(Ae))
call TriggerAddAction(xt,De)
set bE=null
set yE=null
endfunction
function eY takes nothing returns nothing
local trigger bY
local playerunitevent yY
local integer pY
set gs=CreateTrigger()
set bY=gs
set yY=EVENT_PLAYER_UNIT_ATTACKED
set pY=0
loop
call TriggerRegisterPlayerUnitEvent(bY,Player(pY),yY,null)
set pY=pY+1
exitwhen pY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gs,Condition(ky))
call TriggerAddAction(gs,jy)
set bY=null
set yY=null
endfunction
function ek takes nothing returns nothing
local trigger bk
local playerunitevent yk
local integer pk
set Js=CreateTrigger()
set bk=Js
set yk=EVENT_PLAYER_UNIT_SPELL_CAST
set pk=0
loop
call TriggerRegisterPlayerUnitEvent(bk,Player(pk),yk,null)
set pk=pk+1
exitwhen pk==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Js,Condition(dp))
call TriggerAddAction(Js,fp)
set bk=null
set yk=null
endfunction
function fF takes nothing returns nothing
set As=CreateTrigger()
call TriggerRegisterTimerEvent(As,5.00,true)
call TriggerAddAction(As,pp)
endfunction
function fP takes nothing returns nothing
local trigger aP
local playerunitevent nP
local integer dP
set Oi=CreateTrigger()
set aP=Oi
set nP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set dP=0
loop
call TriggerRegisterPlayerUnitEvent(aP,Player(dP),nP,null)
set dP=dP+1
exitwhen dP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Oi,Condition(Mq))
call TriggerAddAction(Oi,wa)
set aP=null
set nP=null
endfunction
function fZ takes nothing returns nothing
local trigger aZ
local playerunitevent nZ
local integer dZ
set It=CreateTrigger()
set aZ=It
set nZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set dZ=0
loop
call TriggerRegisterPlayerUnitEvent(aZ,Player(dZ),nZ,null)
set dZ=dZ+1
exitwhen dZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(It,Condition(tq))
call TriggerAddAction(It,iq)
set aZ=null
set nZ=null
endfunction
function gA takes nothing returns nothing
local trigger TA
local playerunitevent YA
local integer GA
set ni=CreateTrigger()
set TA=ni
set YA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set GA=0
loop
call TriggerRegisterPlayerUnitEvent(TA,Player(GA),YA,null)
set GA=GA+1
exitwhen GA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ni,Condition(qa))
call TriggerAddAction(ni,aa)
set TA=null
set YA=null
endfunction
function gJ takes nothing returns nothing
local trigger TJ
local playerunitevent YJ
local integer GJ
set Ei=CreateTrigger()
set TJ=Ei
set YJ=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set GJ=0
loop
call TriggerRegisterPlayerUnitEvent(TJ,Player(GJ),YJ,null)
set GJ=GJ+1
exitwhen GJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ei,Condition(Ma))
call TriggerAddAction(Ei,wn)
set TJ=null
set YJ=null
endfunction
function gm takes nothing returns nothing
local trigger Tm
local playerunitevent Ym
local integer Gm
set ot=CreateTrigger()
set Tm=ot
set Ym=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Gm=0
loop
call TriggerRegisterPlayerUnitEvent(Tm,Player(Gm),Ym,null)
set Gm=Gm+1
exitwhen Gm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ot,Condition(Bp))
call TriggerAddAction(ot,Np)
set Tm=null
set Ym=null
endfunction
function hD takes nothing returns nothing
set hi=CreateTrigger()
call TriggerRegisterTimerEvent(hi,0.10,false)
call TriggerAddAction(hi,Qa)
endfunction
function hI takes nothing returns nothing
local trigger YI
local playerunitevent GI
local integer gI
set ri=CreateTrigger()
set YI=ri
set GI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set gI=0
loop
call TriggerRegisterPlayerUnitEvent(YI,Player(gI),GI,null)
set gI=gI+1
exitwhen gI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ri,Condition(Uq))
call TriggerAddAction(ri,Iq)
set YI=null
set GI=null
endfunction
function iP takes nothing returns nothing
local trigger rP
local playerunitevent sP
local integer tP
set ci=CreateTrigger()
set rP=ci
set sP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set tP=0
loop
call TriggerRegisterPlayerUnitEvent(rP,Player(tP),sP,null)
set tP=tP+1
exitwhen tP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ci,Condition(Cq))
call TriggerAddAction(ci,Vq)
set rP=null
set sP=null
endfunction
function iZ takes nothing returns nothing
local trigger rZ
local playerunitevent sZ
local integer tZ
set Zt=CreateTrigger()
set rZ=Zt
set sZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set tZ=0
loop
call TriggerRegisterPlayerUnitEvent(rZ,Player(tZ),sZ,null)
set tZ=tZ+1
exitwhen tZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Zt,Condition(wq))
call TriggerAddAction(Zt,uq)
set rZ=null
set sZ=null
endfunction
function iv takes nothing returns nothing
local trigger rv
local playerunitevent sv
local integer tv
set Ms=CreateTrigger()
set rv=Ms
set sv=EVENT_PLAYER_UNIT_SPELL_CAST
set tv=0
loop
call TriggerRegisterPlayerUnitEvent(rv,Player(tv),sv,null)
set tv=tv+1
exitwhen tv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ms,Condition(Ep))
call TriggerAddAction(Ms,Zp)
set rv=null
set sv=null
endfunction
function jE takes nothing returns nothing
local trigger hE
local playerunitevent FE
local integer kE
set mt=CreateTrigger()
set hE=mt
set FE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set kE=0
loop
call TriggerRegisterPlayerUnitEvent(hE,Player(kE),FE,null)
set kE=kE+1
exitwhen kE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(mt,Condition(Ke))
call TriggerAddAction(mt,Le)
set hE=null
set FE=null
endfunction
function jG takes nothing returns nothing
local trigger hG
local playerunitevent FG
local integer kG
set vs=CreateTrigger()
set hG=vs
set FG=EVENT_PLAYER_UNIT_SPELL_CAST
set kG=0
loop
call TriggerRegisterPlayerUnitEvent(hG,Player(kG),FG,null)
set kG=kG+1
exitwhen kG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(vs,Py)
set hG=null
set FG=null
endfunction
function jg takes nothing returns nothing
local trigger hg
local playerunitevent Fg
local integer kg
set Ws=CreateTrigger()
set hg=Ws
set Fg=EVENT_PLAYER_UNIT_SPELL_CAST
set kg=0
loop
call TriggerRegisterPlayerUnitEvent(hg,Player(kg),Fg,null)
set kg=kg+1
exitwhen kg==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ws,Condition(Cy))
call TriggerAddAction(Ws,Vy)
set hg=null
set Fg=null
endfunction
function jh takes nothing returns nothing
local trigger hh
local playerunitevent Fh
local integer kh
set Us=CreateTrigger()
set hh=Us
set Fh=EVENT_PLAYER_UNIT_SPELL_CAST
set kh=0
loop
call TriggerRegisterPlayerUnitEvent(hh,Player(kh),Fh,null)
set kh=kh+1
exitwhen kh==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Us,Condition(tp))
call TriggerAddAction(Us,ip)
set hh=null
set Fh=null
endfunction
function kF takes nothing returns nothing
set Ds=CreateTrigger()
call TriggerRegisterTimerEvent(Ds,5.00,true)
call TriggerAddAction(Ds,qp)
endfunction
function kL takes nothing returns nothing
local trigger gL
local playerunitevent hL
local integer FL
set Ni=CreateTrigger()
set gL=Ni
set hL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set FL=0
loop
call TriggerRegisterPlayerUnitEvent(gL,Player(FL),hL,null)
set FL=FL+1
exitwhen FL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ni,Condition(vn))
call TriggerAddAction(Ni,mn)
set gL=null
set hL=null
endfunction
function kU takes nothing returns nothing
local trigger gU
local playerunitevent hU
local integer FU
set Ct=CreateTrigger()
set gU=Ct
set hU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set FU=0
loop
call TriggerRegisterPlayerUnitEvent(gU,Player(FU),hU,null)
set FU=FU+1
exitwhen FU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ct,Condition(Yq))
call TriggerAddAction(Ct,Gq)
set gU=null
set hU=null
endfunction
function kW takes nothing returns nothing
local trigger gW
local playerunitevent hW
local integer FW
set Gt=CreateTrigger()
set gW=Gt
set hW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set FW=0
loop
call TriggerRegisterPlayerUnitEvent(gW,Player(FW),hW,null)
set FW=FW+1
exitwhen FW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Gt,Condition(ke))
call TriggerAddAction(Gt,je)
set gW=null
set hW=null
endfunction
function lA takes nothing returns nothing
local trigger cA
local playerunitevent oA
local integer OA
set qi=CreateTrigger()
set cA=qi
set oA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set OA=0
loop
call TriggerRegisterPlayerUnitEvent(cA,Player(OA),oA,null)
set OA=OA+1
exitwhen OA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(qi,Condition(ba))
call TriggerAddAction(qi,ya)
set cA=null
set oA=null
endfunction
function lJ takes nothing returns nothing
local trigger cJ
local playerunitevent oJ
local integer OJ
set Qi=CreateTrigger()
set cJ=Qi
set oJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set OJ=0
loop
call TriggerRegisterPlayerUnitEvent(cJ,Player(OJ),oJ,null)
set OJ=OJ+1
exitwhen OJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Qi,Condition(Ca))
call TriggerAddAction(Qi,Va)
set cJ=null
set oJ=null
endfunction
function lm takes nothing returns nothing
local trigger cm
local playerunitevent om
local integer Om
set St=CreateTrigger()
set cm=St
set om=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Om=0
loop
call TriggerRegisterPlayerUnitEvent(cm,Player(Om),om,null)
set Om=Om+1
exitwhen Om==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(St,Condition(Lp))
call TriggerAddAction(St,Xp)
set cm=null
set om=null
endfunction
function mA takes nothing returns nothing
local trigger jA
local playerunitevent xA
local integer vA
set di=CreateTrigger()
set jA=di
set xA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set vA=0
loop
call TriggerRegisterPlayerUnitEvent(jA,Player(vA),xA,null)
set vA=vA+1
exitwhen vA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(di,Condition(na))
call TriggerAddAction(di,da)
set jA=null
set xA=null
endfunction
function mJ takes nothing returns nothing
local trigger jJ
local playerunitevent xJ
local integer vJ
set Zi=CreateTrigger()
set jJ=Zi
set xJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set vJ=0
loop
call TriggerRegisterPlayerUnitEvent(jJ,Player(vJ),xJ,null)
set vJ=vJ+1
exitwhen vJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Zi,Condition(un))
call TriggerAddAction(Zi,rn)
set jJ=null
set xJ=null
endfunction
function mm takes nothing returns nothing
local trigger jm
local playerunitevent xm
local integer vm
set Ot=CreateTrigger()
set jm=Ot
set xm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set vm=0
loop
call TriggerRegisterPlayerUnitEvent(jm,Player(vm),xm,null)
set vm=vm+1
exitwhen vm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ot,Condition(Mp))
call TriggerAddAction(Ot,we)
set jm=null
set xm=null
endfunction
function nA takes nothing returns nothing
local trigger eA
local playerunitevent qA
local integer aA
set ai=CreateTrigger()
set eA=ai
set qA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set aA=0
loop
call TriggerRegisterPlayerUnitEvent(eA,Player(aA),qA,null)
set aA=aA+1
exitwhen aA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ai,Condition(pa))
call TriggerAddAction(ai,ea)
set eA=null
set qA=null
endfunction
function nJ takes nothing returns nothing
local trigger eJ
local playerunitevent qJ
local integer aJ
set Wi=CreateTrigger()
set eJ=Wi
set qJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set aJ=0
loop
call TriggerRegisterPlayerUnitEvent(eJ,Player(aJ),qJ,null)
set aJ=aJ+1
exitwhen aJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Wi,Condition(Ba))
call TriggerAddAction(Wi,Na)
set eJ=null
set qJ=null
endfunction
function nm takes nothing returns nothing
local trigger em
local playerunitevent qm
local integer am
set ct=CreateTrigger()
set em=ct
set qm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set am=0
loop
call TriggerRegisterPlayerUnitEvent(em,Player(am),qm,null)
set am=am+1
exitwhen am==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ct,Condition(Cp))
call TriggerAddAction(ct,Vp)
set em=null
set qm=null
endfunction
function oD takes nothing returns nothing
local trigger iD
local playerunitevent SD
local integer cD
set Yi=CreateTrigger()
set iD=Yi
set SD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set cD=0
loop
call TriggerRegisterPlayerUnitEvent(iD,Player(cD),SD,null)
set cD=cD+1
exitwhen cD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Yi,Condition(ha))
call TriggerAddAction(Yi,Fa)
set iD=null
set SD=null
endfunction
function oK takes nothing returns nothing
local trigger iK
local playerunitevent SK
local integer cK
set Ai=CreateTrigger()
set iK=Ai
set SK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set cK=0
loop
call TriggerRegisterPlayerUnitEvent(iK,Player(cK),SK,null)
set cK=cK+1
exitwhen cK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ai,Condition(ln))
call TriggerAddAction(Ai,bn)
set iK=null
set SK=null
endfunction
function oQ takes nothing returns nothing
local trigger iQ
local playerunitevent SQ
local integer cQ
set pt=CreateTrigger()
set iQ=pt
set SQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set cQ=0
loop
call TriggerRegisterPlayerUnitEvent(iQ,Player(cQ),SQ,null)
set cQ=cQ+1
exitwhen cQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(pt,Condition(ce))
call TriggerAddAction(pt,oe)
set iQ=null
set SQ=null
endfunction
function pL takes nothing returns nothing
local trigger lL
local playerunitevent bL
local integer yL
set Vi=CreateTrigger()
set lL=Vi
set bL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set yL=0
loop
call TriggerRegisterPlayerUnitEvent(lL,Player(yL),bL,null)
set yL=yL+1
exitwhen yL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Vi,Condition(Fn))
call TriggerAddAction(Vi,kn)
set lL=null
set bL=null
endfunction
function pU takes nothing returns nothing
local trigger lU
local playerunitevent bU
local integer yU
set Lt=CreateTrigger()
set lU=Lt
set bU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set yU=0
loop
call TriggerRegisterPlayerUnitEvent(lU,Player(yU),bU,null)
set yU=yU+1
exitwhen yU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Lt,Condition(dq))
call TriggerAddAction(Lt,fq)
set lU=null
set bU=null
endfunction
function pW takes nothing returns nothing
local trigger lW
local playerunitevent bW
local integer yW
set Tt=CreateTrigger()
set lW=Tt
set bW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set yW=0
loop
call TriggerRegisterPlayerUnitEvent(lW,Player(yW),bW,null)
set yW=yW+1
exitwhen yW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Tt,Condition(Ge))
call TriggerAddAction(Tt,ge)
set lW=null
set bW=null
endfunction
function qD takes nothing returns nothing
local trigger yD
local playerunitevent pD
local integer eD
set Gi=CreateTrigger()
set yD=Gi
set pD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set eD=0
loop
call TriggerRegisterPlayerUnitEvent(yD,Player(eD),pD,null)
set eD=eD+1
exitwhen eD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Gi,Condition(ka))
call TriggerAddAction(Gi,ja)
set yD=null
set pD=null
endfunction
function qG takes nothing returns nothing
local trigger yG
local playerunitevent pG
local integer eG
set xs=CreateTrigger()
set yG=xs
set pG=EVENT_PLAYER_UNIT_SPELL_CAST
set eG=0
loop
call TriggerRegisterPlayerUnitEvent(yG,Player(eG),pG,null)
set eG=eG+1
exitwhen eG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(xs,Iy)
set yG=null
set pG=null
endfunction
function qK takes nothing returns nothing
local trigger yK
local playerunitevent pK
local integer eK
set Di=CreateTrigger()
set yK=Di
set pK=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set eK=0
loop
call TriggerRegisterPlayerUnitEvent(yK,Player(eK),pK,null)
set eK=eK+1
exitwhen eK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Di,Condition(yn))
call TriggerAddAction(Di,pn)
set yK=null
set pK=null
endfunction
function qQ takes nothing returns nothing
local trigger yQ
local playerunitevent pQ
local integer eQ
set et=CreateTrigger()
set yQ=et
set pQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set eQ=0
loop
call TriggerRegisterPlayerUnitEvent(yQ,Player(eQ),pQ,null)
set eQ=eQ+1
exitwhen eQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(et,Condition(Oe))
call TriggerAddAction(et,le)
set yQ=null
set pQ=null
endfunction
function rG takes nothing returns nothing
local trigger MY
local playerunitevent wG
local integer uG
set js=CreateTrigger()
set MY=js
set wG=EVENT_PLAYER_UNIT_SPELL_EFFECT
set uG=0
loop
call TriggerRegisterPlayerUnitEvent(MY,Player(uG),wG,null)
set uG=uG+1
exitwhen uG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(js,Condition(Zy))
call TriggerAddAction(js,Uy)
set MY=null
set wG=null
endfunction
function rY takes nothing returns nothing
local trigger MT
local playerunitevent wY
local integer uY
set Gs=CreateTrigger()
set MT=Gs
set wY=EVENT_PLAYER_UNIT_ATTACKED
set uY=0
loop
call TriggerRegisterPlayerUnitEvent(MT,Player(uY),wY,null)
set uY=uY+1
exitwhen uY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Gs,Condition(hy))
call TriggerAddAction(Gs,Fy)
set MT=null
set wY=null
endfunction
function sA takes nothing returns nothing
local trigger wA
local playerunitevent uA
local integer rA
set ei=CreateTrigger()
set wA=ei
set uA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set rA=0
loop
call TriggerRegisterPlayerUnitEvent(wA,Player(rA),uA,null)
set rA=rA+1
exitwhen rA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ei,Condition(Oa))
call TriggerAddAction(ei,la)
set wA=null
set uA=null
endfunction
function sm takes nothing returns nothing
local trigger wm
local playerunitevent um
local integer rm
set tt=CreateTrigger()
set wm=tt
set um=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set rm=0
loop
call TriggerRegisterPlayerUnitEvent(wm,Player(rm),um,null)
set rm=rm+1
exitwhen rm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(tt,Condition(Jp))
call TriggerAddAction(tt,Kp)
set wm=null
set um=null
endfunction
function tI takes nothing returns nothing
local trigger uI
local playerunitevent rI
local integer sI
set Mt=CreateTrigger()
set uI=Mt
set rI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set sI=0
loop
call TriggerRegisterPlayerUnitEvent(uI,Player(sI),rI,null)
set sI=sI+1
exitwhen sI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Mt,Condition(vq))
call TriggerAddAction(Mt,mq)
set uI=null
set rI=null
endfunction
function tX takes nothing returns nothing
local trigger uX
local playerunitevent rX
local integer sX
set rS=CreateTrigger()
set uX=rS
set rX=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set sX=0
loop
call TriggerRegisterPlayerUnitEvent(uX,Player(sX),rX,null)
set sX=sX+1
exitwhen sX==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(rS,Condition(Pn))
call TriggerAddAction(rS,An)
set uX=null
set rX=null
endfunction
function uD takes nothing returns nothing
local trigger NA
local playerunitevent MA
local integer wD
set Ti=CreateTrigger()
set NA=Ti
set MA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set wD=0
loop
call TriggerRegisterPlayerUnitEvent(NA,Player(wD),MA,null)
set wD=wD+1
exitwhen wD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ti,Condition(Ga))
call TriggerAddAction(Ti,ga)
set NA=null
set MA=null
endfunction
function uK takes nothing returns nothing
local trigger NJ
local playerunitevent MJ
local integer wK
set Pi=CreateTrigger()
set NJ=Pi
set MJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set wK=0
loop
call TriggerRegisterPlayerUnitEvent(NJ,Player(wK),MJ,null)
set wK=wK+1
exitwhen wK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Pi,Condition(on))
call TriggerAddAction(Pi,On)
set NJ=null
set MJ=null
endfunction
function uQ takes nothing returns nothing
local trigger Nm
local playerunitevent Mm
local integer wQ
set yt=CreateTrigger()
set Nm=yt
set Mm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set wQ=0
loop
call TriggerRegisterPlayerUnitEvent(Nm,Player(wQ),Mm,null)
set wQ=wQ+1
exitwhen wQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(yt,Condition(ie))
call TriggerAddAction(yt,Se)
set Nm=null
set Mm=null
endfunction
function uj takes nothing returns nothing
local trigger Nk
local playerunitevent Mk
local integer wj
set Ls=CreateTrigger()
set Nk=Ls
set Mk=EVENT_PLAYER_UNIT_SPELL_CAST
set wj=0
loop
call TriggerRegisterPlayerUnitEvent(Nk,Player(wj),Mk,null)
set wj=wj+1
exitwhen wj==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ls,Condition(Yp))
call TriggerAddAction(Ls,Gp)
set Nk=null
set Mk=null
endfunction
function ux takes nothing returns nothing
local trigger Nj
local playerunitevent Mj
local integer wx
set Vs=CreateTrigger()
set Nj=Vs
set Mj=EVENT_PLAYER_UNIT_DEATH
set wx=0
loop
call TriggerRegisterPlayerUnitEvent(Nj,Player(wx),Mj,null)
set wx=wx+1
exitwhen wx==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Vs,Condition(jp))
call TriggerAddAction(Vs,xp)
set Nj=null
set Mj=null
endfunction
function wE takes nothing returns nothing
local trigger BW
local playerunitevent NW
local integer MW
set kt=CreateTrigger()
set BW=kt
set NW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set MW=0
loop
call TriggerRegisterPlayerUnitEvent(BW,Player(MW),NW,null)
set MW=MW+1
exitwhen MW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(kt,Condition(Ze))
call TriggerAddAction(kt,Ue)
set BW=null
set NW=null
endfunction
function xK takes nothing returns nothing
local trigger FK
local playerunitevent kK
local integer jK
set Ji=CreateTrigger()
set FK=Ji
set kK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set jK=0
loop
call TriggerRegisterPlayerUnitEvent(FK,Player(jK),kK,null)
set jK=jK+1
exitwhen jK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ji,Condition(an))
call TriggerAddAction(Ji,nn)
set FK=null
set kK=null
endfunction
function xQ takes nothing returns nothing
local trigger FQ
local playerunitevent kQ
local integer jQ
set at=CreateTrigger()
set FQ=at
set kQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set jQ=0
loop
call TriggerRegisterPlayerUnitEvent(FQ,Player(jQ),kQ,null)
set jQ=jQ+1
exitwhen jQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(at,Condition(pe))
call TriggerAddAction(at,ee)
set FQ=null
set kQ=null
endfunction
function yP takes nothing returns nothing
local trigger OP
local playerunitevent lP
local integer bP
set oi=CreateTrigger()
set OP=oi
set lP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set bP=0
loop
call TriggerRegisterPlayerUnitEvent(OP,Player(bP),lP,null)
set bP=bP+1
exitwhen bP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(oi,Condition(Bq))
call TriggerAddAction(oi,Nq)
set OP=null
set lP=null
endfunction
function yZ takes nothing returns nothing
local trigger OZ
local playerunitevent lZ
local integer bZ
set Ut=CreateTrigger()
set OZ=Ut
set lZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set bZ=0
loop
call TriggerRegisterPlayerUnitEvent(OZ,Player(bZ),lZ,null)
set bZ=bZ+1
exitwhen bZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ut,Condition(rq))
call TriggerAddAction(Ut,sq)
set OZ=null
set lZ=null
endfunction
function iX takes nothing returns nothing
call PT()
set Ts=CreateTrigger()
call TriggerAddAction(Ts,Dn)
call HT()
call rY()
call eY()
call FY()
call PY()
call VY()
call rG()
call qG()
call jG()
call XG()
call bg()
call jg()
call Xg()
call bh()
call jh()
call Xh()
call bF()
call fF()
call kF()
call CF()
call ek()
call Wk()
call uj()
call dj()
call Zj()
call ux()
call dx()
call Ix()
call iv()
set wt=CreateTrigger()
call TriggerAddAction(wt,Hn)
call Gv()
call Dv()
call Vv()
call sm()
call lm()
call nm()
call gm()
call mm()
call Pm()
call Xm()
call uQ()
call oQ()
call qQ()
call YQ()
call xQ()
call UQ()
call KQ()
call MQ()
call SW()
call pW()
call RW()
call kW()
call EW()
call HW()
call LW()
call wE()
call cE()
call eE()
call TE()
call jE()
call ZE()
call JE()
call NE()
call iZ()
call yZ()
call fZ()
call FZ()
call WZ()
call DZ()
call VZ()
call MZ()
call SU()
call pU()
call RU()
call kU()
call EU()
call HU()
call BU()
call tI()
call bI()
call dI()
call hI()
call QI()
call AI()
call CI()
call NI()
call iP()
call yP()
call fP()
call FP()
call WP()
call DP()
call VP()
call sA()
call lA()
call nA()
call gA()
call mA()
call PA()
call XA()
call uD()
call oD()
call qD()
call YD()
call hD()
call PD()
call KD()
call SH()
call RH()
call WH()
call VH()
call lJ()
call nJ()
call gJ()
call mJ()
call PJ()
call XJ()
call uK()
call oK()
call qK()
call YK()
call xK()
call UK()
call KK()
call MK()
call SL()
call pL()
call RL()
call kL()
call EL()
call HL()
call BL()
call tX()
endfunction
function mT takes nothing returns nothing
local player vT=Player(PLAYER_NEUTRAL_AGGRESSIVE)
call CreateUnit(vT,1747989297,-1600.0,-128.0,270.000)
call CreateUnit(vT,1747989297,-15040.0,10816.0,270.000)
call CreateUnit(vT,1747989297,-256.0,-2432.0,270.000)
call CreateUnit(vT,1747989297,-24320.0,3904.0,270.000)
call CreateUnit(vT,1747989297,-23552.0,-4544.0,270.000)
call CreateUnit(vT,1747989297,-23360.0,-64.0,270.000)
call CreateUnit(vT,1747989297,2176.0,-7744.0,270.000)
call CreateUnit(vT,1747989297,-6336.0,8000.0,270.000)
call CreateUnit(vT,1747989297,832.0,-5568.0,270.000)
call CreateUnit(vT,1747989297,-3648.0,1856.0,270.000)
call CreateUnit(vT,1747989042,-768.0,24384.0,270.000)
call CreateUnit(vT,1747989297,-26304.0,-8704.0,270.000)
call CreateUnit(vT,1747989297,2688.0,-3008.0,270.000)
call CreateUnit(vT,1747989297,-5568.0,-2752.0,270.000)
call CreateUnit(vT,1747989297,-3456.0,-2880.0,270.000)
call CreateUnit(vT,1747989297,-6464.0,1280.0,270.000)
call CreateUnit(vT,1747989297,-8064.0,3200.0,270.000)
call CreateUnit(vT,1747989297,-8768.0,1984.0,270.000)
call CreateUnit(vT,1747989297,-7104.0,-768.0,270.000)
call CreateUnit(vT,1747989297,-28544.0,0.0,270.000)
call CreateUnit(vT,1747989297,-27840.0,-2752.0,270.000)
call CreateUnit(vT,1747989297,-27008.0,2688.0,270.000)
call CreateUnit(vT,1747989297,-17024.0,512.0,270.000)
call CreateUnit(vT,1747989297,-21696.0,-4224.0,270.000)
call CreateUnit(vT,1747989042,17536.0,-9024.0,270.000)
call CreateUnit(vT,1747989297,10816.0,-7360.0,270.000)
call CreateUnit(vT,1747989297,12800.0,-6912.0,270.000)
call CreateUnit(vT,1747989297,15488.0,-7552.0,270.000)
call CreateUnit(vT,1747989297,19072.0,-7424.0,270.000)
call CreateUnit(vT,1747989297,15360.0,-5568.0,270.000)
call CreateUnit(vT,1747989297,17216.0,-8640.0,270.000)
call CreateUnit(vT,1747989297,16960.0,-16192.0,270.000)
call CreateUnit(vT,1747989297,6976.0,-6592.0,270.000)
call CreateUnit(vT,1747989297,24000.0,256.0,270.000)
call CreateUnit(vT,1747989297,-10688.0,-384.0,270.000)
call CreateUnit(vT,1747989297,13952.0,-11008.0,270.000)
call CreateUnit(vT,1747989297,-10944.0,-4608.0,270.000)
call CreateUnit(vT,1747989297,-21440.0,-8384.0,270.000)
call CreateUnit(vT,1747989297,17472.0,9472.0,270.000)
call CreateUnit(vT,1747989297,-16768.0,-8064.0,270.000)
call CreateUnit(vT,1747989297,-9920.0,-11264.0,270.000)
call CreateUnit(vT,1747989297,-7488.0,-16256.0,270.000)
call CreateUnit(vT,1747989297,448.0,-17600.0,270.000)
call CreateUnit(vT,1747989297,11008.0,-18496.0,270.000)
call CreateUnit(vT,1747989297,13248.0,-17856.0,270.000)
call CreateUnit(vT,1747989297,12288.0,-20864.0,270.000)
call CreateUnit(vT,1747989297,-11456.0,11008.0,270.000)
call CreateUnit(vT,1747989297,-8640.0,7104.0,270.000)
call CreateUnit(vT,1747989297,-7360.0,17088.0,270.000)
call CreateUnit(vT,1747989297,-5120.0,14528.0,270.000)
call CreateUnit(vT,1747989297,15488.0,-26816.0,270.000)
call CreateUnit(vT,1747989297,-9600.0,13120.0,270.000)
call CreateUnit(vT,1747989297,-11456.0,14528.0,270.000)
call CreateUnit(vT,1747989297,-12544.0,16320.0,270.000)
call CreateUnit(vT,1747989297,-7680.0,22272.0,270.000)
call CreateUnit(vT,1747989297,-6272.0,21376.0,270.000)
call CreateUnit(vT,1747989297,-4992.0,21888.0,270.000)
call CreateUnit(vT,1747989297,-1280.0,23936.0,270.000)
call CreateUnit(vT,1747989297,-3328.0,23232.0,270.000)
call CreateUnit(vT,1747989297,-2560.0,26368.0,270.000)
call CreateUnit(vT,1747989297,-6528.0,28288.0,270.000)
call CreateUnit(vT,1747989297,-9856.0,28416.0,270.000)
call CreateUnit(vT,1747989297,-13376.0,15104.0,270.000)
call CreateUnit(vT,1747989297,-10688.0,3520.0,270.000)
call CreateUnit(vT,1747989297,-9856.0,5440.0,270.000)
call CreateUnit(vT,1747989297,-6720.0,4096.0,270.000)
call CreateUnit(vT,1747989297,-13632.0,2368.0,270.000)
call CreateUnit(vT,1747989297,-10496.0,17728.0,270.000)
call CreateUnit(vT,1747989297,-7616.0,11200.0,270.000)
call CreateUnit(vT,1747989297,-18688.0,5760.0,270.000)
call CreateUnit(vT,1747989297,-25024.0,-3008.0,270.000)
call CreateUnit(vT,1747989297,-20096.0,1408.0,270.000)
call CreateUnit(vT,1747989297,-7040.0,-7808.0,270.000)
call CreateUnit(vT,1747989297,-5376.0,-9216.0,270.000)
call CreateUnit(vT,1747989297,24896.0,-27456.0,270.000)
call CreateUnit(vT,1747989297,-20352.0,12224.0,270.000)
call CreateUnit(vT,1747989297,-13568.0,5184.0,270.000)
call CreateUnit(vT,1747989297,-5120.0,24576.0,270.000)
call CreateUnit(vT,1747989297,-1856.0,27776.0,270.000)
call CreateUnit(vT,1747989297,-16704.0,24192.0,270.000)
call CreateUnit(vT,1747989297,-15936.0,17088.0,270.000)
call CreateUnit(vT,1747989297,-17792.0,16064.0,270.000)
call CreateUnit(vT,1747989297,-20224.0,21632.0,270.000)
call CreateUnit(vT,1747989297,-22400.0,19968.0,270.000)
call CreateUnit(vT,1747989297,-15872.0,20544.0,270.000)
call CreateUnit(vT,1747989297,-19776.0,16512.0,270.000)
call CreateUnit(vT,1747989297,-17088.0,12672.0,270.000)
call CreateUnit(vT,1747989297,-18560.0,19712.0,270.000)
call CreateUnit(vT,1747989297,-15680.0,26112.0,270.000)
call CreateUnit(vT,1747989297,-17088.0,26816.0,270.000)
call CreateUnit(vT,1747989297,-16704.0,3584.0,270.000)
call CreateUnit(vT,1747989297,-11456.0,7232.0,270.000)
call CreateUnit(vT,1747989297,-18176.0,10816.0,270.000)
call CreateUnit(vT,1747989297,-16000.0,6016.0,270.000)
call CreateUnit(vT,1747989297,-8896.0,26688.0,270.000)
call CreateUnit(vT,1747989297,9216.0,-4416.0,270.000)
call CreateUnit(vT,1747989297,6656.0,-4480.0,270.000)
call CreateUnit(vT,1747989297,5184.0,-1856.0,270.000)
call CreateUnit(vT,1747989297,18624.0,-448.0,270.000)
call CreateUnit(vT,1747989297,11008.0,-1984.0,270.000)
call CreateUnit(vT,1747989297,14144.0,-128.0,270.000)
call CreateUnit(vT,1747989297,8384.0,-10368.0,270.000)
call CreateUnit(vT,1747989297,5376.0,-12224.0,270.000)
call CreateUnit(vT,1747989297,3392.0,-7296.0,270.000)
call CreateUnit(vT,1747989297,12672.0,-3904.0,270.000)
call CreateUnit(vT,1747989297,27008.0,-11520.0,270.000)
call CreateUnit(vT,1747989297,-25216.0,1472.0,270.000)
call CreateUnit(vT,1747989297,23552.0,11072.0,270.000)
call CreateUnit(vT,1747989297,-20736.0,-2112.0,270.000)
call CreateUnit(vT,1747989297,-22592.0,2560.0,270.000)
call CreateUnit(vT,1747989297,-20864.0,3136.0,270.000)
call CreateUnit(vT,1747989297,-17280.0,-3136.0,270.000)
call CreateUnit(vT,1747989297,-3584.0,4608.0,270.000)
call CreateUnit(vT,1747989297,1536.0,29440.0,270.000)
call CreateUnit(vT,1747989297,-23104.0,-8832.0,270.000)
call CreateUnit(vT,1747989297,1216.0,-960.0,270.000)
call CreateUnit(vT,1747989297,-13312.0,-8512.0,270.000)
call CreateUnit(vT,1747989297,26240.0,-2688.0,270.000)
call CreateUnit(vT,1747989043,-7872.0,17536.0,270.000)
call CreateUnit(vT,1747989297,-13568.0,12160.0,270.000)
call CreateUnit(vT,1747989297,-13696.0,8064.0,270.000)
call CreateUnit(vT,1747989297,27648.0,-5824.0,270.000)
call CreateUnit(vT,1747989297,-4544.0,11648.0,270.000)
call CreateUnit(vT,1747989297,28992.0,-3200.0,270.000)
call CreateUnit(vT,1747989297,-3072.0,8320.0,270.000)
call CreateUnit(vT,1747989297,-384.0,8512.0,270.000)
call CreateUnit(vT,1747989297,28224.0,2752.0,270.000)
call CreateUnit(vT,1747989297,-4992.0,17280.0,270.000)
call CreateUnit(vT,1747989297,64.0,12608.0,270.000)
call CreateUnit(vT,1747989297,-2112.0,13696.0,270.000)
call CreateUnit(vT,1747989297,4160.0,5376.0,270.000)
call CreateUnit(vT,1747989297,4224.0,3904.0,270.000)
call CreateUnit(vT,1747989297,7232.0,2240.0,270.000)
call CreateUnit(vT,1747989297,-384.0,3072.0,270.000)
call CreateUnit(vT,1747989297,-8128.0,19968.0,270.000)
call CreateUnit(vT,1747989297,3072.0,192.0,270.000)
call CreateUnit(vT,1747989297,832.0,15872.0,270.000)
call CreateUnit(vT,1747989297,-2304.0,16064.0,270.000)
call CreateUnit(vT,1747989297,4416.0,19648.0,270.000)
call CreateUnit(vT,1747989297,1792.0,6976.0,270.000)
call CreateUnit(vT,1747989297,5888.0,24960.0,270.000)
call CreateUnit(vT,1747989297,-1792.0,19200.0,270.000)
call CreateUnit(vT,1747989297,3008.0,22784.0,270.000)
call CreateUnit(vT,1747989297,3200.0,18240.0,270.000)
call CreateUnit(vT,1747989297,-3712.0,-6528.0,270.000)
call CreateUnit(vT,1747989297,-17216.0,22208.0,270.000)
call CreateUnit(vT,1747989297,-18880.0,17920.0,270.000)
call CreateUnit(vT,1747989297,-17280.0,18304.0,270.000)
call CreateUnit(vT,1747989297,-22272.0,22400.0,270.000)
call CreateUnit(vT,1747989297,-10496.0,-9152.0,270.000)
call CreateUnit(vT,1747989297,13248.0,5120.0,270.000)
call CreateUnit(vT,1747989297,7936.0,-2368.0,270.000)
call CreateUnit(vT,1747989297,3520.0,27008.0,270.000)
call CreateUnit(vT,1747989297,8832.0,26368.0,270.000)
call CreateUnit(vT,1747989297,6848.0,21440.0,270.000)
call CreateUnit(vT,1747989297,6144.0,18560.0,270.000)
call CreateUnit(vT,1747989297,3904.0,11072.0,270.000)
call CreateUnit(vT,1747989297,8512.0,12352.0,270.000)
call CreateUnit(vT,1747989297,9280.0,20032.0,270.000)
call CreateUnit(vT,1747989297,1216.0,11008.0,270.000)
call CreateUnit(vT,1747989044,-15680.0,11200.0,270.000)
call CreateUnit(vT,1747989044,-15104.0,17408.0,270.000)
call CreateUnit(vT,1747989045,-1728.0,28608.0,270.000)
call CreateUnit(vT,1747989043,-18304.0,18112.0,270.000)
call CreateUnit(vT,1747989044,-9600.0,13888.0,270.000)
call CreateUnit(vT,1747989297,384.0,19456.0,270.000)
call CreateUnit(vT,1747989044,4864.0,5952.0,270.000)
call CreateUnit(vT,1747989044,8000.0,-1664.0,270.000)
call CreateUnit(vT,1747989044,9280.0,-3008.0,270.000)
call CreateUnit(vT,1747989045,-21056.0,21056.0,270.000)
call CreateUnit(vT,1747989045,-19648.0,12224.0,270.000)
call CreateUnit(vT,1747989045,17984.0,-13120.0,270.000)
call CreateUnit(vT,1747989042,-28544.0,704.0,270.000)
call CreateUnit(vT,1747989045,-9344.0,7168.0,270.000)
call CreateUnit(vT,1747989043,-6336.0,8576.0,270.000)
call CreateUnit(vT,1747989045,-15616.0,21248.0,270.000)
call CreateUnit(vT,1747989045,-16640.0,1024.0,270.000)
call CreateUnit(vT,1747989045,13760.0,-11584.0,270.000)
call CreateUnit(vT,1747989042,-11328.0,3712.0,270.000)
call CreateUnit(vT,1747989042,-16768.0,25920.0,270.000)
call CreateUnit(vT,1747989045,-19200.0,28352.0,270.000)
call CreateUnit(vT,1747989043,3456.0,11584.0,270.000)
call CreateUnit(vT,1747989044,-24640.0,4352.0,270.000)
call CreateUnit(vT,1747989044,-23232.0,-5120.0,270.000)
call CreateUnit(vT,1747989042,-23424.0,768.0,270.000)
call CreateUnit(vT,1747989045,-15936.0,-2688.0,270.000)
call CreateUnit(vT,1747989045,-10752.0,-3456.0,270.000)
call CreateUnit(vT,1747989044,-7552.0,4416.0,270.000)
call CreateUnit(vT,1747989045,-20160.0,-1600.0,270.000)
call CreateUnit(vT,1747989045,-21824.0,2560.0,270.000)
call CreateUnit(vT,1747989045,11392.0,-7104.0,270.000)
call CreateUnit(vT,1747989042,4352.0,20224.0,270.000)
call CreateUnit(vT,1747989044,-15360.0,4992.0,270.000)
call CreateUnit(vT,1747989042,-896.0,3392.0,270.000)
call CreateUnit(vT,1747989045,-6528.0,-832.0,270.000)
call CreateUnit(vT,1747989043,-4928.0,-3264.0,270.000)
call CreateUnit(vT,1747989042,-6144.0,-8192.0,270.000)
call CreateUnit(vT,1747989043,23424.0,640.0,270.000)
call CreateUnit(vT,1747989043,-6976.0,1344.0,270.000)
call CreateUnit(vT,1747989043,4352.0,128.0,270.000)
call CreateUnit(vT,1747989297,17472.0,19648.0,270.000)
call CreateUnit(vT,1747989044,-7872.0,22784.0,270.000)
call CreateUnit(vT,1747989297,20864.0,21504.0,270.000)
call CreateUnit(vT,1747989044,-9152.0,28480.0,270.000)
call CreateUnit(vT,1747989042,-27712.0,-9536.0,270.000)
call CreateUnit(vT,1747989042,4800.0,-12480.0,270.000)
call CreateUnit(vT,1747989045,7232.0,-11328.0,270.000)
call CreateUnit(vT,1747989045,1792.0,-8064.0,270.000)
call CreateUnit(vT,1747989297,-1600.0,5952.0,270.000)
call CreateUnit(vT,1747989043,-128.0,-1792.0,270.000)
call CreateUnit(vT,1747989042,-3392.0,8640.0,270.000)
call CreateUnit(vT,1747989044,-1856.0,16576.0,270.000)
call CreateUnit(vT,1747989043,-13888.0,14784.0,270.000)
call CreateUnit(vT,1747989297,-29568.0,-9792.0,270.000)
call CreateUnit(vT,1747989043,-9088.0,26240.0,270.000)
call CreateUnit(vT,1747989045,-5440.0,23808.0,270.000)
call CreateUnit(vT,1747989045,2176.0,30080.0,270.000)
call CreateUnit(vT,1747989043,1984.0,6464.0,270.000)
call CreateUnit(vT,1747989297,-26304.0,-1408.0,270.000)
call CreateUnit(vT,1747989043,448.0,13056.0,270.000)
call CreateUnit(vT,1747989045,3072.0,26752.0,270.000)
call CreateUnit(vT,1747989043,6656.0,18880.0,270.000)
call CreateUnit(vT,1747989043,3264.0,-3712.0,270.000)
call CreateUnit(vT,1747989297,15872.0,5760.0,270.000)
call CreateUnit(vT,1747989043,6528.0,22080.0,270.000)
call CreateUnit(vT,1747989044,8896.0,27008.0,270.000)
call CreateUnit(vT,1747989297,18496.0,-17280.0,270.000)
call CreateUnit(vT,1747989297,11392.0,7872.0,270.000)
call CreateUnit(vT,1747989297,12672.0,11328.0,270.000)
call CreateUnit(vT,1747989297,6016.0,12416.0,270.000)
call CreateUnit(vT,1747989297,7104.0,7808.0,270.000)
call CreateUnit(vT,1747989297,20864.0,2688.0,270.000)
call CreateUnit(vT,1747989297,24000.0,2560.0,270.000)
call CreateUnit(vT,1747989297,19648.0,11328.0,270.000)
call CreateUnit(vT,1747989297,11584.0,16960.0,270.000)
call CreateUnit(vT,1747989297,18496.0,-13248.0,270.000)
call CreateUnit(vT,1747989297,17216.0,-11456.0,270.000)
call CreateUnit(vT,1747989297,25088.0,-8320.0,270.000)
call CreateUnit(vT,1747989297,15680.0,-17536.0,270.000)
call CreateUnit(vT,1747989297,16640.0,-14208.0,270.000)
call CreateUnit(vT,1747989297,17280.0,-19584.0,270.000)
call CreateUnit(vT,1747989297,22912.0,-10240.0,270.000)
call CreateUnit(vT,1747989297,20864.0,-23040.0,270.000)
call CreateUnit(vT,1747989044,13120.0,-21696.0,270.000)
call CreateUnit(vT,1747989297,20096.0,-5760.0,270.000)
call CreateUnit(vT,1747989297,18816.0,-3776.0,270.000)
call CreateUnit(vT,1747989042,14464.0,-26432.0,270.000)
call CreateUnit(vT,1747989044,23808.0,-27776.0,270.000)
call CreateUnit(vT,1747989042,11776.0,-18688.0,270.000)
call CreateUnit(vT,1747989043,256.0,-18048.0,270.000)
call CreateUnit(vT,1747989045,-16192.0,-8192.0,270.000)
call CreateUnit(vT,1747989045,-11520.0,-10944.0,270.000)
call CreateUnit(vT,1747989045,16512.0,-19968.0,270.000)
call CreateUnit(vT,1747989045,20416.0,-22272.0,270.000)
call CreateUnit(vT,1747989044,28800.0,-11904.0,270.000)
call CreateUnit(vT,1747989297,15040.0,23104.0,270.000)
call CreateUnit(vT,1747989044,8128.0,12928.0,270.000)
call CreateUnit(vT,1747989044,16896.0,-15744.0,270.000)
call CreateUnit(vT,1747989042,17984.0,-640.0,270.000)
call CreateUnit(vT,1747989045,20608.0,3136.0,270.000)
call CreateUnit(vT,1747989045,7232.0,-5120.0,270.000)
call CreateUnit(vT,1747989045,25984.0,-8128.0,270.000)
call CreateUnit(vT,1747989045,20544.0,-5440.0,270.000)
call CreateUnit(vT,1747989045,11968.0,17856.0,270.000)
call CreateUnit(vT,1747989045,10048.0,20032.0,270.000)
call CreateUnit(vT,1747989043,15296.0,-7232.0,270.000)
call CreateUnit(vT,1747989043,13056.0,11776.0,270.000)
call CreateUnit(vT,1747989043,15744.0,23488.0,270.000)
call CreateUnit(vT,1747989043,17984.0,9280.0,270.000)
set vT=null
endfunction
function A0w takes nothing returns boolean
return true
endfunction
function A1 takes nothing returns nothing
call GroupAddUnit(nc,GetEnumUnit())
endfunction
function AD takes nothing returns nothing
call UnitRemoveAbility(GetTriggerUnit(),1093677402)
endfunction
function AK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function AQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988812,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988559,0)
endfunction
function AT takes nothing returns nothing
call SetFloatGameState(GAME_STATE_TIME_OF_DAY,bj_MELEE_STARTING_TOD)
call MeleeStartingHeroLimit()
endfunction
function o0w takes integer c0w returns string
if c0w==0 then
return "|cffADADADtrace|r"
elseif c0w==1 then
return "|cff2685DCdebug|r"
elseif c0w==2 then
return "|cffFFCC00info|r"
elseif c0w==3 then
return "|cffF47E3Ewarning|r"
elseif c0w==4 then
return "|cffFB2700error|r"
endif
return "?"
endfunction
function x1 takes string f1,string R1 returns nothing
local integer T1
local string Y1
local integer G1
local integer g1
local string h1
local integer F1
local integer k1
local string j1
set Xb[Lb]=R1
set Lb=Lb+1
set T1=StringHash(f1)
if HaveSavedInteger(Sc,-1,T1) then
if LoadInteger(Sc,-1,T1)+60<ac then
set R1=f1
set Y1=""
set G1=Lb
set g1=0
loop
set G1=G1-1
set g1=g1+1
exitwhen g1>20 or G1<0
set Y1=Y1+"\n   "+Xb[G1]
endloop
call DisplayTimedTextToPlayer(ro,0.,0.,45.,o0w(4)+" - "+R1+Y1)
call SaveInteger(Sc,-1,T1,R2I(ac))
call SaveBoolean(Sc,-1,T1,false)
elseif HaveSavedBoolean(Sc,-1,T1) then
if not LoadBoolean(Sc,-1,T1) then
call DisplayTimedTextToPlayer(ro,0.,0.,45.,o0w(4)+" - "+"|cffFF3A29Excessive repeating errors are being omitted")
call SaveBoolean(Sc,-1,T1,true)
endif
else
call DisplayTimedTextToPlayer(ro,0.,0.,45.,o0w(4)+" - "+"|cffFF3A29Excessive repeating errors are being omitted")
call SaveBoolean(Sc,-1,T1,true)
endif
else
call SaveInteger(Sc,-1,T1,R2I(ac))
set j1="Message: "+f1
set h1=""
set F1=Lb
set k1=0
loop
set F1=F1-1
set k1=k1+1
exitwhen k1>20 or F1<0
set h1=h1+"\n   "+Xb[F1]
endloop
call DisplayTimedTextToPlayer(ro,0.,0.,45.,o0w(4)+" - "+j1+h1)
endif
call I2S(1/0)
set Lb=Lb-1
endfunction
function fqw takes string pqw,string eqw,integer qqw,integer aqw,integer nqw,string dqw returns integer
set Xb[Lb]=dqw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_ReligionClass in Religion, line 15"
set Lb=Lb+1
if el==0 then
if ql<32768 then
set ql=ql+1
set qqw=ql
else
call x1("Out of memory: Could not create ReligionClass.","when calling error in Religion, line 10")
set qqw=0
endif
else
set el=el-1
set qqw=pl[el]
endif
set Lb=Lb-1-1
return qqw
endfunction
function Axw takes nothing returns boolean
set Lb=0
set Xb[Lb]="Religion, line 1"
set Lb=Lb+1
call fqw("Catholicism","Catholic",244,255,96,"when calling new_ReligionClass in Religion, line 29")
call fqw("Orthodoxy","Orthodox",234,0,255,"when calling new_ReligionClass in Religion, line 35")
call fqw("Islam","Muslim",0,151,0,"when calling new_ReligionClass in Religion, line 41")
call fqw("Orthodoxy","Orthodox",234,0,255,"when calling new_ReligionClass in Religion, line 47")
set Lb=Lb-1
return true
endfunction
function BA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990599,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990600,0)
endfunction
function VG takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function BG takes nothing returns nothing
if VG() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function BI takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,Lq)
endfunction
function BJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function BY takes nothing returns boolean
if GetSpellAbilityId()!=1093677620 then
return false
endif
return true
endfunction
function BZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989570,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989556,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989559,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989557,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989560,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989573,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989574,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651841,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651833,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651832,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989582,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990097,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989812,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990098,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990099,0)
endfunction
function Vg takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function Bg takes nothing returns nothing
if Vg() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function Vh takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function Bh takes nothing returns nothing
if Vh() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function Bj takes nothing returns nothing
local player Ij=GetOwningPlayer(GetKillingUnit())
local playerstate Pj=PLAYER_STATE_RESOURCE_GOLD
local playerstate Aj
local playerstate Dj
local player Hj
local force Jj
local location Kj
local real Lj
local real Xj
local player Cj
local force Vj
if Pj==PLAYER_STATE_RESOURCE_GOLD then
set Aj=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Ij,Aj,GetPlayerState(Ij,Aj)+125)
elseif Pj==PLAYER_STATE_RESOURCE_LUMBER then
set Dj=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Ij,Dj,GetPlayerState(Ij,Dj)+125)
endif
call SetPlayerState(Ij,Pj,GetPlayerState(Ij,Pj)+125)
set Hj=GetOwningPlayer(GetKillingUnit())
set Jj=CreateForce()
call ForceAddPlayer(Jj,Hj)
if IsPlayerInForce(GetLocalPlayer(),Jj) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_091")
endif
set y=GetUnitLoc(GetDyingUnit())
set Cj=GetOwningPlayer(GetDyingUnit())
set Vj=CreateForce()
call ForceAddPlayer(Vj,Cj)
set Kj=y
set Lj=GetLocationX(Kj)
set Xj=GetLocationY(Kj)
if IsPlayerInForce(GetLocalPlayer(),Vj) then
call PingMinimap(Lj,Xj,2.00)
endif
call RemoveLocation(y)
set Ij=null
set Pj=null
set Aj=null
set Dj=null
set Hj=null
set Jj=null
set Kj=null
set Cj=null
set Vj=null
endfunction
function Bk takes nothing returns nothing
local player Ik=GetOwningPlayer(GetSpellTargetUnit())
local playerstate Pk=PLAYER_STATE_RESOURCE_GOLD
local playerstate Ak
local playerstate Dk
local player Hk
local force Jk
local location Kk
local real Lk
local real Xk
local player Ck
local force Vk
if Pk==PLAYER_STATE_RESOURCE_GOLD then
set Ak=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Ik,Ak,GetPlayerState(Ik,Ak)+500)
elseif Pk==PLAYER_STATE_RESOURCE_LUMBER then
set Dk=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Ik,Dk,GetPlayerState(Ik,Dk)+500)
endif
call SetPlayerState(Ik,Pk,GetPlayerState(Ik,Pk)+500)
call RemoveUnit(GetSpellAbilityUnit())
set Hk=GetOwningPlayer(GetSpellTargetUnit())
set Jk=CreateForce()
call ForceAddPlayer(Jk,Hk)
if IsPlayerInForce(GetLocalPlayer(),Jk) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1231")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set Ck=GetOwningPlayer(GetSpellTargetUnit())
set Vk=CreateForce()
call ForceAddPlayer(Vk,Ck)
set Kk=y
set Lk=GetLocationX(Kk)
set Xk=GetLocationY(Kk)
if IsPlayerInForce(GetLocalPlayer(),Vk) then
call PingMinimap(Lk,Xk,2.00)
endif
call RemoveLocation(y)
set Ik=null
set Pk=null
set Ak=null
set Dk=null
set Hk=null
set Jk=null
set Kk=null
set Ck=null
set Vk=null
endfunction
function Bm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989066,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988551,0)
endfunction
function E3 takes string F3 returns boolean
local integer k3
local integer j3
local boolean x3
local integer v3
local boolean m3
local boolean Q3
local boolean W3
set Xb[Lb]=F3
set Lb=Lb+1
if GetOwningPlayer(GetSpellAbilityUnit())==GetOwningPlayer(GetSpellTargetUnit()) then
set Q3=true
else
set j3=wo[GetPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]
set Xb[Lb]="when calling isObserver in Diplomacy, line 107"
set Lb=Lb+1
if yl[j3]==0 then
if j3==0 then
call x1("Nullpointer exception when calling PlayerStats.isObserver","when calling error in PlayerStats, line 29")
else
call x1("Called PlayerStats.isObserver on invalid object.","when calling error in PlayerStats, line 29")
endif
endif
set x3=Hb[j3]
set Lb=Lb-1
set Q3=x3
endif
if Q3 then
set W3=true
else
set v3=wo[GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))]
set Xb[Lb]="when calling isObserver in Diplomacy, line 108"
set Lb=Lb+1
if yl[v3]==0 then
if v3==0 then
call x1("Nullpointer exception when calling PlayerStats.isObserver","when calling error in PlayerStats, line 29")
else
call x1("Called PlayerStats.isObserver on invalid object.","when calling error in PlayerStats, line 29")
endif
endif
set m3=Hb[v3]
set Lb=Lb-1
set W3=m3
endif
if W3 then
set Lb=Lb-1
return false
endif
set k3=GetSpellAbilityId()
set Lb=Lb-1
return k3==1093677396 or k3==1093677397 or k3==1093677398 or k3==1093677400 or k3==1093677399
endfunction
function Bxw takes nothing returns boolean
set Lb=0
return E3("Diplomacy, line 118")
endfunction
function CG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990091 then
return false
endif
return true
endfunction
function CK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function CQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989072,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989073,0)
endfunction
function XW takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function CW takes nothing returns boolean
if not XW() then
return false
endif
return true
endfunction
function Cg takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989077 then
return false
endif
return true
endfunction
function Ch takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990071 then
return false
endif
return true
endfunction
function Yqw takes string Rqw returns integer
local integer Tqw
set Xb[Lb]=Rqw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_Table in Table, line 5"
set Lb=Lb+1
if IO==0 then
if PO<32768 then
set PO=PO+1
set Tqw=PO
set AO[Tqw]=728
else
call x1("Out of memory: Could not create Table.","when calling error in Table, line 6")
set Tqw=0
endif
else
set IO=IO-1
set Tqw=UO[IO]
set AO[Tqw]=728
endif
set Lb=Lb-1-1
return Tqw
endfunction
function yww takes string lww returns boolean
local integer bww
set Xb[Lb]=lww
set Lb=Lb+1
set Po=Yqw("when calling new_Table in TypeCasting, line 6")
set Xb[Lb]="when calling initTypecastData in TypeCasting, line 14"
set Lb=Lb+1
set bww=Po
set Xb[Lb]="when calling saveString in TypeCasting, line 11"
set Lb=Lb+1
if AO[bww]==0 then
if bww==0 then
call x1("Nullpointer exception when calling Table.saveString","when calling error in Table, line 60")
else
call x1("Called Table.saveString on invalid object.","when calling error in Table, line 60")
endif
endif
call SaveStr(Eo,bww,0,"")
set Lb=Lb-1-1-1
return true
endfunction
function Cjw takes nothing returns boolean
set Lb=0
return yww("TypeCasting, line 1")
endfunction
function l0w takes integer O0w returns real
if O0w==1747988785 then
return 10.0
elseif O0w==1747989075 then
return 10.0
elseif O0w==1747990102 then
return 10.0
elseif O0w==1747989839 then
return 10.0
elseif O0w==1747988568 then
return 5.0
elseif O0w==1747990341 then
return 5.0
elseif O0w==1747988789 then
return 15.0
elseif O0w==1747990103 then
return 15.0
elseif O0w==1747990064 then
return 15.0
elseif O0w==1747989846 then
return 15.0
else
return 0.0
endif
endfunction
function WSw takes integer vSw,unit mSw returns nothing
local boolean QSw
if IsUnitType(mSw,UNIT_TYPE_STRUCTURE) then
set QSw=GetOwningPlayer(mSw)==uo[Wl[Cl[vSw]]]
else
set QSw=false
endif
if QSw then
set Al[Cl[vSw]]=Al[Cl[vSw]]+l0w(GetUnitTypeId(mSw))
endif
endfunction
function ubw takes integer Vlw,integer Blw,integer Nlw,string Mlw returns integer
local integer wbw
set Xb[Lb]=Mlw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_LLEntry in LinkedList, line 401"
set Lb=Lb+1
if VO==0 then
if BO<32768 then
set BO=BO+1
set wbw=BO
set NO[wbw]=699
else
call x1("Out of memory: Could not create LLEntry.","when calling error in LinkedList, line 396")
set wbw=0
endif
else
set VO=VO-1
set wbw=CO[VO]
set NO[wbw]=699
endif
set Lb=Lb-1
set fb[wbw]=Vlw
set Rb[wbw]=Blw
set Tb[wbw]=Nlw
set Lb=Lb-1
return wbw
endfunction
function jfw takes integer gfw,integer hfw,string Ffw returns nothing
local integer kfw
set Xb[Lb]=Ffw
set Lb=Lb+1
if Sl[gfw]==0 then
if gfw==0 then
call x1("Nullpointer exception when calling LinkedList.add","when calling error in LinkedList, line 37")
else
call x1("Called LinkedList.add on invalid object.","when calling error in LinkedList, line 37")
endif
endif
set Xb[Lb]="when calling add in LinkedList, line 37"
set Lb=Lb+1
set kfw=ubw(hfw,Rb[Fb[gfw]],Fb[gfw],"when calling new_LLEntry in LinkedList, line 39")
set Tb[Rb[Fb[gfw]]]=kfw
set Rb[Fb[gfw]]=kfw
set kb[gfw]=kb[gfw]+1
set Lb=Lb-1-1
endfunction
function Cnw takes integer Jnw,integer Knw,string Lnw returns boolean
local integer Xnw
set Xb[Lb]=Lnw
set Lb=Lb+1
if ZO[Jnw]==0 then
if Jnw==0 then
call x1("Nullpointer exception when calling HashList.has","when calling error in HashList, line 87")
else
call x1("Called HashList.has on invalid object.","when calling error in HashList, line 87")
endif
endif
set Xb[Lb]="when calling has in HashList, line 87"
set Lb=Lb+1
set Xb[Lb]="when calling count in HashList, line 88"
set Lb=Lb+1
if ZO[Jnw]==0 then
if Jnw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Xnw=LoadInteger(fc,Jnw,Knw)
set Lb=Lb-1
set Lb=Lb-1-1
return Xnw>0
endfunction
function ryw takes integer Nbw,unit Mbw,string wyw returns nothing
local boolean uyw
set Xb[Lb]=wyw
set Lb=Lb+1
if GetOwningPlayer(Mbw)==jb[Nbw]then
set uyw=not Cnw(Co,GetUnitTypeId(Mbw),"when calling has in MassControl, line 28")
else
set uyw=false
endif
if uyw and Mbw!=xb[Nbw] and(not IsUnitType(Mbw,UNIT_TYPE_STRUCTURE)) then
call jfw(vb[Nbw],GetHandleId(Mbw),"when calling add in MassControl, line 29")
endif
set Lb=Lb-1
endfunction
function xSw takes integer hSw,unit FSw,string kSw returns nothing
local boolean jSw
set Xb[Lb]=kSw
set Lb=Lb+1
if not Cnw(Co,GetUnitTypeId(FSw),"when calling has in City, line 314") then
set jSw=GetOwningPlayer(FSw)==uo[Wl[Xl[hSw]]]
else
set jSw=false
endif
if jSw then
set Al[Xl[hSw]]=Al[Xl[hSw]]+0.5
endif
set Lb=Lb-1
endfunction
function tnw takes integer unw,unit rnw,string snw returns nothing
set Xb[Lb]=snw
set Lb=Lb+1
if nO[unw]==0 then
if unw==0 then
call x1("Nullpointer exception when calling ForGroupCallback.callback","when calling error in ClosureForGroups, line 4")
else
call x1("Called ForGroupCallback.callback on invalid object.","when calling error in ClosureForGroups, line 4")
endif
endif
if nO[unw]<=687 then
if nO[unw]<=686 then
if nO[unw]<=685 then
call xSw(unw,rnw,"when calling City_City_callback_line313 in ClosureForGroups, line 4")
else
call WSw(unw,rnw)
endif
else
set Xb[Lb]="when calling LinkedList_callback_line514 in ClosureForGroups, line 4"
set Lb=Lb+1
call jfw(db[unw],GetHandleId(rnw),"when calling add in LinkedList, line 515")
set Lb=Lb-1
endif
elseif nO[unw]<=688 then
call ryw(unw,rnw,"when calling MassControl_callback_line27 in ClosureForGroups, line 4")
else
call RemoveUnit(rnw)
endif
set Lb=Lb-1
endfunction
function Cxw takes nothing returns nothing
local unit Xxw
set Lb=0
set Xb[Lb]="ClosureForGroups, line 14"
set Lb=Lb+1
set Xxw=GetFilterUnit()
set Xb[Lb]="when calling filterCallback in ClosureForGroups, line 14"
set Lb=Lb+1
if JS<HS then
call tnw(AS[DS-1],Xxw,"when calling callback in ClosureForGroups, line 18")
endif
set JS=JS+1
set Lb=Lb-1-1
set Xxw=null
endfunction
function D1 takes nothing returns boolean
set dc=InitHashtable()
set fc=InitHashtable()
return true
endfunction
function D2 takes nothing returns boolean
return true
endfunction
function AA takes nothing returns boolean
if GetResearched()!=1378890054 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890054,true)!=2 then
return false
endif
return true
endfunction
function DA takes nothing returns boolean
if not AA() then
return false
endif
return true
endfunction
function AJ takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747990351 then
return false
endif
return true
endfunction
function DJ takes nothing returns boolean
if not AJ() then
return false
endif
return true
endfunction
function DT takes nothing returns nothing
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_097","TRIGSTR_098","ReplaceableTextures\\CommandButtons\\BTNSteelMelee.blp")
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_103","TRIGSTR_104","ReplaceableTextures\\WorldEditUI\\Doodad-Cinematic.blp")
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_2667","TRIGSTR_2668","ReplaceableTextures\\WorldEditUI\\Editor-MultipleUnits.blp")
endfunction
function AY takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1966092336 then
return false
endif
if GetSpellAbilityId()!=1093677906 then
return false
endif
if GetOwningPlayer(GetSpellTargetUnit())==Player(PLAYER_NEUTRAL_AGGRESSIVE) then
return false
endif
if IsUnitType(GetSpellTargetUnit(),UNIT_TYPE_STRUCTURE)!=true then
return false
endif
return true
endfunction
function DY takes nothing returns boolean
if not AY() then
return false
endif
return true
endfunction
function Am takes nothing returns boolean
if GetResearched()!=1378889798 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889798,true)!=1 then
return false
endif
return true
endfunction
function Dm takes nothing returns boolean
if not Am() then
return false
endif
return true
endfunction
function Px takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747990581 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990580 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989813 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747988569 then
return true
endif
return false
endfunction
function Ax takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989049 then
return false
endif
if not Px() then
return false
endif
return true
endfunction
function Dx takes nothing returns boolean
if not Ax() then
return false
endif
return true
endfunction
function Z0w takes playerunitevent F0w,code k0w,code j0w,code x0w returns nothing
local integer v0w=GetHandleId(F0w)
local integer m0w
local filterfunc Q0w
local trigger W0w
local player E0w
if po[v0w]==null then
set po[v0w]=CreateTrigger()
set m0w=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen m0w<0
set W0w=po[v0w]
set E0w=uo[m0w]
if k0w!=null then
set Q0w=Filter(k0w)
else
set Q0w=null
endif
call TriggerRegisterPlayerUnitEvent(W0w,E0w,F0w,Q0w)
set m0w=m0w-1
endloop
endif
if j0w!=null then
call TriggerAddCondition(po[v0w],Filter(j0w))
endif
if x0w!=null then
call TriggerAddAction(po[v0w],x0w)
endif
set Q0w=null
set W0w=null
set E0w=null
endfunction
function QV takes eventid RV,string TV returns integer
local integer YV
local integer GV
local integer gV
local trigger hV
local integer FV
local integer kV
local integer jV
local integer xV
local boolean vV
local boolean mV
set Xb[Lb]=TV
set Lb=Lb+1
set YV=GetHandleId(RV)
set QS=QS+1
set mS[YV]=QS
set FV=GetHandleId(RV)
if (FV>=18 and FV<=51)or(FV>=269 and FV<=277) then
call Z0w(ConvertPlayerUnitEvent(YV),null,Ef,null)
else
if RV!=EVENT_UNIT_DAMAGED and RV!=EVENT_PLAYER_LEAVE and RV!=kS then
set kV=GetHandleId(RV)
set vV=kV<261 or kV>268 and kV!=17
else
set vV=false
endif
if vV then
set jV=GetHandleId(RV)
set mV=jV<305 or jV>307
else
set mV=false
endif
if mV then
call x1("registering handleid: "+I2S(YV)+" non-playerunitevent. Except EVENT_UNIT_DAMAGED and EVENT_PLAYER_LEAVE these are not supported right now.","when calling error in ClosureEvents, line 243")
endif
endif
set xV=GetHandleId(RV)
if xV>=305 and xV<=307 and(not IS) then
set IS=true
set GV=0
set gV=bj_MAX_PLAYERS-1
loop
exitwhen GV>gV
set hV=vS
call TriggerRegisterPlayerEvent(hV,uo[GV],EVENT_PLAYER_MOUSE_UP)
call TriggerRegisterPlayerEvent(hV,uo[GV],EVENT_PLAYER_MOUSE_DOWN)
call TriggerRegisterPlayerEvent(hV,uo[GV],EVENT_PLAYER_MOUSE_MOVE)
set GV=GV+1
endloop
endif
set Lb=Lb-1
set hV=null
return QS
endfunction
function Hww takes string Iww returns boolean
local playerunitevent Pww
local integer Aww
local integer Dww
set Xb[Lb]=Iww
set Lb=Lb+1
set Pww=EVENT_PLAYER_UNIT_SPELL_CAST
set Xb[Lb]="when calling alloc_Taxation_EventListener_line6 in Taxation, line 6"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set Aww=iO
set SO[Aww]=679
else
call x1("Out of memory: Could not create Taxation_EventListener_line6.","when calling error in Taxation, line 6")
set Aww=0
endif
else
set tO=tO-1
set Aww=sO[tO]
set SO[Aww]=679
endif
set Lb=Lb-1
set ub[Aww]=0
set rb[Aww]=0
set sb[Aww]=0
set Xb[Lb]="when calling add in Taxation, line 6"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set Dww=mS[GetHandleId(Pww)]
if Dww==0 then
set Dww=QV(Pww,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[Aww]=Dww
if ZS[ub[Aww]]!=0 then
set sb[ZS[ub[Aww]]]=Aww
set rb[Aww]=ZS[ub[Aww]]
endif
set ZS[ub[Aww]]=Aww
set Lb=Lb-1-1
set Pww=null
return true
endfunction
function Dxw takes nothing returns boolean
set Lb=0
return Hww("Taxation, line 1")
endfunction
function E8 takes nothing returns boolean
return true
endfunction
function EA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990604,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990602,0)
endfunction
function ED takes nothing returns nothing
local player mD=GetOwningPlayer(GetTriggerUnit())
local boolexpr QD=Condition(Wa)
local group WD=CreateGroup()
local code xD
local boolean vD
call GroupEnumUnitsOfPlayer(WD,mD,QD)
call DestroyBoolExpr(QD)
set xD=Ea
set vD=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(WD,xD)
if vD then
call DestroyGroup(WD)
endif
set mD=null
set QD=null
set WD=null
endfunction
function WI takes nothing returns boolean
if GetResearched()!=1378890032 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890032,true)!=1 then
return false
endif
return true
endfunction
function EI takes nothing returns boolean
if not WI() then
return false
endif
return true
endfunction
function EJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function EY takes nothing returns nothing
local player xY=GetOwningPlayer(GetAttacker())
local player vY=GetOwningPlayer(GetAttacker())
local player mY
local player QY
local unit WY
set r[GetPlayerId(xY)+1]=r[GetPlayerId(vY)+1]+1
set mY=GetOwningPlayer(GetTriggerUnit())
set QY=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(mY)+1]=r[GetPlayerId(QY)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set WY=GetTriggerUnit()
call SetUnitState(WY,UNIT_STATE_LIFE,GetUnitState(WY,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set xY=null
set vY=null
set mY=null
set QY=null
set WY=null
endfunction
function Em takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988558,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989057,0)
endfunction
function Eww takes nothing returns boolean
set no[0]="Terrible! Terrible news, my lord!"
set no[1]="The messenger came to us with horrific news! May we execute him?"
set no[2]="A mere nightmare, Your Mightiness!"
set do[0]="Holy Mother of God, we have horrific news!"
set do[1]="Lord Preserve us, Great Prince!"
set do[2]="Great Prince, we have horrific news!"
set fo[0]="Allah be merciful! I bring terrible news"
set fo[1]="Oh, Great Sultan! We have terrible news"
set fo[2]="Oh, Great one! I bring ill news"
set Ro[0]="Saints save us, we have some most horrific news!"
set Ro[1]="My Basileus! We have horrific news!"
set Ro[2]="My Basileus, by the grace of our lord. We have horrific news!"
set To[0]="My King, we have received news concerning our realm"
set To[1]="The messenger arrived with news. No matter, could I execute him?"
set To[2]="My liege I bring news about the realm"
set Yo[0]="Great Prince, a messenger came with news"
set Yo[1]="May the God bless you, Great Prince, we have some news"
set Yo[2]="There is something you should know, Great Prince"
set Go[0]="My Sultan! We have news"
set Go[1]="Praise be to Allah, Sultan! We bring news"
set Go[2]="Great Sultan! We have some news"
set go[0]="My Basileus, we have some news"
set go[1]="My Basileus, we have some news"
set go[2]="My Basileus, we have some news"
set ho[0]="Milord! Good news!"
set ho[1]="Praise the Holy Lord! We have good news"
set ho[2]="My King, we bring great news for you!"
set Fo[0]="By the grace of our Lord, we bring good news!"
set Fo[1]="We received great news my Lord! Still the Messenger deserves to be pusnished"
set Fo[2]="My Lord, we have received delightful news!"
set ko[0]="Praise be to Allah, Sultan! We have great news"
set ko[1]="Good tidings Sultan! I bring good news"
set ko[2]="Allah is glorious, Sultan! We have great news"
set jo[0]="Good news, my Basileus!"
set jo[1]="Praise the Holy Lord, we bring great news, my Basileus!"
set jo[2]="We received good news my Basileus! We shouldnt blind this messenger"
set xo[0]="Your Majesty, important news!"
set xo[1]="May the God bless you, my lord. There is something you must know!"
set xo[2]="There is something that needs your attention, my lord!"
set vo[0]="By the Saints! Great Prince, you must hear to this"
set vo[1]="You should hear this, Great Prince!"
set vo[2]="You need to see this, Great Prince!"
set mo[0]="Great one, urgent news must be brought to your attention!"
set mo[1]="My Sultan, there is something you need to know!"
set mo[2]="My Great Sultan, there is something you must know!"
set Qo[0]="My Basileus, there is something you need to know!"
set Qo[1]="My Basileus, we can not delay this news!"
set Qo[2]="My Basileus, you should be aware of this!"
set Wo[0]="|cffffd900Med."
set Wo[1]="|cff00ff00Low"
set Wo[2]="|cffff0000High"
set Wo[3]="|cff940000Harsh"
return true
endfunction
function i9 takes string u9 returns boolean
local playerunitevent r9
local integer s9
local integer t9
set Xb[Lb]=u9
set Lb=Lb+1
set r9=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Xb[Lb]="when calling alloc_NoShipsNearRivers_EventListener_line7 in NoShipsNearRivers, line 7"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set s9=iO
set SO[s9]=672
else
call x1("Out of memory: Could not create NoShipsNearRivers_EventListener_line7.","when calling error in NoShipsNearRivers, line 7")
set s9=0
endif
else
set tO=tO-1
set s9=sO[tO]
set SO[s9]=672
endif
set Lb=Lb-1
set ub[s9]=0
set rb[s9]=0
set sb[s9]=0
set Xb[Lb]="when calling add in NoShipsNearRivers, line 7"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set t9=mS[GetHandleId(r9)]
if t9==0 then
set t9=QV(r9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[s9]=t9
if ZS[ub[s9]]!=0 then
set sb[ZS[ub[s9]]]=s9
set rb[s9]=ZS[ub[s9]]
endif
set ZS[ub[s9]]=s9
set Lb=Lb-1-1
set r9=null
return true
endfunction
function Exw takes nothing returns boolean
set Lb=0
return i9("NoShipsNearRivers, line 1")
endfunction
function h9 takes unit g9 returns nothing
call UnitAddAbility(g9,1095577649)
call UnitMakeAbilityPermanent(g9,true,1095577649)
set Nc[Mc]=g9
set Mc=Mc+1
call TriggerEvaluate(Vc)
set Mc=Mc-1
endfunction
function F9 takes nothing returns nothing
call h9(GetFilterUnit())
endfunction
function hA takes nothing returns boolean
if GetResearched()!=1378890040 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890040,true)!=2 then
return false
endif
return true
endfunction
function FA takes nothing returns boolean
if not hA() then
return false
endif
return true
endfunction
function FD takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
return true
endfunction
function FF takes nothing returns nothing
local group GF
local code gF
local boolean hF
set b=GetUnitsOfTypeIdAll(1747989301)
set GF=b
set gF=ep
set hF=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(GF,gF)
if hF then
call DestroyGroup(GF)
endif
call DestroyGroup(b)
set GF=null
endfunction
function hJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990354 then
return false
endif
return true
endfunction
function FJ takes nothing returns boolean
if not hJ() then
return false
endif
return true
endfunction
function hm takes nothing returns boolean
if GetResearched()!=1378889796 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889796,true)!=1 then
return false
endif
return true
endfunction
function Fm takes nothing returns boolean
if not hm() then
return false
endif
return true
endfunction
function Fww takes nothing returns boolean
return true
endfunction
function Bww takes timer Kww,integer Lww,string Xww returns nothing
local integer Cww
local integer Vww
set Xb[Lb]=Xww
set Lb=Lb+1
set Cww=Io
set Vww=GetHandleId(Kww)
set Xb[Lb]="when calling saveInt in TimerUtils, line 17"
set Lb=Lb+1
if AO[Cww]==0 then
if Cww==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,Cww,Vww,Lww)
set Lb=Lb-1-1
endfunction
function Sww takes string tww returns timer
local timer iww
set Xb[Lb]=tww
set Lb=Lb+1
if Uo>0 then
set Uo=Uo-1
call Bww(Zo[Uo],0,"when calling setData in TimerUtils, line 29")
set Lb=Lb-1
set iww=null
return Zo[Uo]
else
set iww=CreateTimer()
call Bww(iww,0,"when calling setData in TimerUtils, line 32")
set Lb=Lb-1
set oR=iww
set iww=null
return oR
endif
endfunction
function enw takes integer lnw,timer bnw,real ynw,string pnw returns nothing
set Xb[Lb]=pnw
set Lb=Lb+1
if hO[lnw]==0 then
if lnw==0 then
call x1("Nullpointer exception when calling CallbackPeriodic.start","when calling error in ClosureTimers, line 132")
else
call x1("Called CallbackPeriodic.start on invalid object.","when calling error in ClosureTimers, line 132")
endif
endif
set Xb[Lb]="when calling start in ClosureTimers, line 132"
set Lb=Lb+1
call Bww(bnw,lnw,"when calling setData in ClosureTimers, line 134")
call TimerStart(bnw,ynw,true,tR)
set Lb=Lb-1-1
endfunction
function OM takes string SM returns boolean
local integer cM
local timer oM
set Xb[Lb]=SM
set Lb=Lb+1
set Xb[Lb]="when calling alloc_Credits_CallbackPeriodic_line5 in Credits, line 5"
set Lb=Lb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set cM=gO
set hO[cM]=633
else
call x1("Out of memory: Could not create Credits_CallbackPeriodic_line5.","when calling error in Credits, line 5")
set cM=0
endif
else
set GO=GO-1
set cM=YO[GO]
set hO[cM]=633
endif
set Lb=Lb-1
set Xb[Lb]="when calling doPeriodically in Credits, line 5"
set Lb=Lb+1
set oM=Sww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call enw(cM,oM,600,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set oM=null
return true
endfunction
function Fxw takes nothing returns boolean
set Lb=0
return OM("Credits, line 1")
endfunction
function GB takes nothing returns boolean
set LS=200
return true
endfunction
function GD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990584,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990594,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990583,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990607,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990598,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990606,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990599,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990601,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651855,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651852,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651850,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990595,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990596,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990604,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990603,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990322,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990323,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990321,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990324,0)
endfunction
function YE takes nothing returns boolean
if GetResearched()!=1378889807 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889807,true)!=1 then
return false
endif
return true
endfunction
function GE takes nothing returns boolean
if not YE() then
return false
endif
return true
endfunction
function GL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function GU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651848,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651846,0)
endfunction
function GW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651828,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651827,0)
endfunction
function H1 takes nothing returns boolean
set Rc=InitHashtable()
return true
endfunction
function H2 takes nothing returns boolean
return true
endfunction
function HA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990603,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990604,0)
endfunction
function HG takes nothing returns nothing
local location QG
local location WG
local real EG
local real ZG
local rect UG
local group IG
local group PG
local code AG
local boolean DG
set u=GetUnitLoc(GetSpellAbilityUnit())
set QG=u
set c=Location(GetLocationX(QG)+200.00,GetLocationY(QG)+0.00)
set WG=u
set EG=GetLocationX(WG)
set ZG=GetLocationY(WG)
set O=Rect(EG-150,ZG-140,EG+150,ZG+140)
set UG=O
set IG=CreateGroup()
call GroupEnumUnitsInRect(IG,UG,null)
call DestroyBoolExpr(null)
set l=IG
set PG=l
set AG=Ay
set DG=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(PG,AG)
if DG then
call DestroyGroup(PG)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747988825,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set QG=null
set WG=null
set UG=null
set IG=null
set PG=null
endfunction
function DI takes nothing returns boolean
if GetResearched()!=1378890038 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890038,true)!=1 then
return false
endif
return true
endfunction
function HI takes nothing returns boolean
if not DI() then
return false
endif
return true
endfunction
function HJ takes nothing returns nothing
call UnitAddAbility(GetConstructedStructure(),1093677896)
endfunction
function Hg takes nothing returns nothing
local location Qg
local location Wg
local real Eg
local real Zg
local rect Ug
local group Ig
local group Pg
local code Ag
local boolean Dg
set u=GetUnitLoc(GetSpellAbilityUnit())
set Qg=u
set S=Location(GetLocationX(Qg)+0.00,GetLocationY(Qg)+200.00)
set Wg=u
set Eg=GetLocationX(Wg)
set Zg=GetLocationY(Wg)
set o=Rect(Eg-140,Zg-150,Eg+140,Zg+150)
set Ug=o
set Ig=CreateGroup()
call GroupEnumUnitsInRect(Ig,Ug,null)
call DestroyBoolExpr(null)
set l=Ig
set Pg=l
set Ag=By
set Dg=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Pg,Ag)
if Dg then
call DestroyGroup(Pg)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990090,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set Qg=null
set Wg=null
set Ug=null
set Ig=null
set Pg=null
endfunction
function Hh takes nothing returns nothing
local location Qh
local location Wh
local real Eh
local real Zh
local rect Uh
local group Ih
local group Ph
local code Ah
local boolean Dh
set u=GetUnitLoc(GetSpellAbilityUnit())
set Qh=u
set S=Location(GetLocationX(Qh)+0.00,GetLocationY(Qh)+200.00)
set Wh=u
set Eh=GetLocationX(Wh)
set Zh=GetLocationY(Wh)
set o=Rect(Eh-140,Zh-150,Eh+140,Zh+150)
set Uh=o
set Ih=CreateGroup()
call GroupEnumUnitsInRect(Ih,Uh,null)
call DestroyBoolExpr(null)
set l=Ih
set Ph=l
set Ah=Sp
set Dh=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Ph,Ah)
if Dh then
call DestroyGroup(Ph)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989079,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set Qh=null
set Wh=null
set Uh=null
set Ih=null
set Ph=null
endfunction
function Hm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988551,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989081,0)
endfunction
function rrw takes string Kuw returns boolean
local trigger Luw
local playerunitevent Xuw
local playerunitevent Cuw
local integer Vuw
local integer Buw
local rect Nuw
local region Muw
local integer wrw
local integer urw
set Xb[Lb]=Kuw
set Lb=Lb+1
set Xuw=EVENT_PLAYER_UNIT_SPELL_FINISH
set Xb[Lb]="when calling alloc_Upkeep_EventListener_line6 in Upkeep, line 6"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set Vuw=iO
set SO[Vuw]=681
else
call x1("Out of memory: Could not create Upkeep_EventListener_line6.","when calling error in Upkeep, line 6")
set Vuw=0
endif
else
set tO=tO-1
set Vuw=sO[tO]
set SO[Vuw]=681
endif
set Lb=Lb-1
set ub[Vuw]=0
set rb[Vuw]=0
set sb[Vuw]=0
set Xb[Lb]="when calling add in Upkeep, line 6"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set Buw=mS[GetHandleId(Xuw)]
if Buw==0 then
set Buw=QV(Xuw,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[Vuw]=Buw
if ZS[ub[Vuw]]!=0 then
set sb[ZS[ub[Vuw]]]=Vuw
set rb[Vuw]=ZS[ub[Vuw]]
endif
set ZS[ub[Vuw]]=Vuw
set Lb=Lb-1
set Luw=CreateTrigger()
set Nuw=GetWorldBounds()
set Muw=CreateRegion()
call RegionAddRect(Muw,Nuw)
call TriggerRegisterEnterRegion(Luw,Muw,null)
call TriggerAddAction(Luw,Cf)
set Cuw=EVENT_PLAYER_UNIT_DEATH
set Xb[Lb]="when calling alloc_Upkeep_EventListener_line28 in Upkeep, line 28"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set wrw=iO
set SO[wrw]=680
else
call x1("Out of memory: Could not create Upkeep_EventListener_line28.","when calling error in Upkeep, line 28")
set wrw=0
endif
else
set tO=tO-1
set wrw=sO[tO]
set SO[wrw]=680
endif
set Lb=Lb-1
set ub[wrw]=0
set rb[wrw]=0
set sb[wrw]=0
set Xb[Lb]="when calling add in Upkeep, line 28"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set urw=mS[GetHandleId(Cuw)]
if urw==0 then
set urw=QV(Cuw,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[wrw]=urw
if ZS[ub[wrw]]!=0 then
set sb[ZS[ub[wrw]]]=wrw
set rb[wrw]=ZS[ub[wrw]]
endif
set ZS[ub[wrw]]=wrw
set Lb=Lb-1-1
set Luw=null
set Xuw=null
set Cuw=null
set Nuw=null
set Muw=null
return true
endfunction
function Hxw takes nothing returns boolean
set Lb=0
return rrw("Upkeep, line 1")
endfunction
function UE takes nothing returns boolean
if GetResearched()!=1378889806 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889806,true)!=1 then
return false
endif
return true
endfunction
function IE takes nothing returns boolean
if not UE() then
return false
endif
return true
endfunction
function IL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function IT takes nothing returns nothing
local group ET=GetUnitsOfTypeIdAll(1747988554)
local code ZT=Yy
local boolean UT=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(ET,ZT)
if UT then
call DestroyGroup(ET)
endif
set ET=null
endfunction
function IU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989816,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989815,0)
endfunction
function IW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989301,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988790,0)
endfunction
function D9 takes string v9 returns boolean
local playerunitevent m9
local playerunitevent Q9
local playerunitevent W9
local integer E9
local integer Z9
local integer U9
local integer I9
local integer P9
local integer A9
set Xb[Lb]=v9
set Lb=Lb+1
set m9=EVENT_PLAYER_UNIT_DEATH
set Xb[Lb]="when calling alloc_OreCapture_EventListener_line9 in OreCapture, line 9"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set E9=iO
set SO[E9]=677
else
call x1("Out of memory: Could not create OreCapture_EventListener_line9.","when calling error in OreCapture, line 9")
set E9=0
endif
else
set tO=tO-1
set E9=sO[tO]
set SO[E9]=677
endif
set Lb=Lb-1
set ub[E9]=0
set rb[E9]=0
set sb[E9]=0
set Xb[Lb]="when calling add in OreCapture, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set Z9=mS[GetHandleId(m9)]
if Z9==0 then
set Z9=QV(m9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[E9]=Z9
if ZS[ub[E9]]!=0 then
set sb[ZS[ub[E9]]]=E9
set rb[E9]=ZS[ub[E9]]
endif
set ZS[ub[E9]]=E9
set Lb=Lb-1
set Q9=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set Xb[Lb]="when calling alloc_OreCapture_EventListener_line14 in OreCapture, line 14"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set U9=iO
set SO[U9]=675
else
call x1("Out of memory: Could not create OreCapture_EventListener_line14.","when calling error in OreCapture, line 14")
set U9=0
endif
else
set tO=tO-1
set U9=sO[tO]
set SO[U9]=675
endif
set Lb=Lb-1
set ub[U9]=0
set rb[U9]=0
set sb[U9]=0
set Xb[Lb]="when calling add in OreCapture, line 14"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set I9=mS[GetHandleId(Q9)]
if I9==0 then
set I9=QV(Q9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[U9]=I9
if ZS[ub[U9]]!=0 then
set sb[ZS[ub[U9]]]=U9
set rb[U9]=ZS[ub[U9]]
endif
set ZS[ub[U9]]=U9
set Lb=Lb-1
set W9=EVENT_PLAYER_UNIT_ATTACKED
set Xb[Lb]="when calling alloc_OreCapture_EventListener_line21 in OreCapture, line 21"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set P9=iO
set SO[P9]=676
else
call x1("Out of memory: Could not create OreCapture_EventListener_line21.","when calling error in OreCapture, line 21")
set P9=0
endif
else
set tO=tO-1
set P9=sO[tO]
set SO[P9]=676
endif
set Lb=Lb-1
set ub[P9]=0
set rb[P9]=0
set sb[P9]=0
set Xb[Lb]="when calling add in OreCapture, line 21"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set A9=mS[GetHandleId(W9)]
if A9==0 then
set A9=QV(W9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[P9]=A9
if ZS[ub[P9]]!=0 then
set sb[ZS[ub[P9]]]=P9
set rb[P9]=ZS[ub[P9]]
endif
set ZS[ub[P9]]=P9
set Lb=Lb-1-1
set m9=null
set Q9=null
set W9=null
return true
endfunction
function Ixw takes nothing returns boolean
set Lb=0
return D9("OreCapture, line 1")
endfunction
function J1 takes nothing returns boolean
return true
endfunction
function JF takes nothing returns nothing
local player mF=GetOwningPlayer(GetSpellTargetUnit())
local playerstate QF=PLAYER_STATE_RESOURCE_LUMBER
local playerstate WF
local playerstate EF
local player ZF
local force UF
local location IF
local real PF
local real AF
local player DF
local force HF
if QF==PLAYER_STATE_RESOURCE_GOLD then
set WF=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(mF,WF,GetPlayerState(mF,WF)+250)
elseif QF==PLAYER_STATE_RESOURCE_LUMBER then
set EF=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(mF,EF,GetPlayerState(mF,EF)+250)
endif
call SetPlayerState(mF,QF,GetPlayerState(mF,QF)+250)
call RemoveUnit(GetSpellAbilityUnit())
set ZF=GetOwningPlayer(GetSpellTargetUnit())
set UF=CreateForce()
call ForceAddPlayer(UF,ZF)
if IsPlayerInForce(GetLocalPlayer(),UF) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1229")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set DF=GetOwningPlayer(GetSpellTargetUnit())
set HF=CreateForce()
call ForceAddPlayer(HF,DF)
set IF=y
set PF=GetLocationX(IF)
set AF=GetLocationY(IF)
if IsPlayerInForce(GetLocalPlayer(),HF) then
call PingMinimap(PF,AF,2.00)
endif
call RemoveLocation(y)
set mF=null
set QF=null
set WF=null
set EF=null
set ZF=null
set UF=null
set IF=null
set DF=null
set HF=null
endfunction
function JI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989830,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989829,0)
endfunction
function HP takes nothing returns boolean
if GetResearched()!=1378890051 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890051,true)!=1 then
return false
endif
return true
endfunction
function JP takes nothing returns boolean
if not HP() then
return false
endif
return true
endfunction
function JW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989057,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988558,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988551,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989066,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651824,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651826,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988818,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989080,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989072,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989082,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988559,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988812,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651828,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989065,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989067,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989301,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651843,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988561,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988788,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988565,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988566,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988567,0)
endfunction
function HZ takes nothing returns boolean
if GetResearched()!=1378890035 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890035,true)!=1 then
return false
endif
return true
endfunction
function JZ takes nothing returns boolean
if not HZ() then
return false
endif
return true
endfunction
function Hv takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function Jv takes nothing returns boolean
if not Hv() then
return false
endif
return true
endfunction
function Jww takes nothing returns boolean
return true
endfunction
function Aew takes integer Uew,integer Iew returns nothing
local integer Pew
if Ub[Uew]!=-1 then
call ForceRemovePlayer(bc[Ub[Uew]],Ib[Uew])
endif
set Ub[Uew]=Iew
call ForceAddPlayer(bc[Ub[Uew]],Ib[Uew])
call SetPlayerTechMaxAllowed(Ib[Uew],1747990087,0)
call SetPlayerTechMaxAllowed(Ib[Uew],1747990088,0)
call SetPlayerTechMaxAllowed(Ib[Uew],1747989558,0)
call SetPlayerTechMaxAllowed(Ib[Uew],1747989575,0)
call SetPlayerTechMaxAllowed(Ib[Uew],1747990339,0)
call SetPlayerTechMaxAllowed(Ib[Uew],1747990340,0)
call SetPlayerTechMaxAllowed(Ib[Uew],1747988528,0)
call SetPlayerTechMaxAllowed(Ib[Uew],1747988532,0)
set Pew=Ub[Uew]
if Pew==0 then
call SetPlayerTechMaxAllowed(Ib[Uew],1747988528,-1)
call SetPlayerTechMaxAllowed(Ib[Uew],1747988532,-1)
elseif Pew==1 then
call SetPlayerTechMaxAllowed(Ib[Uew],1747990339,-1)
call SetPlayerTechMaxAllowed(Ib[Uew],1747990340,-1)
elseif Pew==2 then
call SetPlayerTechMaxAllowed(Ib[Uew],1747990087,-1)
call SetPlayerTechMaxAllowed(Ib[Uew],1747990088,-1)
elseif Pew==3 then
call SetPlayerTechMaxAllowed(Ib[Uew],1747989558,-1)
call SetPlayerTechMaxAllowed(Ib[Uew],1747989575,-1)
endif
endfunction
function Gdw takes integer Tdw,string Ydw returns nothing
set Xb[Lb]=Ydw
set Lb=Lb+1
if rl[Tdw]==0 then
if Tdw==0 then
call x1("Nullpointer exception when calling LLIterator.LLIterator","when calling error in LinkedList, line 406")
else
call x1("Called LLIterator.LLIterator on invalid object.","when calling error in LinkedList, line 406")
endif
endif
set Xb[Lb]="when calling destroyLLIterator in LinkedList, line 406"
set Lb=Lb+1
set Xb[Lb]="when calling dealloc_LLIterator in LinkedList, line 406"
set Lb=Lb+1
if rl[Tdw]==0 then
call x1("Double free: object of type LLIterator","when calling error in LinkedList, line 406")
else
set MO[wl]=Tdw
set wl=wl+1
set rl[Tdw]=0
endif
set Lb=Lb-1-1-1
endfunction
function jdw takes integer gdw,string hdw returns nothing
local integer Fdw
local integer kdw
set Xb[Lb]=hdw
set Lb=Lb+1
if rl[gdw]==0 then
if gdw==0 then
call x1("Nullpointer exception when calling LLIterator.reset","when calling error in LinkedList, line 421")
else
call x1("Called LLIterator.reset on invalid object.","when calling error in LinkedList, line 421")
endif
endif
set Xb[Lb]="when calling reset in LinkedList, line 421"
set Lb=Lb+1
set Fdw=gb[gdw]
set Xb[Lb]="when calling getDummy in LinkedList, line 422"
set Lb=Lb+1
if Sl[Fdw]==0 then
if Fdw==0 then
call x1("Nullpointer exception when calling LinkedList.getDummy","when calling error in LinkedList, line 362")
else
call x1("Called LinkedList.getDummy on invalid object.","when calling error in LinkedList, line 362")
endif
endif
set kdw=Fb[Fdw]
set Lb=Lb-1
set Yb[gdw]=kdw
set Gb[gdw]=Yb[gdw]
set Lb=Lb-1-1
endfunction
function ibw takes integer rbw,string sbw returns integer
local integer tbw
set Xb[Lb]=sbw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_LLIterator in LinkedList, line 412"
set Lb=Lb+1
if wl==0 then
if ul<32768 then
set ul=ul+1
set tbw=ul
set rl[tbw]=700
else
call x1("Out of memory: Could not create LLIterator.","when calling error in LinkedList, line 406")
set tbw=0
endif
else
set wl=wl-1
set tbw=MO[wl]
set rl[tbw]=700
endif
set Lb=Lb-1
set Xb[Lb]="when calling construct_LLIterator in LinkedList, line 412"
set Lb=Lb+1
set hb[tbw]=true
set gb[tbw]=rbw
call jdw(tbw,"when calling reset in LinkedList, line 414")
set Lb=Lb-1-1
return tbw
endfunction
function lV takes unit tV,string iV returns integer
local integer SV
local integer cV
local integer oV
local unit OV
set Xb[Lb]=iV
set Lb=Lb+1
set SV=0
set cV=dS-1
loop
exitwhen SV>cV
set oV=FS[SV]
set iV="when calling getCityUnit in City, line 443"
set Xb[Lb]="when calling getCityUnit in City, line 443"
set Lb=Lb+1
if pO[oV]==0 then
if oV==0 then
call x1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call x1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set OV=xl[oV]
set Lb=Lb-1
if OV==tV then
set Lb=Lb-1
set OV=null
return SV
endif
set SV=SV+1
endloop
set Lb=Lb-1
set OV=null
return -1
endfunction
function ftw takes integer atw,integer ntw,string dtw returns nothing
set Xb[Lb]=dtw
set Lb=Lb+1
if not Cnw(No,ntw,"when calling has in City, line 195") then
set Lb=Lb-1
return
endif
set xl[atw]=ReplaceUnitBJ(xl[atw],ntw,bj_UNIT_STATE_METHOD_RELATIVE)
set Lb=Lb-1
endfunction
function Fiw takes integer giw returns string
local string hiw
if Ul[giw]<100000 then
set hiw=I2S(R2I(Ul[giw]*1./1000))+","+I2S(R2I(ModuloReal(Ul[giw],1000)/100.))+"k"
else
set hiw=I2S(R2I(Ul[giw]*1./1000))+"k"
endif
return hiw
endfunction
function wnw takes integer Naw,string Maw returns nothing
set Xb[Lb]=Maw
set Lb=Lb+1
if nO[Naw]==0 then
if Naw==0 then
call x1("Nullpointer exception when calling ForGroupCallback.ForGroupCallback","when calling error in ClosureForGroups, line 3")
else
call x1("Called ForGroupCallback.ForGroupCallback on invalid object.","when calling error in ClosureForGroups, line 3")
endif
endif
set Xb[Lb]="when calling destroyForGroupCallback in ClosureForGroups, line 3"
set Lb=Lb+1
set Xb[Lb]="when calling dealloc_ForGroupCallback in ClosureForGroups, line 3"
set Lb=Lb+1
if nO[Naw]==0 then
call x1("Double free: object of type ForGroupCallback","when calling error in ClosureForGroups, line 3")
else
set eO[qO]=Naw
set qO=qO+1
set nO[Naw]=0
endif
set Lb=Lb-1-1-1
endfunction
function YB takes real nB,real dB,real fB,integer RB,string TB returns nothing
set Xb[Lb]=TB
set Lb=Lb+1
set AS[DS]=RB
set DS=DS+1
set JS=0
set HS=2147483647
call GroupEnumUnitsInRange(PS,nB,dB,fB,KS)
set Xb[Lb]="when calling popCallback in ClosureForGroups, line 98"
set Lb=Lb+1
call GroupClear(PS)
set DS=DS-1
call wnw(AS[DS],"when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 30")
set Lb=Lb-1-1
endfunction
function a5 takes player b5,string y5 returns string
local integer p5
local integer e5
local integer q5
set Xb[Lb]=y5
set Lb=Lb+1
set e5=wo[GetPlayerId(b5)]
set Xb[Lb]="when calling getForceId in Messages, line 53"
set Lb=Lb+1
if yl[e5]==0 then
if e5==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set q5=Ub[e5]
set Lb=Lb-1
set p5=GetRandomInt(0,2)
if q5==0 then
set y5=xo[p5]
elseif q5==1 then
set y5=vo[p5]
elseif q5==2 then
set y5=mo[p5]
elseif q5==3 then
set y5=Qo[p5]
else
set y5="Attention!"
endif
set Lb=Lb-1
return "|cffffa600"+y5+"|r"
endfunction
function ldw takes integer Sdw,integer cdw,string odw returns integer
local integer Odw
set Xb[Lb]=odw
set Lb=Lb+1
if AO[Sdw]==0 then
if Sdw==0 then
call x1("Nullpointer exception when calling HashMap.get","when calling error in HashMap, line 23")
else
call x1("Called HashMap.get on invalid object.","when calling error in HashMap, line 23")
endif
endif
set Xb[Lb]="when calling get in HashMap, line 23"
set Lb=Lb+1
set Xb[Lb]="when calling loadInt in HashMap, line 24"
set Lb=Lb+1
if AO[Sdw]==0 then
if Sdw==0 then
call x1("Nullpointer exception when calling Table.loadInt","when calling error in Table, line 39")
else
call x1("Called Table.loadInt on invalid object.","when calling error in Table, line 39")
endif
endif
set Odw=LoadInteger(Eo,Sdw,cdw)
set Lb=Lb-1-1-1
return Odw
endfunction
function Eaw takes integer maw,integer Qaw,string Waw returns nothing
set Xb[Lb]=Waw
set Lb=Lb+1
if pO[maw]==0 then
if maw==0 then
call x1("Nullpointer exception when calling City.getCityModifierOnAdd","when calling error in City, line 420")
else
call x1("Called City.getCityModifierOnAdd on invalid object.","when calling error in City, line 420")
endif
endif
set Xb[Lb]="when calling getCityModifierOnAdd in City, line 420"
set Lb=Lb+1
set Dl[maw]=Dl[maw]+Tl[ldw(nS,Qaw,"when calling get in City, line 421")]
set Hl[maw]=Hl[maw]+Fl[ldw(nS,Qaw,"when calling get in City, line 422")]
set Lb=Lb-1-1
endfunction
function K2 takes string J2 returns nothing
if (not gc)and(not hc) then
return
endif
call DisplayTimedTextToPlayer(uo[0],0.,0.,60.,J2)
endfunction
function ebw takes integer bbw,integer ybw returns boolean
local integer pbw=Tb[Fb[bbw]]
loop
exitwhen pbw==Fb[bbw]
if fb[pbw]==ybw then
return true
endif
set pbw=Tb[pbw]
endloop
return false
endfunction
function Xcw takes integer Hcw,timer Jcw,real Kcw,string Lcw returns nothing
set Xb[Lb]=Lcw
set Lb=Lb+1
call Bww(Jcw,Hcw,"when calling setData in ClosureTimers, line 113")
call TimerStart(Jcw,Kcw,false,wR)
set ob[Hcw]=Jcw
set Lb=Lb-1
endfunction
function hnw takes integer Tnw,timer Ynw,real Gnw,string gnw returns nothing
set Xb[Lb]=gnw
set Lb=Lb+1
if TO[Tnw]==0 then
if Tnw==0 then
call x1("Nullpointer exception when calling CallbackSingle.start","when calling error in ClosureTimers, line 111")
else
call x1("Called CallbackSingle.start on invalid object.","when calling error in ClosureTimers, line 111")
endif
endif
call Xcw(Tnw,Ynw,Gnw,"when calling start in ClosureTimers, line 111")
set Lb=Lb-1
endfunction
function ctw takes integer Msw,integer wtw,string utw returns boolean
local real rtw
local integer stw
local boolean ttw
local integer itw
local timer Stw
set Xb[Lb]=utw
set Lb=Lb+1
set stw=Ll[Msw]
set Xb[Lb]="when calling has in City, line 369"
set Lb=Lb+1
if Sl[stw]==0 then
if stw==0 then
call x1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call x1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set ttw=ebw(stw,wtw)
set Lb=Lb-1
if ttw then
set Lb=Lb-1
set Stw=null
return false
endif
call jfw(Ll[Msw],wtw,"when calling add in City, line 371")
call Eaw(Msw,wtw,"when calling getCityModifierOnAdd in City, line 372")
call K2("Added a modifier "+kl[ldw(nS,wtw,"when calling get in City, line 373")]+" | "+R2SW(Rl[ldw(nS,wtw,"when calling get in City, line 373")],3,3))
set rtw=Rl[ldw(nS,wtw,"when calling get in City, line 374")]
set Xb[Lb]="when calling alloc_City_City_CallbackSingle_line374 in City, line 374"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set itw=RO
set TO[itw]=639
else
call x1("Out of memory: Could not create City_City_CallbackSingle_line374.","when calling error in City, line 374")
set itw=0
endif
else
set fO=fO-1
set itw=dO[fO]
set TO[itw]=639
endif
set Lb=Lb-1
set Vl[itw]=Msw
set Bl[itw]=wtw
set Xb[Lb]="when calling doAfter in City, line 374"
set Lb=Lb+1
set Stw=Sww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(itw,Stw,rtw,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1-1
set Stw=null
return true
endfunction
function haw takes integer naw,string daw returns string
local integer faw
local integer Raw
local integer Taw
local integer Yaw
local integer Gaw
local integer gaw
set Xb[Lb]=daw
set Lb=Lb+1
if pO[naw]==0 then
if naw==0 then
call x1("Nullpointer exception when calling City.getCityNameColored","when calling error in City, line 179")
else
call x1("Called City.getCityNameColored on invalid object.","when calling error in City, line 179")
endif
endif
set Yaw=yc[Ql[naw]]
set Gaw=pc[Ql[naw]]
set gaw=ec[Ql[naw]]
set faw=Yaw/16
set Raw=Gaw/16
set Taw=gaw/16
set daw="|cff"+BS[faw]+BS[Yaw-faw*16]+BS[Raw]+BS[Gaw-Raw*16]+BS[Taw]+BS[gaw-Taw*16]+vl[naw]+"|r"
set Lb=Lb-1
return daw
endfunction
function qww takes integer D0w,string H0w returns nothing
local integer J0w
local unit K0w
local integer L0w
local integer X0w
local integer C0w
local integer V0w
local integer B0w
local integer N0w
local integer M0w
local real www
local integer uww
local integer rww
local integer sww
local unit tww
local player iww
local integer Sww_2
local player cww
local integer oww
local integer Oww
local integer lww
local integer bww
local integer yww_2
local integer pww
local boolean eww
set Xb[Lb]=H0w
set Lb=Lb+1
if D0w<0 or D0w>=dS then
set Lb=Lb-1
set K0w=null
set tww=null
set iww=null
set cww=null
return
endif
if kc-qo[D0w]<=60 then
set Lb=Lb-1
set K0w=null
set tww=null
set iww=null
set cww=null
return
endif
set M0w=FS[D0w]
set Xb[Lb]="when calling getLastPublicOrder in Revolts, line 21"
set Lb=Lb+1
if pO[M0w]==0 then
if M0w==0 then
call x1("Nullpointer exception when calling City.getLastPublicOrder","when calling error in City, line 335")
else
call x1("Called City.getLastPublicOrder on invalid object.","when calling error in City, line 335")
endif
endif
set www=Al[M0w]
set Lb=Lb-1
set uww=FS[D0w]
set Xb[Lb]="when calling getPopulation in Revolts, line 22"
set Lb=Lb+1
if pO[uww]==0 then
if uww==0 then
call x1("Nullpointer exception when calling City.getPopulation","when calling error in City, line 344")
else
call x1("Called City.getPopulation on invalid object.","when calling error in City, line 344")
endif
endif
set rww=Ul[uww]
set Lb=Lb-1
set J0w=rww
set sww=FS[D0w]
set Xb[Lb]="when calling getCityUnit in Revolts, line 23"
set Lb=Lb+1
if pO[sww]==0 then
if sww==0 then
call x1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call x1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set tww=xl[sww]
set Lb=Lb-1
set K0w=tww
set iww=GetOwningPlayer(tww)
if GetPlayerSlotState(iww)==PLAYER_SLOT_STATE_PLAYING then
set eww=GetPlayerController(iww)==MAP_CONTROL_USER
else
set eww=false
endif
if not eww then
set Lb=Lb-1
set K0w=null
set tww=null
set iww=null
set cww=null
return
endif
if www<50.0 then
set qo[D0w]=kc
set Sww_2=FS[D0w]
set Xb[Lb]="when calling addModifier in Revolts, line 28"
set Lb=Lb+1
if pO[Sww_2]==0 then
if Sww_2==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(Sww_2,1,"when calling addModifier in City, line 368")
set Lb=Lb-1
set H0w="A violent mob has appeared near the gates of "+haw(FS[D0w],"when calling getCityNameColored in Revolts, line 29")+"!"
set cww=GetOwningPlayer(tww)
set Xb[Lb]="when calling attentionToPlayer in Revolts, line 29"
set Lb=Lb+1
call DisplayTimedTextToPlayer(cww,0.,0.,10.0,a5(cww,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(cww,0.,0.,10.0,H0w)
set Lb=Lb-1
if www>=30.0 then
set oww=Mo[0]
set Xb[Lb]="when calling iterator in Revolts, line 32"
set Lb=Lb+1
set Oww=ibw(oww,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set L0w=Oww
loop
exitwhen Tb[Gb[L0w]]==Yb[L0w]
set Gb[L0w]=Tb[Gb[L0w]]
set X0w=fb[Gb[L0w]]
call CreateUnit(uo[PLAYER_NEUTRAL_AGGRESSIVE],X0w,GetUnitX(K0w),GetUnitY(K0w),0.)
if GetRandomReal(0.0,1.0)<=J0w*1./150000 then
call CreateUnit(uo[PLAYER_NEUTRAL_AGGRESSIVE],X0w,GetUnitX(K0w),GetUnitY(K0w),0.)
endif
endloop
set Xb[Lb]="when calling close in Revolts, line 32"
set Lb=Lb+1
if hb[L0w]then
call Gdw(L0w,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
elseif www>=15.0 then
set lww=Mo[1]
set Xb[Lb]="when calling iterator in Revolts, line 38"
set Lb=Lb+1
set bww=ibw(lww,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set C0w=bww
loop
exitwhen Tb[Gb[C0w]]==Yb[C0w]
set Gb[C0w]=Tb[Gb[C0w]]
set V0w=fb[Gb[C0w]]
call CreateUnit(uo[PLAYER_NEUTRAL_AGGRESSIVE],V0w,GetUnitX(K0w),GetUnitY(K0w),0.)
if GetRandomReal(0.0,1.0)<=J0w*1./150000 then
call CreateUnit(uo[PLAYER_NEUTRAL_AGGRESSIVE],V0w,GetUnitX(K0w),GetUnitY(K0w),0.)
endif
endloop
set Xb[Lb]="when calling close in Revolts, line 38"
set Lb=Lb+1
if hb[C0w]then
call Gdw(C0w,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
else
set yww_2=Mo[2]
set Xb[Lb]="when calling iterator in Revolts, line 44"
set Lb=Lb+1
set pww=ibw(yww_2,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set B0w=pww
loop
exitwhen Tb[Gb[B0w]]==Yb[B0w]
set Gb[B0w]=Tb[Gb[B0w]]
set N0w=fb[Gb[B0w]]
call CreateUnit(uo[PLAYER_NEUTRAL_AGGRESSIVE],N0w,GetUnitX(K0w),GetUnitY(K0w),0.)
if GetRandomReal(0.0,1.0)<=J0w*1./150000 then
call CreateUnit(uo[PLAYER_NEUTRAL_AGGRESSIVE],N0w,GetUnitX(K0w),GetUnitY(K0w),0.)
endif
endloop
set Xb[Lb]="when calling close in Revolts, line 44"
set Lb=Lb+1
if hb[B0w]then
call Gdw(B0w,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
endif
endif
set Lb=Lb-1
set K0w=null
set tww=null
set iww=null
set cww=null
endfunction
function qiw takes integer Siw,string ciw returns real
local integer oiw
local integer Oiw
local boolean liw
local real biw
local real yiw
local real piw
local real eiw
set Xb[Lb]=ciw
set Lb=Lb+1
set Al[Siw]=100.0-Pl[Siw]*1000.-SquareRoot(Ul[Siw]*1.)/17.+Dl[Siw]-Ul[Siw]*1./1000*gS[Jl[Siw]]
set biw=El[Siw]
set yiw=Zl[Siw]
set Xb[Lb]="when calling alloc_City_City_ForGroupCallback_line313 in City, line 313"
set Lb=Lb+1
if qO==0 then
if aO<32768 then
set aO=aO+1
set oiw=aO
set nO[oiw]=685
else
call x1("Out of memory: Could not create City_City_ForGroupCallback_line313.","when calling error in City, line 313")
set oiw=0
endif
else
set qO=qO-1
set oiw=eO[qO]
set nO[oiw]=685
endif
set Lb=Lb-1
set Xl[oiw]=Siw
call YB(biw,yiw,500,oiw,"when calling forUnitsInRange in City, line 313")
set piw=El[Siw]
set eiw=Zl[Siw]
set Xb[Lb]="when calling alloc_City_City_ForGroupCallback_line317 in City, line 317"
set Lb=Lb+1
if qO==0 then
if aO<32768 then
set aO=aO+1
set Oiw=aO
set nO[Oiw]=686
else
call x1("Out of memory: Could not create City_City_ForGroupCallback_line317.","when calling error in City, line 317")
set Oiw=0
endif
else
set qO=qO-1
set Oiw=eO[qO]
set nO[Oiw]=686
endif
set Lb=Lb-1
set Cl[Oiw]=Siw
call YB(piw,eiw,1500.0,Oiw,"when calling forUnitsInRange in City, line 317")
if Al[Siw]<0.0 then
set Al[Siw]=0.0
endif
if Al[Siw]>100.0 then
set Al[Siw]=100.0
endif
if Al[Siw]<50.0 then
set liw=GetRandomReal(0.0,1.0)<=0.01
else
set liw=false
endif
if liw then
call qww(ml[Siw],"when calling checkForRevolt in City, line 328")
endif
set Lb=Lb-1
return Al[Siw]
endfunction
function Giw takes integer aiw,string niw returns string
local real diw
local integer fiw
local integer Riw
local integer Tiw
local integer Yiw
set Xb[Lb]=niw
set Lb=Lb+1
set Xb[Lb]="when calling countPublicOrder in City, line 339"
set Lb=Lb+1
if pO[aiw]==0 then
if aiw==0 then
call x1("Nullpointer exception when calling City.countPublicOrder","when calling error in City, line 308")
else
call x1("Called City.countPublicOrder on invalid object.","when calling error in City, line 308")
endif
endif
set diw=qiw(aiw,"when calling countPublicOrder in City, line 308")
set Lb=Lb-1
set Tiw=R2I(255.-diw/100.*255.)
set Yiw=R2I(diw/100.*255.)
set fiw=Tiw/16
set Riw=Yiw/16
set niw=StringCase("|cff"+BS[fiw]+BS[Tiw-fiw*16]+BS[Riw]+BS[Yiw-Riw*16]+BS[0]+BS[0],false)+I2S(R2I(diw))+","+I2S(R2I(ModuloReal(R2I(diw*10.),10)))+"%|r"
set Lb=Lb-1
return niw
endfunction
function iiw takes integer Btw,string Ntw returns integer
local integer Mtw
local real wiw
local real uiw
local real riw
local real siw
local real tiw
set Xb[Lb]=Ntw
set Lb=Lb+1
set Mtw=0
set Mtw=0+ldw(SS,GetUnitTypeId(xl[Btw]),"when calling get in City, line 283")
set tiw=Ul[Btw]*1.
set Xb[Lb]="when calling countPublicOrder in City, line 295"
set Lb=Lb+1
if pO[Btw]==0 then
if Btw==0 then
call x1("Nullpointer exception when calling City.countPublicOrder","when calling error in City, line 308")
else
call x1("Called City.countPublicOrder on invalid object.","when calling error in City, line 308")
endif
endif
set siw=qiw(Btw,"when calling countPublicOrder in City, line 308")
set Lb=Lb-1
set wiw=siw/100.
set uiw=yo
if 0.75>uiw then
set riw=0.75
else
set riw=uiw
endif
if wiw>riw then
set riw=wiw
endif
set Mtw=Mtw+R2I(SquareRoot(tiw*riw)/6.)
set Mtw=R2I(Mtw*Hl[Btw]*YS[Jl[Btw]])
set Lb=Lb-1
return Mtw
endfunction
function Tww takes string pww,string eww returns integer
local integer qww_2
local integer aww
local boolean nww
local integer dww
local string fww
local integer Rww
set Xb[Lb]=eww
set Lb=Lb+1
set qww_2=StringHash(pww)
loop
set aww=Po
set Xb[Lb]="when calling hasString in TypeCasting, line 25"
set Lb=Lb+1
if AO[aww]==0 then
if aww==0 then
call x1("Nullpointer exception when calling Table.hasString","when calling error in Table, line 18")
else
call x1("Called Table.hasString on invalid object.","when calling error in Table, line 18")
endif
endif
set nww=HaveSavedString(Eo,aww,qww_2)
set Lb=Lb-1
if nww then
set dww=Po
set eww="when calling loadString in TypeCasting, line 26"
set Xb[Lb]="when calling loadString in TypeCasting, line 26"
set Lb=Lb+1
if AO[dww]==0 then
if dww==0 then
call x1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call x1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set fww=LoadStr(Eo,dww,qww_2)
set Lb=Lb-1
exitwhen fww==pww
else
set Rww=Po
set Xb[Lb]="when calling saveString in TypeCasting, line 29"
set Lb=Lb+1
if AO[Rww]==0 then
if Rww==0 then
call x1("Nullpointer exception when calling Table.saveString","when calling error in Table, line 60")
else
call x1("Called Table.saveString on invalid object.","when calling error in Table, line 60")
endif
endif
call SaveStr(Eo,Rww,qww_2,pww)
set Lb=Lb-1
exitwhen true
endif
set qww_2=qww_2+1
endloop
set Lb=Lb-1
return qww_2
endfunction
function O4 takes integer t4,integer i4,integer S4,string c4 returns integer
local integer o4
set Xb[Lb]=c4
set Lb=Lb+1
set Xb[Lb]="when calling stringFromIndex in LinkedList, line 349"
set Lb=Lb+1
set o4=Po
set Xb[Lb]="when calling loadString in TypeCasting, line 35"
set Lb=Lb+1
if AO[o4]==0 then
if o4==0 then
call x1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call x1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set c4=LoadStr(Eo,o4,S4)
set Lb=Lb-1-1
set t4=Tww(c4+I2S(i4)+",","when calling stringToIndex in LinkedList, line 349")
set Lb=Lb-1
return t4
endfunction
function ndw takes integer qdw,string adw returns nothing
set Xb[Lb]=adw
set Lb=Lb+1
if XO[qdw]==0 then
if qdw==0 then
call x1("Nullpointer exception when calling FoldClosure.FoldClosure","when calling error in LinkedList, line 498")
else
call x1("Called FoldClosure.FoldClosure on invalid object.","when calling error in LinkedList, line 498")
endif
endif
set Xb[Lb]="when calling destroyFoldClosure in LinkedList, line 498"
set Lb=Lb+1
set Xb[Lb]="when calling dealloc_FoldClosure in LinkedList, line 498"
set Lb=Lb+1
if XO[qdw]==0 then
call x1("Double free: object of type FoldClosure","when calling error in LinkedList, line 498")
else
set JO[KO]=qdw
set KO=KO+1
set XO[qdw]=0
endif
set Lb=Lb-1-1-1
endfunction
function mbw takes integer Gbw,integer gbw,integer hbw,string Fbw returns integer
local integer kbw
local integer jbw
local integer xbw
local integer vbw
set Xb[Lb]=Fbw
set Lb=Lb+1
set kbw=gbw
set jbw=Tb[Fb[Gbw]]
loop
exitwhen jbw==Fb[Gbw]
set xbw=fb[jbw]
set Fbw="when calling run in LinkedList, line 281"
set Xb[Lb]="when calling run in LinkedList, line 281"
set Lb=Lb+1
if XO[hbw]==0 then
if hbw==0 then
call x1("Nullpointer exception when calling FoldClosure.run","when calling error in LinkedList, line 499")
else
call x1("Called FoldClosure.run on invalid object.","when calling error in LinkedList, line 499")
endif
endif
set vbw=O4(hbw,xbw,kbw,"when calling run_wrapper in LinkedList, line 499")
set Lb=Lb-1
set kbw=vbw
set jbw=Tb[jbw]
endloop
call ndw(hbw,"when calling dispatch_FoldClosure_destroyFoldClosure in LinkedList, line 283")
set Lb=Lb-1
return kbw
endfunction
function Abw takes integer Qbw,string Wbw returns string
local string Ebw
local integer Zbw
local integer Ubw
local integer Ibw
local integer Pbw
set Xb[Lb]=Wbw
set Lb=Lb+1
set Zbw=Tww("[","when calling stringToIndex in LinkedList, line 349")
set Xb[Lb]="when calling alloc_LinkedList_LinkedList_FoldClosure_line349 in LinkedList, line 349"
set Lb=Lb+1
if KO==0 then
if LO<32768 then
set LO=LO+1
set Ubw=LO
set XO[Ubw]=683
else
call x1("Out of memory: Could not create LinkedList_LinkedList_FoldClosure_line349.","when calling error in LinkedList, line 349")
set Ubw=0
endif
else
set KO=KO-1
set Ubw=JO[KO]
set XO[Ubw]=683
endif
set Lb=Lb-1
set Xb[Lb]="when calling foldl in LinkedList, line 349"
set Lb=Lb+1
if Sl[Qbw]==0 then
if Qbw==0 then
call x1("Nullpointer exception when calling LinkedList.foldl","when calling error in LinkedList, line 277")
else
call x1("Called LinkedList.foldl on invalid object.","when calling error in LinkedList, line 277")
endif
endif
set Pbw=mbw(Qbw,Zbw,Ubw,"when calling foldl in LinkedList, line 277")
set Lb=Lb-1
set Xb[Lb]="when calling stringFromIndex in LinkedList, line 349"
set Lb=Lb+1
set Ibw=Po
set Xb[Lb]="when calling loadString in TypeCasting, line 35"
set Lb=Lb+1
if AO[Ibw]==0 then
if Ibw==0 then
call x1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call x1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set Wbw=LoadStr(Eo,Ibw,Pbw)
set Lb=Lb-1-1
set Ebw=SubString(Wbw,0,StringLength(Wbw)-1)+"]"
set Lb=Lb-1
return Ebw
endfunction
function vaw takes integer Faw,string kaw returns integer
local integer jaw
local integer xaw
set Xb[Lb]=kaw
set Lb=Lb+1
if pO[Faw]==0 then
if Faw==0 then
call x1("Nullpointer exception when calling City.getModifiers","when calling error in City, line 391")
else
call x1("Called City.getModifiers on invalid object.","when calling error in City, line 391")
endif
endif
set Xb[Lb]="when calling getModifiers in City, line 391"
set Lb=Lb+1
set xaw=Ll[Faw]
set Xb[Lb]="when calling toString in City, line 392"
set Lb=Lb+1
if Sl[xaw]==0 then
if xaw==0 then
call x1("Nullpointer exception when calling LinkedList.toString","when calling error in LinkedList, line 348")
else
call x1("Called LinkedList.toString on invalid object.","when calling error in LinkedList, line 348")
endif
endif
set kaw=Abw(xaw,"when calling toString in LinkedList, line 348")
set Lb=Lb-1
call K2(kaw)
set Lb=Lb-1
set jaw=Ll[Faw]
set Lb=Lb-1
return jaw
endfunction
function w9 takes multiboard J8,integer K8,integer L8,string X8,real C8 returns nothing
local multiboarditem V8=MultiboardGetItem(J8,L8,K8)
local string B8=X8
local string N8
local integer M8
set L8=R2I((R2I(C8/0.004)-StringLength(X8))*1./2)
set N8=""
set M8=0
set K8=L8-1
loop
exitwhen M8>K8
set N8=N8+" "
set M8=M8+1
endloop
if ModuloReal(L8,2)==1. then
set B8=" "+B8
endif
set B8=N8+B8
call MultiboardSetItemValue(V8,B8)
set V8=null
endfunction
function W2 takes real Q2 returns real
if Q2>0. then
return 1.
elseif Q2<0. then
return -1.
else
return 0.
endif
endfunction
function xww takes integer kww returns string
local string jww="|cff15ff00+"
if W2(kww*1.)==-1. then
set jww="|cffff0000"
endif
return jww+I2S(kww)+"|r"
endfunction
function yew takes integer Upw,string Ipw returns nothing
local integer Ppw
local multiboard Apw
local integer Dpw
local integer Hpw
local integer Jpw
local multiboard Kpw
local integer Lpw
local integer Xpw
local multiboard Cpw
local integer Vpw
local integer Bpw
local integer Npw
local integer Mpw
local string wew
local integer uew
local string rew
local integer sew
local string tew
local integer iew
local integer Sew
local string cew
local integer oew
local integer Oew
local string lew
local string bew
set Xb[Lb]=Ipw
set Lb=Lb+1
if Ab[Upw]==-1 then
set Lb=Lb-1
set Apw=null
set Kpw=null
set Cpw=null
return
endif
set Ppw=GetPlayerId(Ib[Upw])
call w9(Xc[Ppw],Kc[0],Kc[1],haw(FS[Ab[Upw]],"when calling getCityNameColored in PlayerStats, line 76"),0.40)
set Vpw=FS[Ab[Upw]]
set Xb[Lb]="when calling countTax in PlayerStats, line 85"
set Lb=Lb+1
if pO[Vpw]==0 then
if Vpw==0 then
call x1("Nullpointer exception when calling City.countTax","when calling error in City, line 279")
else
call x1("Called City.countTax on invalid object.","when calling error in City, line 279")
endif
endif
set Bpw=iiw(Vpw,"when calling countTax in City, line 279")
set Lb=Lb-1
set Npw=FS[Ab[Upw]]
set Xb[Lb]="when calling getTaxLevelString in PlayerStats, line 86"
set Lb=Lb+1
if pO[Npw]==0 then
if Npw==0 then
call x1("Nullpointer exception when calling City.getTaxLevelString","when calling error in City, line 176")
else
call x1("Called City.getTaxLevelString on invalid object.","when calling error in City, line 176")
endif
endif
set Ipw=Wo[Jl[Npw]]
set Lb=Lb-1
set Mpw=FS[Ab[Upw]]
set Xb[Lb]="when calling getPublicOrderStr in PlayerStats, line 87"
set Lb=Lb+1
if pO[Mpw]==0 then
if Mpw==0 then
call x1("Nullpointer exception when calling City.getPublicOrderStr","when calling error in City, line 338")
else
call x1("Called City.getPublicOrderStr on invalid object.","when calling error in City, line 338")
endif
endif
set wew=Giw(Mpw,"when calling getPublicOrderStr in City, line 338")
set Lb=Lb-1
set uew=FS[Ab[Upw]]
set Xb[Lb]="when calling getPopulationStr in PlayerStats, line 88"
set Lb=Lb+1
if pO[uew]==0 then
if uew==0 then
call x1("Nullpointer exception when calling City.getPopulationStr","when calling error in City, line 359")
else
call x1("Called City.getPopulationStr on invalid object.","when calling error in City, line 359")
endif
endif
set rew=Fiw(uew)
set Lb=Lb-1
set sew=FS[Ab[Upw]]
set Xb[Lb]="when calling getPopulationGrowthStr in PlayerStats, line 89"
set Lb=Lb+1
if pO[sew]==0 then
if sew==0 then
call x1("Nullpointer exception when calling City.getPopulationGrowthStr","when calling error in City, line 356")
else
call x1("Called City.getPopulationGrowthStr on invalid object.","when calling error in City, line 356")
endif
endif
set tew=xww(Il[sew])
set Lb=Lb-1
set Apw=Xc[Ppw]
set iew=Ac[0]
set Sew=Ac[1]
set cew=I2S(Bpw)
call MultiboardSetItemValue(MultiboardGetItem(Apw,Sew,iew),cew)
call MultiboardSetItemValue(MultiboardGetItem(Apw,Ac[1],Ac[0]+1),Ipw)
call MultiboardSetItemValue(MultiboardGetItem(Apw,Dc[1],Dc[0]),wew)
call MultiboardSetItemValue(MultiboardGetItem(Apw,Hc[1],Hc[0]),rew)
call MultiboardSetItemValue(MultiboardGetItem(Apw,Jc[1],Jc[0]),tew)
set Dpw=0
set oew=vaw(FS[Ab[Upw]],"when calling getModifiers in PlayerStats, line 99")
set Xb[Lb]="when calling iterator in PlayerStats, line 99"
set Lb=Lb+1
set Oew=ibw(oew,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set Hpw=Oew
loop
exitwhen Tb[Gb[Hpw]]==Yb[Hpw]
set Gb[Hpw]=Tb[Gb[Hpw]]
set Jpw=fb[Gb[Hpw]]
set Kpw=Xc[Ppw]
set lew=kl[ldw(nS,Jpw,"when calling get in PlayerStats, line 101")]
call MultiboardSetItemValue(MultiboardGetItem(Kpw,4+Dpw,4),lew)
set bew="("+jl[ldw(nS,Jpw,"when calling get in PlayerStats, line 102")]+")"
call MultiboardSetItemValue(MultiboardGetItem(Kpw,4+Dpw,5),bew)
set Dpw=Dpw+1
endloop
set Xb[Lb]="when calling close in PlayerStats, line 99"
set Lb=Lb+1
if hb[Hpw]then
call Gdw(Hpw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
set Lpw=Dpw
set Xpw=9
loop
exitwhen Lpw>Xpw
set Cpw=Xc[Ppw]
call MultiboardSetItemValue(MultiboardGetItem(Cpw,4+Lpw,4)," ")
call MultiboardSetItemValue(MultiboardGetItem(Cpw,4+Lpw,5)," ")
set Lpw=Lpw+1
endloop
set Lb=Lb-1
set Apw=null
set Kpw=null
set Cpw=null
endfunction
function qtw takes integer otw,string Otw returns nothing
local integer ltw
local integer btw
local integer ytw
local integer ptw
local integer etw
set Xb[Lb]=Otw
set Lb=Lb+1
set ltw=0
set btw=23
loop
exitwhen ltw>btw
set ytw=wo[ltw]
set Xb[Lb]="when calling getSelectedCityId in City, line 252"
set Lb=Lb+1
if yl[ytw]==0 then
if ytw==0 then
call x1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call x1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set ptw=Ab[ytw]
set Lb=Lb-1
if ptw==ml[otw]then
set etw=wo[ltw]
set Otw="when calling refreshMultiboardCity in City, line 253"
set Xb[Lb]="when calling refreshMultiboardCity in City, line 253"
set Lb=Lb+1
if yl[etw]==0 then
if etw==0 then
call x1("Nullpointer exception when calling PlayerStats.refreshMultiboardCity","when calling error in PlayerStats, line 71")
else
call x1("Called PlayerStats.refreshMultiboardCity on invalid object.","when calling error in PlayerStats, line 71")
endif
endif
call yew(etw,"when calling refreshMultiboardCity in PlayerStats, line 71")
set Lb=Lb-1
endif
set ltw=ltw+1
endloop
set Lb=Lb-1
endfunction
function htw takes integer Rtw,integer Ttw,string Ytw returns nothing
local integer Gtw
local integer gtw
set Xb[Lb]=Ytw
set Lb=Lb+1
if Ttw==PLAYER_NEUTRAL_AGGRESSIVE then
call SetUnitOwner(xl[Rtw],Player(PLAYER_NEUTRAL_AGGRESSIVE),true)
set Xb[Lb]="when calling changeTaxLevelFORCED in City, line 204"
set Lb=Lb+1
if pO[Rtw]==0 then
if Rtw==0 then
call x1("Nullpointer exception when calling City.changeTaxLevelFORCED","when calling error in City, line 273")
else
call x1("Called City.changeTaxLevelFORCED on invalid object.","when calling error in City, line 273")
endif
endif
set Dl[Rtw]=Dl[Rtw]-GS[Jl[Rtw]]
set Dl[Rtw]=Dl[Rtw]+GS[0]
set Jl[Rtw]=0
set Lb=Lb-1
else
call SetUnitOwner(xl[Rtw],uo[Ttw],true)
endif
set Wl[Rtw]=Ttw
if Ttw>=0 and Ttw<24 then
set Gtw=wo[Ttw]
set Xb[Lb]="when calling getForceId in City, line 211"
set Lb=Lb+1
if yl[Gtw]==0 then
if Gtw==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set gtw=Ub[Gtw]
set Lb=Lb-1
set Ql[Rtw]=gtw
endif
set Xb[Lb]="when calling refreshMultiboardIfPossible in City, line 213"
set Lb=Lb+1
if pO[Rtw]==0 then
if Rtw==0 then
call x1("Nullpointer exception when calling City.refreshMultiboardIfPossible","when calling error in City, line 250")
else
call x1("Called City.refreshMultiboardIfPossible on invalid object.","when calling error in City, line 250")
endif
endif
call qtw(Rtw,"when calling refreshMultiboardIfPossible in City, line 250")
set Lb=Lb-1-1
endfunction
function vtw takes integer Ftw,integer ktw,string jtw returns nothing
local integer xtw
set Xb[Lb]=jtw
set Lb=Lb+1
set xtw=Ql[Ftw]
if xtw==0 then
set Xb[Lb]="when calling replaceCity in City, line 218"
set Lb=Lb+1
if pO[Ftw]==0 then
if Ftw==0 then
call x1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call x1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call ftw(Ftw,1747988529,"when calling replaceCity in City, line 194")
set Lb=Lb-1
elseif xtw==3 then
set Xb[Lb]="when calling replaceCity in City, line 220"
set Lb=Lb+1
if pO[Ftw]==0 then
if Ftw==0 then
call x1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call x1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call ftw(Ftw,1747989590,"when calling replaceCity in City, line 194")
set Lb=Lb-1
elseif xtw==1 then
set Xb[Lb]="when calling replaceCity in City, line 222"
set Lb=Lb+1
if pO[Ftw]==0 then
if Ftw==0 then
call x1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call x1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call ftw(Ftw,1747990326,"when calling replaceCity in City, line 194")
set Lb=Lb-1
elseif xtw==2 then
set Xb[Lb]="when calling replaceCity in City, line 224"
set Lb=Lb+1
if pO[Ftw]==0 then
if Ftw==0 then
call x1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call x1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call ftw(Ftw,1747990084,"when calling replaceCity in City, line 194")
set Lb=Lb-1
endif
set Xb[Lb]="when calling changeOwner in City, line 225"
set Lb=Lb+1
if pO[Ftw]==0 then
if Ftw==0 then
call x1("Nullpointer exception when calling City.changeOwner","when calling error in City, line 199")
else
call x1("Called City.changeOwner on invalid object.","when calling error in City, line 199")
endif
endif
call htw(Ftw,ktw,"when calling changeOwner in City, line 199")
set Lb=Lb-1-1
endfunction
function xC takes string eC returns nothing
local integer qC
local integer aC
local integer nC
local integer dC
local integer fC
local integer RC
local integer TC
local integer YC
local integer GC
local integer gC
local player hC
local location FC
local real kC
local integer jC
set Xb[Lb]=eC
set Lb=Lb+1
set qC=lV(GetSpellTargetUnit(),"when calling getCityId in CityManage, line 19")
set dC=FS[qC]
set Xb[Lb]="when calling getCityForceId in CityManage, line 20"
set Lb=Lb+1
if pO[dC]==0 then
if dC==0 then
call x1("Nullpointer exception when calling City.getCityForceId","when calling error in City, line 191")
else
call x1("Called City.getCityForceId on invalid object.","when calling error in City, line 191")
endif
endif
set fC=Ql[dC]
set Lb=Lb-1
set aC=GetPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))
set RC=wo[aC]
set Xb[Lb]="when calling changeForce in CityManage, line 22"
set Lb=Lb+1
if yl[RC]==0 then
if RC==0 then
call x1("Nullpointer exception when calling PlayerStats.changeForce","when calling error in PlayerStats, line 125")
else
call x1("Called PlayerStats.changeForce on invalid object.","when calling error in PlayerStats, line 125")
endif
endif
call Aew(RC,fC)
set Lb=Lb-1
set TC=Xo[fC]
set Xb[Lb]="when calling iterator in CityManage, line 25"
set Lb=Lb+1
set YC=ibw(TC,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set nC=YC
loop
exitwhen Tb[Gb[nC]]==Yb[nC]
set Gb[nC]=Tb[Gb[nC]]
set GC=1
set gC=fb[Gb[nC]]
set hC=uo[aC]
set FC=GetSpellTargetLoc()
set kC=0.
call GroupClear(bj_lastCreatedGroup)
loop
set GC=GC-1
exitwhen GC<0
call CreateUnitAtLocSaveLast(hC,gC,FC,kC)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
endloop
set Xb[Lb]="when calling close in CityManage, line 25"
set Lb=Lb+1
if hb[nC]then
call Gdw(nC,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
set jC=FS[qC]
set Xb[Lb]="when calling settleCity in CityManage, line 28"
set Lb=Lb+1
if pO[jC]==0 then
if jC==0 then
call x1("Nullpointer exception when calling City.settleCity","when calling error in City, line 215")
else
call x1("Called City.settleCity on invalid object.","when calling error in City, line 215")
endif
endif
call vtw(jC,aC,"when calling settleCity in City, line 215")
set Lb=Lb-1
call KillUnit(GetSpellAbilityUnit())
set Lb=Lb-1
set hC=null
set FC=null
endfunction
function Jxw takes nothing returns nothing
set Lb=0
call xC("CityManage, line 18")
endfunction
function K1 takes nothing returns boolean
return true
endfunction
function K9 takes nothing returns boolean
local integer H9
local integer J9
set ro=GetLocalPlayer()
set H9=0
set J9=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen H9>J9
set uo[H9]=Player(H9)
set H9=H9+1
endloop
return true
endfunction
function KH takes nothing returns nothing
local integer UH=1
local integer IH=1751868773
local player PH=GetOwningPlayer(GetTriggerUnit())
local rect JH=bj_mapInitialPlayableArea
local location HH=Location(GetRectCenterX(JH),GetRectCenterY(JH))
local location AH=Location(GetLocationX(HH)+100000000.00,GetLocationY(HH)+100000000.00)
local real DH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set UH=UH-1
exitwhen UH<0
call CreateUnitAtLocSaveLast(PH,IH,AH,DH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set PH=null
set AH=null
set HH=null
set JH=null
endfunction
function JL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990328 then
return false
endif
return true
endfunction
function KL takes nothing returns boolean
if not JL() then
return false
endif
return true
endfunction
function KP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989825,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989817,0)
endfunction
function JT takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989043 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function KT takes nothing returns boolean
if not JT() then
return false
endif
return true
endfunction
function JU takes nothing returns boolean
if GetResearched()!=1378890033 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890033,true)!=1 then
return false
endif
return true
endfunction
function KU takes nothing returns boolean
if not JU() then
return false
endif
return true
endfunction
function KW takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,We)
endfunction
function KY takes nothing returns nothing
local unit HY=GetSpellTargetUnit()
local unitstate JY=UNIT_STATE_MANA
call SetUnitState(HY,UNIT_STATE_MANA,RMaxBJ(0.,GetUnitState(GetSpellTargetUnit(),JY)-600.00))
set HY=null
set JY=null
endfunction
function KZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989582,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989583,0)
endfunction
function Kv takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988788,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988535,0)
endfunction
function Kww takes nothing returns boolean
return true
endfunction
function Icw takes integer Ecw,string Zcw returns nothing
local integer Ucw
set Xb[Lb]=Zcw
set Lb=Lb+1
set Ucw=ZS[ub[Ecw]]
if Ucw==Ecw then
set ZS[ub[Ecw]]=rb[Ecw]
elseif sb[Ecw]!=0 then
set rb[sb[Ecw]]=rb[Ecw]
endif
set sb[rb[Ecw]]=sb[Ecw]
set Ucw=US[ub[Ecw]]
if Ucw==Ecw then
set US[ub[Ecw]]=rb[Ecw]
elseif sb[Ecw]!=0 then
set rb[sb[Ecw]]=rb[Ecw]
endif
set sb[rb[Ecw]]=sb[Ecw]
set rb[Ecw]=0
set sb[Ecw]=0
set Xb[Lb]="when calling dealloc_EventListener in ClosureEvents, line 202"
set Lb=Lb+1
if SO[Ecw]==0 then
call x1("Double free: object of type EventListener","when calling error in ClosureEvents, line 98")
else
set sO[tO]=Ecw
set tO=tO+1
set SO[Ecw]=0
endif
set Lb=Lb-1-1
endfunction
function LV takes integer DV,string HV returns nothing
local integer JV
local integer KV
set Xb[Lb]=HV
set Lb=Lb+1
if DV>0 then
if US[DV]!=0 then
set JV=US[DV]
set US[DV]=0
loop
exitwhen JV==0
set KV=JV
set JV=rb[JV]
set HV="when calling dispatch_EventListener_destroyEventListener in ClosureEvents, line 282"
set Xb[Lb]="when calling dispatch_EventListener_destroyEventListener in ClosureEvents, line 282"
set Lb=Lb+1
if SO[KV]==0 then
if KV==0 then
call x1("Nullpointer exception when calling EventListener.EventListener","when calling error in ClosureEvents, line 98")
else
call x1("Called EventListener.EventListener on invalid object.","when calling error in ClosureEvents, line 98")
endif
endif
call Icw(KV,"when calling destroyEventListener in ClosureEvents, line 98")
set Lb=Lb-1
endloop
endif
endif
set Lb=Lb-1
endfunction
function wdw takes integer Vnw,integer Bnw,string Nnw returns boolean
local boolean Mnw
set Xb[Lb]=Nnw
set Lb=Lb+1
if AO[Vnw]==0 then
if Vnw==0 then
call x1("Nullpointer exception when calling HashMap.has","when calling error in HashMap, line 13")
else
call x1("Called HashMap.has on invalid object.","when calling error in HashMap, line 13")
endif
endif
set Xb[Lb]="when calling has in HashMap, line 13"
set Lb=Lb+1
set Xb[Lb]="when calling hasInt in HashMap, line 14"
set Lb=Lb+1
if AO[Vnw]==0 then
if Vnw==0 then
call x1("Nullpointer exception when calling Table.hasInt","when calling error in Table, line 9")
else
call x1("Called Table.hasInt on invalid object.","when calling error in Table, line 9")
endif
endif
set Mnw=HaveSavedInteger(Eo,Vnw,Bnw)
set Lb=Lb-1-1-1
return Mnw
endfunction
function LOw takes integer DOw,integer HOw,integer JOw,string KOw returns nothing
set Xb[Lb]=KOw
set Lb=Lb+1
if not wdw(DOw,HOw,"when calling has in HashMap, line 18") then
set qb[DOw]=qb[DOw]+1
endif
set Xb[Lb]="when calling saveInt in HashMap, line 20"
set Lb=Lb+1
if AO[DOw]==0 then
if DOw==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,DOw,HOw,JOw)
set Lb=Lb-1-1
endfunction
function GOw takes integer dOw,integer fOw,string ROw returns nothing
local hashtable TOw
local integer YOw
set Xb[Lb]=ROw
set Lb=Lb+1
set TOw=fc
set Xb[Lb]="when calling count in HashList, line 19"
set Lb=Lb+1
if ZO[dOw]==0 then
if dOw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set YOw=LoadInteger(fc,dOw,fOw)
set Lb=Lb-1
call SaveInteger(TOw,dOw,fOw,YOw+1)
set Lb=Lb-1
set TOw=null
endfunction
function Djw takes integer Ijw,integer Pjw,string Ajw returns nothing
set Xb[Lb]=Ajw
set Lb=Lb+1
call SaveInteger(dc,Ijw,eb[Ijw],Pjw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[Ijw]==0 then
if Ijw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(Ijw,Pjw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Ijw]=eb[Ijw]+1
set Lb=Lb-1
endfunction
function Ujw takes integer vjw,integer mjw,string Qjw returns nothing
local integer Wjw
local hashtable Ejw
local integer Zjw
set Xb[Lb]=Qjw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[vjw]==0 then
if vjw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Wjw=LoadInteger(fc,vjw,mjw)
set Lb=Lb-1
if Wjw<=0 then
set Ejw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[vjw]==0 then
if vjw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Zjw=eb[vjw]
set Lb=Lb-1
call SaveInteger(Ejw,vjw,mjw,Zjw)
call Djw(vjw,mjw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set Ejw=null
endfunction
function Ljw takes integer Hjw,integer Jjw,string Kjw returns nothing
set Xb[Lb]=Kjw
set Lb=Lb+1
if ZO[Hjw]==0 then
if Hjw==0 then
call x1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call x1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if ZO[Hjw]<=692 then
call Djw(Hjw,Jjw,"when calling add in HashList, line 25")
else
call Ujw(Hjw,Jjw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function Slw takes integer ulw,integer rlw,integer slw,string tlw returns nothing
local boolean ilw
set Xb[Lb]=tlw
set Lb=Lb+1
call LOw(ulw,rlw,slw,"when calling put in HashMap, line 60")
set Xb[Lb]="when calling hasKey in HashMap, line 61"
set Lb=Lb+1
if AO[ulw]==0 then
if ulw==0 then
call x1("Nullpointer exception when calling IterableMap.hasKey","when calling error in HashMap, line 87")
else
call x1("Called IterableMap.hasKey on invalid object.","when calling error in HashMap, line 87")
endif
endif
set Xb[Lb]="when calling hasKey in HashMap, line 87"
set Lb=Lb+1
set ilw=Cnw(ab[ulw],rlw,"when calling has in HashMap, line 88")
set Lb=Lb-1-1
if not ilw then
call Ljw(ab[ulw],rlw,"when calling add in HashMap, line 62")
endif
set Lb=Lb-1
endfunction
function idw takes integer udw,integer rdw,integer sdw,string tdw returns nothing
set Xb[Lb]=tdw
set Lb=Lb+1
if AO[udw]==0 then
if udw==0 then
call x1("Nullpointer exception when calling HashMap.put","when calling error in HashMap, line 17")
else
call x1("Called HashMap.put on invalid object.","when calling error in HashMap, line 17")
endif
endif
if AO[udw]<=729 then
call LOw(udw,rdw,sdw,"when calling put in HashMap, line 17")
else
call Slw(udw,rdw,sdw,"when calling put in HashMap, line 17")
endif
set Lb=Lb-1
endfunction
function Dcw takes integer Pcw,string Acw returns nothing
set Xb[Lb]=Acw
set Lb=Lb+1
if cb[Pcw]!=null then
if ldw(ES,GetHandleId(cb[Pcw]),"when calling get in ClosureEvents, line 60")==Pcw then
call idw(ES,GetHandleId(cb[Pcw]),tb[Pcw],"when calling put in ClosureEvents, line 62")
elseif ib[Pcw]!=0 then
set tb[ib[Pcw]]=tb[Pcw]
endif
elseif ldw(WS,Sb[Pcw],"when calling get in ClosureEvents, line 66")==Pcw then
call idw(WS,Sb[Pcw],tb[Pcw],"when calling put in ClosureEvents, line 68")
elseif ib[Pcw]!=0 then
set tb[ib[Pcw]]=tb[Pcw]
endif
set ib[tb[Pcw]]=ib[Pcw]
set tb[Pcw]=0
set ib[Pcw]=0
set Lb=Lb-1
endfunction
function Law takes integer Jaw,string Kaw returns nothing
set Xb[Lb]=Kaw
set Lb=Lb+1
if kO[Jaw]==0 then
if Jaw==0 then
call x1("Nullpointer exception when calling OnCastListener.OnCastListener","when calling error in ClosureEvents, line 50")
else
call x1("Called OnCastListener.OnCastListener on invalid object.","when calling error in ClosureEvents, line 50")
endif
endif
set Xb[Lb]="when calling destroyOnCastListener in ClosureEvents, line 50"
set Lb=Lb+1
call Dcw(Jaw,"when calling OnCastListener_onDestroy in ClosureEvents, line 58")
set Xb[Lb]="when calling dealloc_OnCastListener in ClosureEvents, line 58"
set Lb=Lb+1
if kO[Jaw]==0 then
call x1("Double free: object of type OnCastListener","when calling error in ClosureEvents, line 50")
else
set FO=FO+1
set kO[Jaw]=0
endif
set Lb=Lb-1-1-1
endfunction
function BOw takes integer XOw,integer COw,string VOw returns nothing
set Xb[Lb]=VOw
set Lb=Lb+1
if wdw(XOw,COw,"when calling has in HashMap, line 28") then
set qb[XOw]=qb[XOw]-1
endif
set Xb[Lb]="when calling removeInt in HashMap, line 30"
set Lb=Lb+1
if AO[XOw]==0 then
if XOw==0 then
call x1("Nullpointer exception when calling Table.removeInt","when calling error in Table, line 24")
else
call x1("Called Table.removeInt on invalid object.","when calling error in Table, line 24")
endif
endif
call RemoveSavedInteger(Eo,XOw,COw)
set Lb=Lb-1-1
endfunction
function xOw takes integer gOw,integer hOw,string FOw returns nothing
local hashtable kOw
local integer jOw
set Xb[Lb]=FOw
set Lb=Lb+1
set kOw=fc
set Xb[Lb]="when calling count in HashList, line 22"
set Lb=Lb+1
if ZO[gOw]==0 then
if gOw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set jOw=LoadInteger(fc,gOw,hOw)
set Lb=Lb-1
call SaveInteger(kOw,gOw,hOw,jOw-1)
set Lb=Lb-1
set kOw=null
endfunction
function UOw takes integer vOw,integer mOw,string QOw returns nothing
local integer WOw
local integer EOw
local integer ZOw
set Xb[Lb]=QOw
set Lb=Lb+1
set ZOw=LoadInteger(dc,vOw,mOw)
set Xb[Lb]="when calling decrOccurences in HashList, line 54"
set Lb=Lb+1
if ZO[vOw]==0 then
if vOw==0 then
call x1("Nullpointer exception when calling HashList.decrOccurences","when calling error in HashList, line 21")
else
call x1("Called HashList.decrOccurences on invalid object.","when calling error in HashList, line 21")
endif
endif
call xOw(vOw,ZOw,"when calling decrOccurences in HashList, line 21")
set Lb=Lb-1
set WOw=mOw
set EOw=eb[vOw]
loop
exitwhen WOw>EOw
call SaveInteger(dc,vOw,WOw,LoadInteger(dc,vOw,WOw+1))
set WOw=WOw+1
endloop
set eb[vOw]=eb[vOw]-1
set Lb=Lb-1
endfunction
function glw takes integer ylw,integer plw,string elw returns nothing
local integer qlw
local integer alw
local hashtable nlw
local integer dlw
local integer flw
local hashtable Rlw
local integer Tlw
local hashtable Ylw
local integer Glw
set Xb[Lb]=elw
set Lb=Lb+1
set nlw=Rc
set Xb[Lb]="when calling get in HashSet, line 22"
set Lb=Lb+1
if ZO[ylw]==0 then
if ylw==0 then
call x1("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call x1("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set dlw=LoadInteger(dc,ylw,plw)
set Lb=Lb-1
call RemoveSavedInteger(nlw,ylw,dlw)
set qlw=plw+1
set Xb[Lb]="when calling size in HashSet, line 23"
set Lb=Lb+1
if ZO[ylw]==0 then
if ylw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set flw=eb[ylw]
set Lb=Lb-1
set alw=flw
loop
exitwhen qlw>alw
set Rlw=Rc
set Xb[Lb]="when calling get in HashSet, line 24"
set Lb=Lb+1
if ZO[ylw]==0 then
if ylw==0 then
call x1("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call x1("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set Tlw=LoadInteger(dc,ylw,qlw)
set Lb=Lb-1
set Ylw=Rc
set elw="when calling get in HashSet, line 24"
set Xb[Lb]="when calling get in HashSet, line 24"
set Lb=Lb+1
if ZO[ylw]==0 then
if ylw==0 then
call x1("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call x1("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set Glw=LoadInteger(dc,ylw,qlw)
set Lb=Lb-1
call SaveInteger(Rlw,ylw,Tlw,LoadInteger(Ylw,ylw,Glw)-1)
set qlw=qlw+1
endloop
call UOw(ylw,plw,"when calling removeAt in HashSet, line 25")
set Lb=Lb-1
set nlw=null
set Rlw=null
set Ylw=null
endfunction
function Wnw takes integer vnw,integer mnw,string Qnw returns nothing
set Xb[Lb]=Qnw
set Lb=Lb+1
if ZO[vnw]==0 then
if vnw==0 then
call x1("Nullpointer exception when calling HashList.removeAt","when calling error in HashList, line 53")
else
call x1("Called HashList.removeAt on invalid object.","when calling error in HashList, line 53")
endif
endif
if ZO[vnw]<=692 then
call UOw(vnw,mnw,"when calling removeAt in HashList, line 53")
else
call glw(vnw,mnw,"when calling removeAt in HashList, line 53")
endif
set Lb=Lb-1
endfunction
function vlw takes integer hlw,integer Flw,string klw returns nothing
local integer jlw
local integer xlw
set Xb[Lb]=klw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 17"
set Lb=Lb+1
if ZO[hlw]==0 then
if hlw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set jlw=LoadInteger(fc,hlw,Flw)
set Lb=Lb-1
if jlw>0 then
set xlw=LoadInteger(Rc,hlw,Flw)
set Xb[Lb]="when calling removeAt in HashSet, line 18"
set Lb=Lb+1
if ZO[hlw]==0 then
if hlw==0 then
call x1("Nullpointer exception when calling HashSet.removeAt","when calling error in HashSet, line 21")
else
call x1("Called HashSet.removeAt on invalid object.","when calling error in HashSet, line 21")
endif
endif
call glw(hlw,xlw,"when calling removeAt in HashSet, line 21")
set Lb=Lb-1
endif
set Lb=Lb-1
endfunction
function Hnw takes integer Enw,integer Znw,string Unw returns nothing
local integer Inw
local integer Pnw
local integer Anw
local integer Dnw
set Xb[Lb]=Unw
set Lb=Lb+1
if ZO[Enw]==0 then
if Enw==0 then
call x1("Nullpointer exception when calling HashList.remove","when calling error in HashList, line 60")
else
call x1("Called HashList.remove on invalid object.","when calling error in HashList, line 60")
endif
endif
if ZO[Enw]<=692 then
set Inw=Enw
set Pnw=Znw
set Xb[Lb]="when calling remove in HashList, line 60"
set Lb=Lb+1
set Anw=0
set Dnw=eb[Enw]-1
loop
exitwhen Anw>Dnw
if Pnw==LoadInteger(dc,Inw,Anw) then
call Wnw(Inw,Anw,"when calling removeAt in HashList, line 63")
exitwhen true
endif
set Anw=Anw+1
endloop
set Lb=Lb-1
else
call vlw(Enw,Znw,"when calling remove in HashList, line 60")
endif
set Lb=Lb-1
endfunction
function blw takes integer clw,integer olw,string Olw returns nothing
local boolean llw
set Xb[Lb]=Olw
set Lb=Lb+1
call BOw(clw,olw,"when calling remove in HashMap, line 66")
set Xb[Lb]="when calling hasKey in HashMap, line 67"
set Lb=Lb+1
if AO[clw]==0 then
if clw==0 then
call x1("Nullpointer exception when calling IterableMap.hasKey","when calling error in HashMap, line 87")
else
call x1("Called IterableMap.hasKey on invalid object.","when calling error in HashMap, line 87")
endif
endif
set Xb[Lb]="when calling hasKey in HashMap, line 87"
set Lb=Lb+1
set llw=Cnw(ab[clw],olw,"when calling has in HashMap, line 88")
set Lb=Lb-1-1
if llw then
call Hnw(ab[clw],olw,"when calling remove in HashMap, line 68")
endif
set Lb=Lb-1
endfunction
function edw takes integer bdw,integer ydw,string pdw returns nothing
set Xb[Lb]=pdw
set Lb=Lb+1
if AO[bdw]==0 then
if bdw==0 then
call x1("Nullpointer exception when calling HashMap.remove","when calling error in HashMap, line 27")
else
call x1("Called HashMap.remove on invalid object.","when calling error in HashMap, line 27")
endif
endif
if AO[bdw]<=729 then
call BOw(bdw,ydw,"when calling remove in HashMap, line 27")
else
call blw(bdw,ydw,"when calling remove in HashMap, line 27")
endif
set Lb=Lb-1
endfunction
function AV takes unit WV,string EV returns nothing
local integer ZV
local integer UV
local integer IV
local integer PV
set Xb[Lb]=EV
set Lb=Lb+1
call LV(GetUnitUserData(WV),"when calling unregisterEvents in ClosureEvents, line 258")
if wdw(ES,GetHandleId(WV),"when calling has in ClosureEvents, line 259") then
set ZV=ldw(ES,GetHandleId(WV),"when calling get in ClosureEvents, line 260")
call edw(ES,GetHandleId(WV),"when calling remove in ClosureEvents, line 261")
loop
exitwhen ZV==0
set UV=ZV
set ZV=tb[ZV]
call Law(UV,"when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 265")
endloop
endif
if wdw(ES,GetHandleId(WV),"when calling has in ClosureEvents, line 266") then
set IV=ldw(ES,GetHandleId(WV),"when calling get in ClosureEvents, line 267")
loop
exitwhen IV==0
set PV=IV
set IV=tb[IV]
call Law(PV,"when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 271")
endloop
endif
set Lb=Lb-1
endfunction
function Kxw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 288"
set Lb=Lb+1
call AV(Ho[Jo-1],"when calling unregisterEventsForUnit in ClosureEvents, line 288")
set Lb=Lb-1
endfunction
function L1 takes nothing returns boolean
return true
endfunction
function L9 takes nothing returns boolean
return true
endfunction
function KE takes nothing returns boolean
if GetResearched()!=1378889806 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889806,true)!=2 then
return false
endif
return true
endfunction
function LE takes nothing returns boolean
if not KE() then
return false
endif
return true
endfunction
function LL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function LU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989828,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989827,0)
endfunction
function Lww takes nothing returns boolean
return true
endfunction
function Udw takes integer xdw,integer vdw,string mdw returns integer
local integer Qdw
local integer Wdw
local integer Edw
local integer Zdw
set Xb[Lb]=mdw
set Lb=Lb+1
if Sl[xdw]==0 then
if xdw==0 then
call x1("Nullpointer exception when calling LinkedList.get","when calling error in LinkedList, line 50")
else
call x1("Called LinkedList.get on invalid object.","when calling error in LinkedList, line 50")
endif
endif
set Xb[Lb]="when calling get in LinkedList, line 50"
set Lb=Lb+1
set Xb[Lb]="when calling getEntry in LinkedList, line 51"
set Lb=Lb+1
if Sl[xdw]==0 then
if xdw==0 then
call x1("Nullpointer exception when calling LinkedList.getEntry","when calling error in LinkedList, line 366")
else
call x1("Called LinkedList.getEntry on invalid object.","when calling error in LinkedList, line 366")
endif
endif
set Wdw=Fb[xdw]
set Edw=0
set Zdw=vdw
loop
exitwhen Edw>Zdw
set Wdw=Tb[Wdw]
set Edw=Edw+1
endloop
set Lb=Lb-1
set Qdw=fb[Wdw]
set Lb=Lb-1-1
return Qdw
endfunction
function Ybw takes string Rbw returns integer
local integer Tbw
set Xb[Lb]=Rbw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_LinkedList in LinkedList, line 31"
set Lb=Lb+1
if tl==0 then
if il<32768 then
set il=il+1
set Tbw=il
set Sl[Tbw]=703
else
call x1("Out of memory: Could not create LinkedList.","when calling error in LinkedList, line 17")
set Tbw=0
endif
else
set tl=tl-1
set Tbw=sl[tl]
set Sl[Tbw]=703
endif
set Lb=Lb-1
set Xb[Lb]="when calling construct_LinkedList2 in LinkedList, line 31"
set Lb=Lb+1
set Fb[Tbw]=ubw(0,0,0,"when calling new_LLEntry in LinkedList, line 18")
set kb[Tbw]=0
set Tb[Fb[Tbw]]=Fb[Tbw]
set Rb[Fb[Tbw]]=Fb[Tbw]
set Lb=Lb-1-1
return Tbw
endfunction
function Bbw takes integer Dbw,string Hbw returns nothing
local integer Jbw
local unit Kbw
local player Lbw
local real Xbw
local real Cbw
local real Vbw
set Xb[Lb]=Hbw
set Lb=Lb+1
if GetSpellAbilityId()==1093678154 then
set Jbw=Ybw("when calling new_LinkedList in MassControl, line 24")
set Kbw=GetSpellAbilityUnit()
set Lbw=GetOwningPlayer(Kbw)
set Cbw=GetSpellTargetX()
set Vbw=GetSpellTargetY()
set Xbw=Udw(Ec,GetLearnedSkillLevel(),"when calling get in MassControl, line 27")/1000.
set Xb[Lb]="when calling alloc_MassControl_ForGroupCallback_line27 in MassControl, line 27"
set Lb=Lb+1
if qO==0 then
if aO<32768 then
set aO=aO+1
set Dbw=aO
set nO[Dbw]=688
else
call x1("Out of memory: Could not create MassControl_ForGroupCallback_line27.","when calling error in MassControl, line 27")
set Dbw=0
endif
else
set qO=qO-1
set Dbw=eO[qO]
set nO[Dbw]=688
endif
set Lb=Lb-1
set jb[Dbw]=Lbw
set xb[Dbw]=Kbw
set vb[Dbw]=Jbw
call YB(Cbw,Vbw,Xbw,Dbw,"when calling forUnitsInRange in MassControl, line 27")
call idw(Wc,GetHandleId(Kbw),Jbw,"when calling put in MassControl, line 30")
endif
set Lb=Lb-1
set Kbw=null
set Lbw=null
endfunction
function Clw takes integer Alw,string Dlw returns nothing
local unit Hlw
local player Jlw
local player Klw
local player Llw
local timer Xlw
set Xb[Lb]=Dlw
set Lb=Lb+1
set Hlw=GetConstructingStructure()
if GetUnitTypeId(Hlw)==1747988808 then
if Tc[GetPlayerId(GetOwningPlayer(Hlw))]<3 then
set Jlw=GetOwningPlayer(Hlw)
set Klw=GetOwningPlayer(Hlw)
set Tc[GetPlayerId(Jlw)]=Tc[GetPlayerId(Klw)]+1
else
set Llw=GetOwningPlayer(Hlw)
set Xb[Lb]="when calling attentionToPlayer in LimitEncampments, line 18"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Llw,0.,0.,10.0,a5(Llw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Llw,0.,0.,10.0,"You cannot build more than 3 encampments.")
set Lb=Lb-1
set Xb[Lb]="when calling alloc_LimitEncampments_CallbackSingle_line19 in LimitEncampments, line 19"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set Alw=RO
set TO[Alw]=645
else
call x1("Out of memory: Could not create LimitEncampments_CallbackSingle_line19.","when calling error in LimitEncampments, line 19")
set Alw=0
endif
else
set fO=fO-1
set Alw=dO[fO]
set TO[Alw]=645
endif
set Lb=Lb-1
set nb[Alw]=Hlw
set Xb[Lb]="when calling doAfter in LimitEncampments, line 19"
set Lb=Lb+1
set Xlw=Sww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(Alw,Xlw,0.01,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1
endif
endif
set Lb=Lb-1
set Hlw=null
set Jlw=null
set Klw=null
set Llw=null
set Xlw=null
endfunction
function Gpw takes integer qpw,string apw returns nothing
local unit npw
local integer dpw
local boolean fpw
local player Rpw
local integer Tpw
local integer Ypw
set Xb[Lb]=apw
set Lb=Lb+1
set qpw=Ko
set dpw=GetUnitTypeId(GetTriggerUnit())
set Xb[Lb]="when calling has in OreCapture, line 15"
set Lb=Lb+1
if Sl[qpw]==0 then
if qpw==0 then
call x1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call x1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set fpw=ebw(qpw,dpw)
set Lb=Lb-1
if fpw then
set npw=GetTriggerUnit()
set Rpw=GetOwningPlayer(npw)
set Ypw=tc[GetPlayerId(GetOwningPlayer(npw))]
set Tpw=Lo
set tc[GetPlayerId(Rpw)]=Ypw+ldw(Tpw,GetUnitTypeId(npw),"when calling get in OreCapture, line 19")
endif
set Lb=Lb-1
set npw=null
set Rpw=null
endfunction
function sV takes integer uV,integer rV returns integer
if uV==1 then
if rV==0 then
return 1747988529
elseif rV==1 then
return 1747990326
elseif rV==2 then
return 1747990084
elseif rV==3 then
return 1747989590
else
return 1747988529
endif
elseif uV==2 then
if rV==0 then
return 1747988530
elseif rV==1 then
return 1747990327
elseif rV==2 then
return 1747990085
elseif rV==3 then
return 1747989591
else
return 1747988530
endif
elseif uV==3 then
if rV==0 then
return 1747988531
elseif rV==1 then
return 1747990328
elseif rV==2 then
return 1747990086
elseif rV==3 then
return 1747989592
else
return 1747988531
endif
elseif rV==0 then
return 1747988529
elseif rV==1 then
return 1747990326
elseif rV==2 then
return 1747990084
elseif rV==3 then
return 1747989590
else
return 1747988529
endif
endfunction
function wV takes integer MC returns integer
if MC==1747988529 then
return 1
elseif MC==1747988530 then
return 2
elseif MC==1747988531 then
return 3
elseif MC==1747990326 then
return 1
elseif MC==1747990327 then
return 2
elseif MC==1747990328 then
return 3
elseif MC==1747990084 then
return 1
elseif MC==1747990085 then
return 2
elseif MC==1747990086 then
return 3
elseif MC==1747989590 then
return 1
elseif MC==1747989591 then
return 2
elseif MC==1747989592 then
return 3
else
return 1
endif
endfunction
function Jtw takes integer mtw,player Qtw,string Wtw returns nothing
local integer Etw
local integer Ztw
local unit Utw
local unit Itw
local real Ptw
local integer Atw
local integer Dtw
local integer Htw
set Xb[Lb]=Wtw
set Lb=Lb+1
set Utw=xl[mtw]
call SetUnitState(Utw,UNIT_STATE_LIFE,GetUnitState(Utw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,60.0)*0.01)
set Itw=xl[mtw]
call SetUnitState(Itw,UNIT_STATE_MANA,GetUnitState(Itw,UNIT_STATE_MAX_MANA)*RMaxBJ(0.,30.0)*0.01)
set Xb[Lb]="when calling addModifier in City, line 234"
set Lb=Lb+1
if pO[mtw]==0 then
if mtw==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(mtw,0,"when calling addModifier in City, line 368")
set Lb=Lb-1
set Ptw=Gl[ldw(nS,6,"when calling get in City, line 235")]
if GetRandomReal(0.0,1.0)<=Ptw then
set Xb[Lb]="when calling addModifier in City, line 236"
set Lb=Lb+1
if pO[mtw]==0 then
if mtw==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(mtw,6,"when calling addModifier in City, line 368")
set Lb=Lb-1
endif
set Etw=Ql[mtw]
set Ztw=GetPlayerId(Qtw)
if Ztw>=0 and Ztw<24 then
set Atw=wo[Ztw]
set Xb[Lb]="when calling getForceId in City, line 242"
set Lb=Lb+1
if yl[Atw]==0 then
if Atw==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set Dtw=Ub[Atw]
set Lb=Lb-1
set Etw=Dtw
endif
if Cnw(Vo,GetUnitTypeId(xl[mtw]),"when calling has in City, line 244") then
set Htw=sV(wV(GetUnitTypeId(xl[mtw])),Etw)
set Xb[Lb]="when calling replaceCity in City, line 245"
set Lb=Lb+1
if pO[mtw]==0 then
if mtw==0 then
call x1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call x1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call ftw(mtw,Htw,"when calling replaceCity in City, line 194")
set Lb=Lb-1
endif
set Xb[Lb]="when calling changeOwner in City, line 247"
set Lb=Lb+1
if pO[mtw]==0 then
if mtw==0 then
call x1("Nullpointer exception when calling City.changeOwner","when calling error in City, line 199")
else
call x1("Called City.changeOwner on invalid object.","when calling error in City, line 199")
endif
endif
call htw(mtw,Ztw,"when calling changeOwner in City, line 199")
set Lb=Lb-1
call UnitAddAbility(xl[mtw],1093677634)
set Lb=Lb-1
set Utw=null
set Itw=null
endfunction
function NB takes playercolor IB returns integer
local playercolor HB=IB
local integer JB=0
local integer KB=0
local integer LB=bj_MAX_PLAYER_SLOTS-1
local integer PB
local integer AB
local integer DB
local playercolor XB
local integer CB
local integer VB
local integer BB
loop
exitwhen KB>LB
if oo[KB]==HB then
set JB=KB
exitwhen true
endif
set KB=KB+1
endloop
if JB<=23 then
set XB=IB
set CB=0
set VB=0
set BB=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen VB>BB
if oo[VB]==XB then
set CB=VB
exitwhen true
endif
set VB=VB+1
endloop
set PB=XS[CB]
set AB=CS[CB]
set DB=VS[CB]
else
set PB=0
set AB=0
set DB=0
endif
set Cb=PB
set Vb=AB
set Bb=DB
set HB=null
set XB=null
return Cb
endfunction
function UB takes player xB returns string
local integer WB=NB(GetPlayerColor(xB))
local integer EB=Vb
local integer ZB=Bb
local integer vB=WB/16
local integer mB=EB/16
local integer QB=ZB/16
return "|cff"+BS[vB]+BS[WB-vB*16]+BS[mB]+BS[EB-mB*16]+BS[QB]+BS[ZB-QB*16]+GetPlayerName(xB)+"|r"
endfunction
function h5 takes string n5,force d5,string f5 returns nothing
local integer R5
local integer T5
local player Y5
local player G5
local force g5
set Xb[Lb]=f5
set Lb=Lb+1
set R5=0
set T5=23
loop
exitwhen R5>T5
set G5=uo[R5]
set g5=CreateForce()
call ForceAddPlayer(g5,G5)
if g5==d5 then
set Y5=uo[R5]
call DisplayTimedTextToPlayer(Y5,0.,0.,10.0,a5(Y5,"when calling getAttentionStringForPlayer in Messages, line 116"))
call DisplayTimedTextToPlayer(Y5,0.,0.,10.0,n5)
endif
set R5=R5+1
endloop
set Lb=Lb-1
set Y5=null
set G5=null
set g5=null
endfunction
function Isw takes integer hsw,string Fsw returns nothing
local unit ksw
local boolean jsw
local unit xsw
local integer vsw
local player msw
local boolean Qsw
local real Wsw
local real Esw
local real Zsw
local real Usw
set Xb[Lb]=Fsw
set Lb=Lb+1
set ksw=GetTriggerUnit()
set Xb[Lb]="when calling isCity in CityManage, line 37"
set Lb=Lb+1
set Xb[Lb]="when calling isCity in UnitTools, line 5"
set Lb=Lb+1
set jsw=Cnw(No,GetUnitTypeId(ksw),"when calling has in City, line 437")
set Lb=Lb-1-1
if jsw then
if GetUnitStatePercent(ksw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=50.0 then
set Qsw=GetOwningPlayer(ksw)!=GetOwningPlayer(GetAttacker())
else
set Qsw=false
endif
if Qsw then
set Wsw=GetUnitX(ksw)
set Esw=GetUnitY(ksw)
set xsw=GetAttacker()
set Zsw=Wsw-GetUnitX(xsw)
set Usw=Esw-GetUnitY(xsw)
if SquareRoot(Zsw*Zsw+Usw*Usw)>300.0 then
call SetUnitState(ksw,UNIT_STATE_LIFE,GetUnitState(ksw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,50.0)*0.01)
else
set Xb[Lb]="when calling getCityId in CityManage, line 42"
set Lb=Lb+1
set hsw=lV(ksw,"when calling getCityId in UnitTools, line 9")
set Lb=Lb-1
if Cnw(Vo,GetUnitTypeId(ksw),"when calling has in CityManage, line 44") then
call h5(UB(GetOwningPlayer(GetAttacker()))+" has just captured "+UB(GetOwningPlayer(GetTriggerUnit()))+" Capitol!",bj_FORCE_ALL_PLAYERS,"when calling attentionToForce in CityManage, line 45")
endif
set vsw=FS[hsw]
set msw=GetOwningPlayer(GetAttacker())
set Xb[Lb]="when calling capture in CityManage, line 46"
set Lb=Lb+1
if pO[vsw]==0 then
if vsw==0 then
call x1("Nullpointer exception when calling City.capture","when calling error in City, line 230")
else
call x1("Called City.capture on invalid object.","when calling error in City, line 230")
endif
endif
call Jtw(vsw,msw,"when calling capture in City, line 230")
set Lb=Lb-1
endif
elseif GetUnitStatePercent(ksw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=50.0 then
call SetUnitState(ksw,UNIT_STATE_LIFE,GetUnitState(ksw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,50.0)*0.01)
endif
endif
set Lb=Lb-1
set ksw=null
set xsw=null
set msw=null
endfunction
function KSw takes integer ESw returns nothing
local unit ZSw=GetDyingUnit()
local real USw
local real ISw
local player PSw
local integer ASw
local real DSw
local unit HSw
local unitstate JSw
if ZSw==xl[Nl[ESw]]then
set PSw=uo[Wl[Nl[ESw]]]
set ASw=GetUnitTypeId(ZSw)
set xl[Nl[ESw]]=CreateUnitAtLoc(PSw,ASw,GetUnitLoc(ZSw),bj_UNIT_FACING)
set HSw=xl[Nl[ESw]]
set JSw=UNIT_STATE_LIFE
set DSw=GetUnitState(xl[Nl[ESw]],UNIT_STATE_MAX_LIFE)
set USw=yo
if 0.>USw then
set ISw=0.
else
set ISw=USw
endif
if 50.0>ISw then
set ISw=50.0
endif
call SetUnitState(HSw,JSw,DSw*ISw*0.01)
call SetUnitState(xl[Nl[ESw]],UNIT_STATE_MANA,GetUnitState(ZSw,UNIT_STATE_MANA))
endif
set ZSw=null
set PSw=null
set HSw=null
set JSw=null
endfunction
function Jww_2 takes integer Uww,string Iww returns rect
local integer Pww
local fogstate Aww
local integer Dww
local rect Hww_2
set Xb[Lb]=Iww
set Lb=Lb+1
set Pww=Po
set Aww=ConvertFogState(Uww)
set Xb[Lb]="when calling saveFogState in TypeCasting, line 136"
set Lb=Lb+1
if AO[Pww]==0 then
if Pww==0 then
call x1("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call x1("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call SaveFogStateHandle(Eo,Pww,0,Aww)
set Lb=Lb-1
set Dww=Po
set Xb[Lb]="when calling loadRect in TypeCasting, line 137"
set Lb=Lb+1
if AO[Dww]==0 then
if Dww==0 then
call x1("Nullpointer exception when calling Table.loadRect","when calling error in Table, line 147")
else
call x1("Called Table.loadRect on invalid object.","when calling error in Table, line 147")
endif
endif
set Hww_2=LoadRectHandle(Eo,Dww,0)
set Lb=Lb-1-1
set bR=Hww_2
set Aww=null
set Hww_2=null
return bR
endfunction
function h0w takes rect f0w,real R0w,real T0w returns boolean
local boolean Y0w
local boolean G0w
local boolean g0w
if R0w>GetRectMinX(f0w) then
set Y0w=R0w<GetRectMaxX(f0w)
else
set Y0w=false
endif
if Y0w then
set G0w=T0w>GetRectMinY(f0w)
else
set G0w=false
endif
if G0w then
set g0w=T0w<GetRectMaxY(f0w)
else
set g0w=false
endif
return g0w
endfunction
function Kyw takes integer Wyw,string Eyw returns nothing
local unit Zyw
local real Uyw
local real Iyw
local integer Pyw
local integer Ayw
local integer Dyw
local timer Hyw
local player Jyw
set Xb[Lb]=Eyw
set Lb=Lb+1
set Zyw=GetTriggerUnit()
if GetUnitTypeId(Zyw)==1747988569 then
set Uyw=GetUnitX(Zyw)
set Iyw=GetUnitY(Zyw)
set Ayw=wO
set Xb[Lb]="when calling iterator in NoShipsNearRivers, line 11"
set Lb=Lb+1
set Wyw=ibw(Ayw,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set Pyw=Wyw
loop
exitwhen Tb[Gb[Pyw]]==Yb[Pyw]
set Gb[Pyw]=Tb[Gb[Pyw]]
if h0w(Jww_2(fb[Gb[Pyw]],"when calling rectFromIndex in NoShipsNearRivers, line 11"),Uyw,Iyw) then
set Xb[Lb]="when calling alloc_NoShipsNearRivers_CallbackSingle_line14 in NoShipsNearRivers, line 14"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set Dyw=RO
set TO[Dyw]=648
else
call x1("Out of memory: Could not create NoShipsNearRivers_CallbackSingle_line14.","when calling error in NoShipsNearRivers, line 14")
set Dyw=0
endif
else
set fO=fO-1
set Dyw=dO[fO]
set TO[Dyw]=648
endif
set Lb=Lb-1
set Zb[Dyw]=Zyw
set Xb[Lb]="when calling doAfter in NoShipsNearRivers, line 14"
set Lb=Lb+1
set Hyw=Sww("when calling getTimer in ClosureTimers, line 27")
set Eyw="when calling doAfter in ClosureTimers, line 27"
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(Dyw,Hyw,0.01,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1
set Jyw=GetOwningPlayer(Zyw)
set Xb[Lb]="when calling attentionToPlayer in NoShipsNearRivers, line 16"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Jyw,0.,0.,10.0,a5(Jyw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Jyw,0.,0.,10.0,"You cannot build shipyards near rivers")
set Lb=Lb-1
endif
endloop
set Xb[Lb]="when calling close in NoShipsNearRivers, line 11"
set Lb=Lb+1
if hb[Pyw]then
call Gdw(Pyw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
endif
set Lb=Lb-1
set Zyw=null
set Hyw=null
set Jyw=null
endfunction
function Plw takes integer Elw returns nothing
local unit Zlw=GetDyingUnit()
local player Ulw
local player Ilw
if GetUnitTypeId(Zlw)==1747988808 then
set Ulw=GetOwningPlayer(Zlw)
set Ilw=GetOwningPlayer(Zlw)
set Tc[GetPlayerId(Ulw)]=Tc[GetPlayerId(Ilw)]-1
endif
set Zlw=null
set Ulw=null
set Ilw=null
endfunction
function t5 takes player M2,string w5 returns string
local integer u5
local integer r5
local integer s5
set Xb[Lb]=w5
set Lb=Lb+1
set r5=wo[GetPlayerId(M2)]
set Xb[Lb]="when calling getForceId in Messages, line 21"
set Lb=Lb+1
if yl[r5]==0 then
if r5==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set s5=Ub[r5]
set Lb=Lb-1
set u5=GetRandomInt(0,2)
if s5==0 then
set w5=To[u5]
elseif s5==1 then
set w5=Yo[u5]
elseif s5==2 then
set w5=Go[u5]
elseif s5==3 then
set w5=go[u5]
else
set w5="Note:"
endif
set Lb=Lb-1
return "|cff00ccff"+w5+"|r"
endfunction
function Vtw takes integer Ktw,integer Ltw,string Xtw returns nothing
local player Ctw
set Xb[Lb]=Xtw
set Lb=Lb+1
if kc-Kl[Ktw]>=fS then
set Kl[Ktw]=kc
set Dl[Ktw]=Dl[Ktw]-GS[Jl[Ktw]]
set Dl[Ktw]=Dl[Ktw]+GS[Ltw]
set Jl[Ktw]=Ltw
else
set Ctw=uo[Wl[Ktw]]
set Xb[Lb]="when calling noteToPlayer in City, line 271"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Ctw,0.,0.,10.0,t5(Ctw,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(Ctw,0.,0.,10.0,"Wait 1 turn to be able to change tax level.")
set Lb=Lb-1
endif
set Lb=Lb-1
set Ctw=null
endfunction
function Qqw takes integer Gqw,string gqw returns nothing
local integer hqw
local integer Fqw
local integer kqw
local boolean jqw
local unit xqw
local boolean vqw
local integer mqw
set Xb[Lb]=gqw
set Lb=Lb+1
set Fqw=sS
set kqw=GetSpellAbilityId()
set Xb[Lb]="when calling has in Taxation, line 7"
set Lb=Lb+1
if Sl[Fqw]==0 then
if Fqw==0 then
call x1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call x1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set jqw=ebw(Fqw,kqw)
set Lb=Lb-1
if jqw then
set xqw=GetSpellTargetUnit()
set Xb[Lb]="when calling isCity in Taxation, line 8"
set Lb=Lb+1
set vqw=Cnw(No,GetUnitTypeId(xqw),"when calling has in City, line 437")
set Lb=Lb-1
if vqw then
if GetOwningPlayer(GetSpellTargetUnit())==GetOwningPlayer(GetSpellAbilityUnit()) then
set hqw=0
set Gqw=GetSpellAbilityId()
if Gqw==1093677642 then
set hqw=1
elseif Gqw==1093677641 then
set hqw=0
elseif Gqw==1093677640 then
set hqw=2
elseif Gqw==1093678155 then
set hqw=3
endif
set mqw=FS[lV(GetSpellTargetUnit(),"when calling getCityId in Taxation, line 20")]
set Xb[Lb]="when calling changeTaxLevel in Taxation, line 20"
set Lb=Lb+1
if pO[mqw]==0 then
if mqw==0 then
call x1("Nullpointer exception when calling City.changeTaxLevel","when calling error in City, line 262")
else
call x1("Called City.changeTaxLevel on invalid object.","when calling error in City, line 262")
endif
endif
call Vtw(mqw,hqw,"when calling changeTaxLevel in City, line 262")
set Lb=Lb-1
endif
endif
endif
set Lb=Lb-1
set xqw=null
endfunction
function Zpw takes integer gpw,string hpw returns nothing
local unit Fpw
local integer kpw
local boolean jpw
local player xpw
local player vpw
local integer mpw
local integer Qpw
local integer Wpw
local integer Epw
set Xb[Lb]=hpw
set Lb=Lb+1
set Fpw=GetTriggerUnit()
set kpw=Ko
set gpw=GetUnitTypeId(Fpw)
set Xb[Lb]="when calling has in OreCapture, line 23"
set Lb=Lb+1
if Sl[kpw]==0 then
if kpw==0 then
call x1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call x1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set jpw=ebw(kpw,gpw)
set Lb=Lb-1
if jpw then
if GetUnitStatePercent(Fpw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=80.0 then
call SetUnitOwner(Fpw,GetOwningPlayer(GetAttacker()),true)
call SetUnitState(Fpw,UNIT_STATE_LIFE,GetUnitState(Fpw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.0)*0.01)
set xpw=GetOwningPlayer(Fpw)
set Qpw=tc[GetPlayerId(GetOwningPlayer(Fpw))]
set mpw=Lo
set tc[GetPlayerId(xpw)]=Qpw-ldw(mpw,GetUnitTypeId(Fpw),"when calling get in OreCapture, line 29")
set vpw=GetOwningPlayer(GetAttacker())
set Epw=tc[GetPlayerId(GetOwningPlayer(GetAttacker()))]
set Wpw=Lo
set tc[GetPlayerId(vpw)]=Epw+ldw(Wpw,GetUnitTypeId(Fpw),"when calling get in OreCapture, line 30")
endif
endif
set Lb=Lb-1
set Fpw=null
set xpw=null
set vpw=null
endfunction
function jww takes integer Yww,string Gww returns unit
local integer gww
local fogstate hww
local integer Fww_2
local unit kww
set Xb[Lb]=Gww
set Lb=Lb+1
set gww=Po
set hww=ConvertFogState(Yww)
set Xb[Lb]="when calling saveFogState in TypeCasting, line 52"
set Lb=Lb+1
if AO[gww]==0 then
if gww==0 then
call x1("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call x1("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call SaveFogStateHandle(Eo,gww,0,hww)
set Lb=Lb-1
set Fww_2=Po
set Xb[Lb]="when calling loadUnit in TypeCasting, line 53"
set Lb=Lb+1
if AO[Fww_2]==0 then
if Fww_2==0 then
call x1("Nullpointer exception when calling Table.loadUnit","when calling error in Table, line 75")
else
call x1("Called Table.loadUnit on invalid object.","when calling error in Table, line 75")
endif
endif
set kww=LoadUnitHandle(Eo,Fww_2,0)
set Lb=Lb-1-1
set OR=kww
set hww=null
set kww=null
return OR
endfunction
function ayw takes integer syw,string tyw returns nothing
local integer iyw
local integer Syw
local real cyw
local real oyw
local integer Oyw
local unit lyw
local integer byw
local integer yyw
local boolean pyw
local integer eyw
local timer qyw
set Xb[Lb]=tyw
set Lb=Lb+1
set byw=Zc
set yyw=GetUnitTypeId(GetOrderedUnit())
set Xb[Lb]="when calling has in MassControl, line 33"
set Lb=Lb+1
if Sl[byw]==0 then
if byw==0 then
call x1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call x1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set pyw=ebw(byw,yyw)
set Lb=Lb-1
if pyw then
if wdw(Wc,GetHandleId(GetOrderedUnit()),"when calling has in MassControl, line 34") then
set iyw=ldw(Wc,GetHandleId(GetOrderedUnit()),"when calling get in MassControl, line 35")
set Syw=GetIssuedOrderId()
set cyw=GetOrderPointX()
set oyw=GetOrderPointY()
set Xb[Lb]="when calling iterator in MassControl, line 38"
set Lb=Lb+1
set eyw=ibw(iyw,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set Oyw=eyw
loop
exitwhen Tb[Gb[Oyw]]==Yb[Oyw]
set Gb[Oyw]=Tb[Gb[Oyw]]
set lyw=jww(fb[Gb[Oyw]],"when calling unitFromIndex in MassControl, line 38")
set Xb[Lb]="when calling alloc_MassControl_CallbackSingle_line39 in MassControl, line 39"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set syw=RO
set TO[syw]=646
else
call x1("Out of memory: Could not create MassControl_CallbackSingle_line39.","when calling error in MassControl, line 39")
set syw=0
endif
else
set fO=fO-1
set syw=dO[fO]
set TO[syw]=646
endif
set Lb=Lb-1
set mb[syw]=lyw
set Qb[syw]=Syw
set Wb[syw]=cyw
set Eb[syw]=oyw
set Xb[Lb]="when calling doAfter in MassControl, line 39"
set Lb=Lb+1
set qyw=Sww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(syw,qyw,0.01,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1
endloop
set Xb[Lb]="when calling close in MassControl, line 38"
set Lb=Lb+1
if hb[Oyw]then
call Gdw(Oyw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
call edw(Wc,GetHandleId(GetOrderedUnit()),"when calling remove in MassControl, line 42")
endif
endif
set Lb=Lb-1
set lyw=null
set qyw=null
endfunction
function epw takes integer Opw,string lpw returns nothing
local unit bpw
local integer ypw
local boolean ppw
set Xb[Lb]=lpw
set Lb=Lb+1
set ypw=Ko
set Opw=GetUnitTypeId(GetDyingUnit())
set Xb[Lb]="when calling has in OreCapture, line 10"
set Lb=Lb+1
if Sl[ypw]==0 then
if ypw==0 then
call x1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call x1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set ppw=ebw(ypw,Opw)
set Lb=Lb-1
if ppw then
set bpw=GetTriggerUnit()
call CreateUnitAtLoc(GetOwningPlayer(bpw),GetUnitTypeId(bpw),GetUnitLoc(bpw),bj_UNIT_FACING)
endif
set Lb=Lb-1
set bpw=null
endfunction
function A2 takes real E2,real Z2,real U2,real I2,real P2 returns real
set U2=GetRandomReal(U2,I2)
return (E2+Z2)/2.+W2(U2)*Pow(2.718281828,-(Pow(U2,2.)/2.*P2))/SquareRoot(6.283185482*P2)*((Z2-E2)/2.)
endfunction
function gSw takes integer tSw,unit iSw,string SSw,integer cSw,integer oSw,string OSw returns nothing
local playerunitevent lSw
local real bSw
local real ySw
local unit pSw
local player eSw
local integer qSw
local integer aSw
local real nSw
local integer dSw
local timer fSw
local integer RSw
local timer TSw
local real YSw
local real GSw
set Xb[Lb]=OSw
set Lb=Lb+1
set Jl[tSw]=0
set Kl[tSw]=0.
set Ll[tSw]=Ybw("when calling new_LinkedList in City, line 104")
set Hl[tSw]=1.0
set xl[tSw]=iSw
set pSw=xl[tSw]
set YSw=GetUnitX(pSw)
set GSw=GetUnitY(pSw)
set El[tSw]=YSw
set Zl[tSw]=GSw
set vl[tSw]=SSw
set Ql[tSw]=cSw
set eSw=GetOwningPlayer(xl[tSw])
set Wl[tSw]=GetPlayerId(eSw)
set vl[tSw]=SubString(SSw,0,24)
set ml[tSw]=dS
set dS=dS+1
set lSw=EVENT_PLAYER_UNIT_DEATH
set Xb[Lb]="when calling alloc_City_City_EventListener_line121 in City, line 121"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set qSw=iO
set SO[qSw]=665
else
call x1("Out of memory: Could not create City_City_EventListener_line121.","when calling error in City, line 121")
set qSw=0
endif
else
set tO=tO-1
set qSw=sO[tO]
set SO[qSw]=665
endif
set Lb=Lb-1
set ub[qSw]=0
set rb[qSw]=0
set sb[qSw]=0
set Nl[qSw]=tSw
set Xb[Lb]="when calling add in City, line 121"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set aSw=mS[GetHandleId(lSw)]
if aSw==0 then
set aSw=QV(lSw,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[qSw]=aSw
if ZS[ub[qSw]]!=0 then
set sb[ZS[ub[qSw]]]=qSw
set rb[qSw]=ZS[ub[qSw]]
endif
set ZS[ub[qSw]]=qSw
set Lb=Lb-1
set Pl[tSw]=A2(RS[0],RS[1],-5.0,5.0,0.15)
set nSw=A2(Udw(TS[oSw],0,"when calling get in City, line 133")*1.,Udw(TS[oSw],1,"when calling get in City, line 133")*1.,-5.0,5.0,0.15)
set Ul[tSw]=R2I(nSw)
set Dl[tSw]=0.
set bSw=2.5+GetRandomReal(2.5,5.0)
set Xb[Lb]="when calling alloc_City_City_CallbackPeriodic_line138 in City, line 138"
set Lb=Lb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set dSw=gO
set hO[dSw]=631
else
call x1("Out of memory: Could not create City_City_CallbackPeriodic_line138.","when calling error in City, line 138")
set dSw=0
endif
else
set GO=GO-1
set dSw=YO[GO]
set hO[dSw]=631
endif
set Lb=Lb-1
set Ml[dSw]=tSw
set Xb[Lb]="when calling doPeriodically in City, line 138"
set Lb=Lb+1
set fSw=Sww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call enw(dSw,fSw,bSw,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1
set ySw=60+GetRandomReal(60,120.0)
set Xb[Lb]="when calling alloc_City_City_CallbackPeriodic_line154 in City, line 154"
set Lb=Lb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set RSw=gO
set hO[RSw]=632
else
call x1("Out of memory: Could not create City_City_CallbackPeriodic_line154.","when calling error in City, line 154")
set RSw=0
endif
else
set GO=GO-1
set RSw=YO[GO]
set hO[RSw]=632
endif
set Lb=Lb-1
set wb[RSw]=tSw
set Xb[Lb]="when calling doPeriodically in City, line 154"
set Lb=Lb+1
set TSw=Sww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call enw(RSw,TSw,ySw,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set lSw=null
set pSw=null
set eSw=null
set fSw=null
set TSw=null
endfunction
function sSw takes unit Biw,string Niw,integer Miw,integer wSw,string uSw returns integer
local integer rSw
set Xb[Lb]=uSw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_City in City, line 101"
set Lb=Lb+1
if bO==0 then
if yO<32768 then
set yO=yO+1
set rSw=yO
set pO[rSw]=652
else
call x1("Out of memory: Could not create City.","when calling error in City, line 71")
set rSw=0
endif
else
set bO=bO-1
set rSw=lO[bO]
set pO[rSw]=652
endif
set Lb=Lb-1
call gSw(rSw,Biw,Niw,Miw,wSw,"when calling construct_City in City, line 101")
set Lb=Lb-1
return rSw
endfunction
function fsw takes integer psw,string esw returns nothing
local unit qsw
local boolean asw
local integer nsw
local unit dsw
set Xb[Lb]=esw
set Lb=Lb+1
set qsw=GetConstructedStructure()
set Xb[Lb]="when calling isCity in CityBuilded, line 10"
set Lb=Lb+1
set Xb[Lb]="when calling isCity in UnitTools, line 5"
set Lb=Lb+1
set asw=Cnw(No,GetUnitTypeId(qsw),"when calling has in City, line 437")
set Lb=Lb-1-1
if asw then
set dsw=GetConstructedStructure()
set nsw=wo[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))]
set Xb[Lb]="when calling getForceId in CityBuilded, line 11"
set Lb=Lb+1
if yl[nsw]==0 then
if nsw==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set psw=Ub[nsw]
set Lb=Lb-1
set FS[dS]=sSw(dsw,"New",psw,1,"when calling new_City in CityBuilded, line 11")
endif
set Lb=Lb-1
set qsw=null
set dsw=null
endfunction
function Ldw takes integer Hdw,integer Jdw,string Kdw returns nothing
set Xb[Lb]=Kdw
set Lb=Lb+1
if yl[Hdw]==0 then
if Hdw==0 then
call x1("Nullpointer exception when calling PlayerStats.setSelectedCityId","when calling error in PlayerStats, line 116")
else
call x1("Called PlayerStats.setSelectedCityId on invalid object.","when calling error in PlayerStats, line 116")
endif
endif
set Xb[Lb]="when calling setSelectedCityId in PlayerStats, line 116"
set Lb=Lb+1
if Jdw>=0 and Jdw<dS then
set Ab[Hdw]=Jdw
set Xb[Lb]="when calling refreshMultiboardCity in PlayerStats, line 119"
set Lb=Lb+1
if yl[Hdw]==0 then
if Hdw==0 then
call x1("Nullpointer exception when calling PlayerStats.refreshMultiboardCity","when calling error in PlayerStats, line 71")
else
call x1("Called PlayerStats.refreshMultiboardCity on invalid object.","when calling error in PlayerStats, line 71")
endif
endif
call yew(Hdw,"when calling refreshMultiboardCity in PlayerStats, line 71")
set Lb=Lb-1
endif
set Lb=Lb-1-1
endfunction
function gsw takes integer Rsw,string Tsw returns nothing
local unit Ysw
local boolean Gsw
set Xb[Lb]=Tsw
set Lb=Lb+1
set Ysw=GetTriggerUnit()
set Xb[Lb]="when calling isCity in CityManage, line 10"
set Lb=Lb+1
set Xb[Lb]="when calling isCity in UnitTools, line 5"
set Lb=Lb+1
set Gsw=Cnw(No,GetUnitTypeId(Ysw),"when calling has in City, line 437")
set Lb=Lb-1-1
if Gsw then
call Ldw(wo[GetPlayerId(GetTriggerPlayer())],lV(GetTriggerUnit(),"when calling getCityId in CityManage, line 11"),"when calling setSelectedCityId in CityManage, line 11")
endif
set Lb=Lb-1
set Ysw=null
endfunction
function ipw takes integer rpw,string spw returns nothing
local force tpw
set Xb[Lb]=spw
set Lb=Lb+1
set spw=UB(GetTriggerPlayer())+" has left the game!"
set tpw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),tpw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,5.0,spw)
endif
set rpw=wo[GetPlayerId(GetTriggerPlayer())]
set Xb[Lb]="when calling setInGame in OnPlayerLeave, line 7"
set Lb=Lb+1
if yl[rpw]==0 then
if rpw==0 then
call x1("Nullpointer exception when calling PlayerStats.setInGame","when calling error in PlayerStats, line 45")
else
call x1("Called PlayerStats.setInGame on invalid object.","when calling error in PlayerStats, line 45")
endif
endif
set Pb[rpw]=false
set Lb=Lb-1
call SetPlayerName(GetTriggerPlayer(),GetPlayerName(GetTriggerPlayer())+" [LEFT]")
set Lb=Lb-1
set tpw=null
endfunction
function nOw takes integer lOw,string bOw returns nothing
local unit yOw
local boolean pOw
local player eOw
local boolean qOw
local boolean aOw
set Xb[Lb]=bOw
set Lb=Lb+1
set yOw=GetTriggerUnit()
set Xb[Lb]="when calling isCity in Garissons, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling isCity in UnitTools, line 5"
set Lb=Lb+1
set pOw=Cnw(No,GetUnitTypeId(yOw),"when calling has in City, line 437")
set Lb=Lb-1-1
if pOw then
set qOw=true
else
set qOw=Cnw(Bo,GetUnitTypeId(yOw),"when calling has in Garissons, line 9")
endif
if qOw then
set eOw=GetOwningPlayer(yOw)
if GetPlayerSlotState(eOw)==PLAYER_SLOT_STATE_PLAYING then
set aOw=GetPlayerController(eOw)==MAP_CONTROL_USER
else
set aOw=false
endif
if not aOw then
call IssueImmediateOrder(yOw,"spiritwolf")
endif
endif
set Lb=Lb-1
set yOw=null
set eOw=null
endfunction
function taw takes integer Jqw,string Kqw returns nothing
local unit Lqw
local unit Xqw
local integer Cqw
local integer Vqw
local player Bqw
local integer Nqw
local integer Mqw
local player waw
local integer uaw
local boolean raw
local boolean saw
set Xb[Lb]=Kqw
set Lb=Lb+1
if GetSpellAbilityId()==1093677620 then
set Lqw=GetSpellAbilityUnit()
set Xqw=GetSpellTargetUnit()
set Cqw=GetPlayerId(GetOwningPlayer(Lqw))
set Vqw=GetPlayerId(GetOwningPlayer(Xqw))
set Bqw=uo[Cqw]
if GetPlayerSlotState(Bqw)==PLAYER_SLOT_STATE_PLAYING then
set raw=GetPlayerController(Bqw)==MAP_CONTROL_USER
else
set raw=false
endif
if raw then
set Nqw=wo[Cqw]
set Mqw=-GetUnitLevel(Xqw)
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 15"
set Lb=Lb+1
if yl[Nqw]==0 then
if Nqw==0 then
call x1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call x1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[Nqw]=Db[Nqw]+Mqw
set Lb=Lb-1
endif
set waw=uo[Vqw]
if GetPlayerSlotState(waw)==PLAYER_SLOT_STATE_PLAYING then
set saw=GetPlayerController(waw)==MAP_CONTROL_USER
else
set saw=false
endif
if saw then
set Jqw=wo[Vqw]
set uaw=GetUnitLevel(Xqw)
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 17"
set Lb=Lb+1
if yl[Jqw]==0 then
if Jqw==0 then
call x1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call x1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[Jqw]=Db[Jqw]+uaw
set Lb=Lb-1
endif
endif
set Lb=Lb-1
set Lqw=null
set Xqw=null
set Bqw=null
set waw=null
endfunction
function upw takes integer Lyw,string Xyw returns nothing
local unit Cyw
local integer Vyw
local integer Byw
local integer Nyw
local boolean Myw
local boolean wpw
set Xb[Lb]=Xyw
set Lb=Lb+1
set Cyw=GetOrderedUnit()
if GetIssuedOrderId()==852056 then
set Myw=GetUnitAbilityLevel(Cyw,1093677904)>0
else
set Myw=false
endif
if Myw then
call UnitRemoveAbility(Cyw,1093677904)
set Vyw=Cc
set Byw=GetHandleId(Cyw)
set Xb[Lb]="when calling add in NoStarvationOnBoat, line 14"
set Lb=Lb+1
if ZO[Vyw]==0 then
if Vyw==0 then
call x1("Nullpointer exception when calling HashSet.add","when calling error in HashSet, line 9")
else
call x1("Called HashSet.add on invalid object.","when calling error in HashSet, line 9")
endif
endif
call Ujw(Vyw,Byw,"when calling add in HashSet, line 9")
set Lb=Lb-1
endif
if GetIssuedOrderId()==851972 then
set wpw=Cnw(Cc,GetHandleId(Cyw),"when calling has in NoStarvationOnBoat, line 16")
else
set wpw=false
endif
if wpw then
call UnitAddAbility(GetOrderedUnit(),1093677904)
set Nyw=Cc
set Lyw=GetHandleId(Cyw)
set Xb[Lb]="when calling remove in NoStarvationOnBoat, line 18"
set Lb=Lb+1
if ZO[Nyw]==0 then
if Nyw==0 then
call x1("Nullpointer exception when calling HashSet.remove","when calling error in HashSet, line 16")
else
call x1("Called HashSet.remove on invalid object.","when calling error in HashSet, line 16")
endif
endif
call vlw(Nyw,Lyw,"when calling remove in HashSet, line 16")
set Lb=Lb-1
endif
set Lb=Lb-1
set Cyw=null
endfunction
function xcw takes integer Gcw,string gcw returns nothing
local integer hcw
local integer Fcw
local integer kcw
local player jcw
set Xb[Lb]=gcw
set Lb=Lb+1
if GetSpellAbilityId()==1093677620 then
if GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))<24 then
set Gcw=wo[GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))]
set Xb[Lb]="when calling getForceId in Clerics, line 10"
set Lb=Lb+1
if yl[Gcw]==0 then
if Gcw==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set hcw=Ub[Gcw]
set Lb=Lb-1
set Fcw=wo[GetPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]
set Xb[Lb]="when calling getForceId in Clerics, line 10"
set Lb=Lb+1
if yl[Fcw]==0 then
if Fcw==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set kcw=Ub[Fcw]
set Lb=Lb-1
if hcw==kcw then
call IssueImmediateOrderById(GetSpellAbilityUnit(),851972)
set jcw=GetOwningPlayer(GetSpellAbilityUnit())
set Xb[Lb]="when calling noteToPlayer in Clerics, line 12"
set Lb=Lb+1
call DisplayTimedTextToPlayer(jcw,0.,0.,10.0,t5(jcw,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(jcw,0.,0.,10.0,"Clerics cannot convert someone who professes same religion as you.")
set Lb=Lb-1
endif
endif
endif
set Lb=Lb-1
set jcw=null
endfunction
function yaw takes integer iaw,string Saw returns nothing
local unit caw
local integer oaw
local player Oaw
local integer law
local boolean baw
set Xb[Lb]=Saw
set Lb=Lb+1
set caw=GetDyingUnit()
set oaw=GetPlayerId(GetOwningPlayer(caw))
set Oaw=uo[oaw]
if GetPlayerSlotState(Oaw)==PLAYER_SLOT_STATE_PLAYING then
set baw=GetPlayerController(Oaw)==MAP_CONTROL_USER
else
set baw=false
endif
if baw and(not IsUnitType(caw,UNIT_TYPE_STRUCTURE)) then
set law=wo[oaw]
set iaw=GetUnitLevel(caw)
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 32"
set Lb=Lb+1
if yl[law]==0 then
if law==0 then
call x1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call x1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[law]=Db[law]+iaw
set Lb=Lb-1
endif
set Lb=Lb-1
set caw=null
set Oaw=null
endfunction
function luw takes unit tuw,unit iuw returns real
local real Suw=GetUnitX(tuw)
local real cuw=GetUnitY(tuw)
local real ouw=Suw-GetUnitX(iuw)
local real Ouw=cuw-GetUnitY(iuw)
return SquareRoot(ouw*ouw+Ouw*Ouw)
endfunction
function yqw takes integer Mew,string wqw returns nothing
local unit uqw
local player rqw
local group sqw
local location tqw
local group iqw
local unit Sqw
local integer cqw
local timer oqw
local boolean Oqw
local boolean lqw
local boolean bqw
set Xb[Lb]=wqw
set Lb=Lb+1
set uqw=GetTriggerUnit()
set Mew=GetUnitTypeId(uqw)
if Cnw(bo,Mew,"when calling has in RangeChecks, line 15") then
set rqw=GetOwningPlayer(uqw)
set tqw=GetUnitLoc(uqw)
set iqw=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(iqw,tqw,2000.0,null)
call DestroyBoolExpr(null)
set nc=CreateGroup()
call ForGroup(iqw,Pf)
set sqw=nc
loop
exitwhen FirstOfGroup(sqw)==null
set Sqw=FirstOfGroup(sqw)
call GroupRemoveUnit(sqw,Sqw)
if GetOwningPlayer(Sqw)==rqw and Sqw!=uqw then
if GetUnitTypeId(Sqw)==Mew and luw(Sqw,uqw)<=1500 then
set lqw=true
else
if Cnw(Bo,Mew,"when calling has in RangeChecks, line 21") then
set Oqw=Cnw(Bo,GetUnitTypeId(Sqw),"when calling has in RangeChecks, line 21")
else
set Oqw=false
endif
set lqw=Oqw
endif
set bqw=lqw
else
set bqw=false
endif
if bqw then
set Xb[Lb]="when calling alloc_RangeChecks_CallbackSingle_line23 in RangeChecks, line 23"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set cqw=RO
set TO[cqw]=651
else
call x1("Out of memory: Could not create RangeChecks_CallbackSingle_line23.","when calling error in RangeChecks, line 23")
set cqw=0
endif
else
set fO=fO-1
set cqw=dO[fO]
set TO[cqw]=651
endif
set Lb=Lb-1
set Jb[cqw]=uqw
set Xb[Lb]="when calling doAfter in RangeChecks, line 23"
set Lb=Lb+1
set oqw=Sww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(cqw,oqw,0.01,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1
if Mew==1747988557 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 27"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build settlements too close to each other.")
set Lb=Lb-1
elseif Mew==1747989041 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 29"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build settlements too close to each other.")
set Lb=Lb-1
elseif Mew==1747990344 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 31"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build settlements too close to each other.")
set Lb=Lb-1
elseif Mew==1747989075 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 33"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build churches too close to each other.")
set Lb=Lb-1
elseif Mew==1747990102 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 35"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build churches too close to each other.")
set Lb=Lb-1
elseif Mew==1747988785 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 37"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build churches too close to each other.")
set Lb=Lb-1
elseif Mew==1747989839 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 39"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build mosques too close to each other.")
set Lb=Lb-1
elseif Mew==1747989059 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 41"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build castles too close to each other.")
set Lb=Lb-1
elseif Mew==1747989331 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 43"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build castles too close to each other.")
set Lb=Lb-1
elseif Mew==1747990351 then
set wqw="You cannot build castles too close to each other."
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 45"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build castles too close to each other.")
set Lb=Lb-1
elseif Mew==1747990353 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 47"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build castles too close to each other.")
set Lb=Lb-1
elseif Mew==1747988568 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 49"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build inns too close to each other.")
set Lb=Lb-1
elseif Mew==1747990341 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 51"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build inns too close to each other.")
set Lb=Lb-1
else
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 54"
set Lb=Lb+1
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,a5(rqw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(rqw,0.,0.,10.0,"You cannot build inns too close to each other.")
set Lb=Lb-1
endif
exitwhen true
endif
endloop
call GroupClear(sqw)
call DestroyGroup(sqw)
endif
set Lb=Lb-1
set uqw=null
set rqw=null
set sqw=null
set tqw=null
set iqw=null
set Sqw=null
set oqw=null
endfunction
function CC takes integer XC returns integer
if XC==1747989059 then
return 1
elseif XC==1747989060 then
return 2
elseif XC==1747988844 then
return 3
elseif XC==1747990351 then
return 1
elseif XC==1747990352 then
return 2
elseif XC==1747990356 then
return 3
elseif XC==1747989331 then
return 1
elseif XC==1747990350 then
return 2
elseif XC==1747989809 then
return 3
elseif XC==1747990353 then
return 1
elseif XC==1747990354 then
return 2
elseif XC==1747990355 then
return 3
else
return 1
endif
endfunction
function NC takes integer VC,integer BC returns integer
if VC==1 then
if BC==0 then
return 1747989059
elseif BC==1 then
return 1747990351
elseif BC==2 then
return 1747989331
elseif BC==3 then
return 1747990353
else
return 1747989059
endif
elseif VC==2 then
if BC==0 then
return 1747989060
elseif BC==1 then
return 1747990352
elseif BC==2 then
return 1747990350
elseif BC==3 then
return 1747990354
else
return 1747989060
endif
elseif VC==3 then
if BC==0 then
return 1747988844
elseif BC==1 then
return 1747990356
elseif BC==2 then
return 1747989809
elseif BC==3 then
return 1747990355
else
return 1747988844
endif
elseif BC==0 then
return 1747989059
elseif BC==1 then
return 1747990351
elseif BC==2 then
return 1747989331
elseif BC==3 then
return 1747990353
else
return 1747989059
endif
endfunction
function ysw takes integer Mrw,string wsw returns nothing
local unit usw
local player rsw
local unit ssw
local integer tsw
local boolean isw
local real Ssw
local boolean csw
local integer osw
local real Osw
local real lsw
local real bsw
set Xb[Lb]=wsw
set Lb=Lb+1
set usw=GetTriggerUnit()
if Cnw(Bo,GetUnitTypeId(usw),"when calling has in CastleCapture, line 11") then
if GetUnitStatePercent(usw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=50.0 then
set isw=GetOwningPlayer(usw)!=GetOwningPlayer(GetAttacker())
else
set isw=false
endif
if isw then
set Ssw=GetUnitX(usw)
set Osw=GetUnitY(usw)
set ssw=GetAttacker()
set lsw=Ssw-GetUnitX(ssw)
set bsw=Osw-GetUnitY(ssw)
set csw=SquareRoot(lsw*lsw+bsw*bsw)<=300.0
else
set csw=false
endif
if csw then
set rsw=GetOwningPlayer(GetAttacker())
call SetUnitOwner(usw,rsw,true)
if GetPlayerId(rsw)!=PLAYER_NEUTRAL_AGGRESSIVE then
set osw=CC(GetUnitTypeId(usw))
set tsw=wo[GetPlayerId(rsw)]
set Xb[Lb]="when calling getForceId in CastleCapture, line 17"
set Lb=Lb+1
if yl[tsw]==0 then
if tsw==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set Mrw=Ub[tsw]
set Lb=Lb-1
set usw=ReplaceUnitBJ(usw,NC(osw,Mrw),bj_UNIT_STATE_METHOD_RELATIVE)
endif
call SetUnitState(usw,UNIT_STATE_LIFE,GetUnitState(usw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,60.0)*0.01)
call SetUnitState(usw,UNIT_STATE_MANA,GetUnitState(usw,UNIT_STATE_MAX_MANA)*RMaxBJ(0.,0.0)*0.01)
call UnitAddAbility(usw,1093677896)
endif
endif
set Lb=Lb-1
set usw=null
set rsw=null
set ssw=null
endfunction
function Haw takes integer Aaw,string Daw returns nothing
set Xb[Lb]=Daw
set Lb=Lb+1
if SO[Aaw]==0 then
if Aaw==0 then
call x1("Nullpointer exception when calling EventListener.onEvent","when calling error in ClosureEvents, line 109")
else
call x1("Called EventListener.onEvent on invalid object.","when calling error in ClosureEvents, line 109")
endif
endif
if SO[Aaw]<=671 then
if SO[Aaw]<=666 then
if SO[Aaw]<=663 then
if SO[Aaw]<=662 then
if SO[Aaw]<=661 then
call ysw(Aaw,"when calling CastleCapture_onEvent_line8 in ClosureEvents, line 109")
else
call fsw(Aaw,"when calling CityBuilded_onEvent_line9 in ClosureEvents, line 109")
endif
else
call Isw(Aaw,"when calling CityManage_onEvent_line34 in ClosureEvents, line 109")
endif
elseif SO[Aaw]<=665 then
if SO[Aaw]<=664 then
call gsw(Aaw,"when calling CityManage_onEvent_line9 in ClosureEvents, line 109")
else
call KSw(Aaw)
endif
else
call xcw(Aaw,"when calling Clerics_onEvent_line5 in ClosureEvents, line 109")
endif
elseif SO[Aaw]<=669 then
if SO[Aaw]<=668 then
if SO[Aaw]<=667 then
call nOw(Aaw,"when calling Garissons_onEvent_line7 in ClosureEvents, line 109")
else
call Clw(Aaw,"when calling LimitEncampments_onEvent_line12 in ClosureEvents, line 109")
endif
else
call Plw(Aaw)
endif
elseif SO[Aaw]<=670 then
call Bbw(Aaw,"when calling MassControl_onEvent_line22 in ClosureEvents, line 109")
else
call ayw(Aaw,"when calling MassControl_onEvent_line32 in ClosureEvents, line 109")
endif
elseif SO[Aaw]<=676 then
if SO[Aaw]<=674 then
if SO[Aaw]<=673 then
if SO[Aaw]<=672 then
call Kyw(Aaw,"when calling NoShipsNearRivers_onEvent_line7 in ClosureEvents, line 109")
else
call upw(Aaw,"when calling NoStarvationOnBoat_onEvent_line9 in ClosureEvents, line 109")
endif
else
call ipw(Aaw,"when calling OnPlayerLeave_onEvent_line5 in ClosureEvents, line 109")
endif
elseif SO[Aaw]<=675 then
call Gpw(Aaw,"when calling OreCapture_onEvent_line14 in ClosureEvents, line 109")
else
call Zpw(Aaw,"when calling OreCapture_onEvent_line21 in ClosureEvents, line 109")
endif
elseif SO[Aaw]<=679 then
if SO[Aaw]<=678 then
if SO[Aaw]<=677 then
call epw(Aaw,"when calling OreCapture_onEvent_line9 in ClosureEvents, line 109")
else
call yqw(Aaw,"when calling RangeChecks_onEvent_line12 in ClosureEvents, line 109")
endif
else
call Qqw(Aaw,"when calling Taxation_onEvent_line6 in ClosureEvents, line 109")
endif
elseif SO[Aaw]<=680 then
call yaw(Aaw,"when calling Upkeep_onEvent_line28 in ClosureEvents, line 109")
else
call taw(Aaw,"when calling Upkeep_onEvent_line6 in ClosureEvents, line 109")
endif
set Lb=Lb-1
endfunction
function sB takes string CV returns nothing
local unit VV
local integer BV
local integer NV
local integer MV
local eventid wB
local integer uB
local boolean rB
set Xb[Lb]=CV
set Lb=Lb+1
set VV=GetTriggerUnit()
set wB=GetTriggerEventId()
set Xb[Lb]="when calling toIntId in ClosureEvents, line 170"
set Lb=Lb+1
set uB=mS[GetHandleId(wB)]
if uB==0 then
set uB=QV(wB,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set BV=uB
if VV!=null then
set rB=GetUnitUserData(VV)>0
else
set rB=false
endif
if rB then
if US[GetUnitUserData(VV)]!=0 then
set NV=US[GetUnitUserData(VV)]
loop
exitwhen NV==0
if ub[NV]==BV then
call Haw(NV,"when calling onEvent in ClosureEvents, line 177")
endif
set NV=rb[NV]
endloop
endif
endif
if ZS[BV]!=0 then
set MV=ZS[BV]
loop
exitwhen MV==0
call Haw(MV,"when calling onEvent in ClosureEvents, line 183")
set MV=rb[MV]
endloop
endif
set Lb=Lb-1
set VV=null
set wB=null
endfunction
function Lxw takes nothing returns nothing
set Lb=0
call sB("ClosureEvents, line 241")
endfunction
function NL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988531 then
return false
endif
return true
endfunction
function ML takes nothing returns boolean
if not NL() then
return false
endif
return true
endfunction
function MP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990607,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990583,0)
endfunction
function NU takes nothing returns boolean
if GetResearched()!=1378890033 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890033,true)!=2 then
return false
endif
return true
endfunction
function MU takes nothing returns boolean
if not NU() then
return false
endif
return true
endfunction
function wlw takes string NOw returns integer
local integer MOw
set Xb[Lb]=NOw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_HashMap in HashMap, line 7"
set Lb=Lb+1
if IO==0 then
if PO<32768 then
set PO=PO+1
set MOw=PO
set AO[MOw]=729
else
call x1("Out of memory: Could not create HashMap.","when calling error in HashMap, line 8")
set MOw=0
endif
else
set IO=IO-1
set MOw=UO[IO]
set AO[MOw]=729
endif
set Lb=Lb-1
set qb[MOw]=0
set Lb=Lb-1
return MOw
endfunction
function Mjw takes nothing returns boolean
set Lb=0
set Xb[Lb]="EventHelper, line 1"
set Lb=Lb+1
call wlw("when calling new_HashMap in EventHelper, line 6")
call wlw("when calling new_HashMap in EventHelper, line 7")
call Yqw("when calling new_Table in EventHelper, line 8")
set Lb=Lb-1
return true
endfunction
function Mv takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988561,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988784,0)
endfunction
function l2 takes string K4 returns nothing
local fogmodifier array L4
local integer X4
local integer C4
local integer V4
local integer B4
local integer N4
local player M4
local fogstate w2
local location u2
local rect r2
local force s2
local integer t2
local integer i2
local integer S2
local integer c2
local string o2
local force O2
set Xb[Lb]=K4
set Lb=Lb+1
if hc then
set Lb=Lb-1
set M4=null
set w2=null
set u2=null
set r2=null
set s2=null
set O2=null
return
endif
set X4=0
set C4=23
loop
exitwhen X4>C4
set M4=uo[X4]
set w2=FOG_OF_WAR_VISIBLE
set r2=bj_mapInitialPlayableArea
set u2=Location(GetRectCenterX(r2),GetRectCenterY(r2))
set bj_lastCreatedFogModifier=CreateFogModifierRadiusLoc(M4,w2,u2,999999.00,true,false)
call FogModifierStart(bj_lastCreatedFogModifier)
set L4[X4]=bj_lastCreatedFogModifier
call FogModifierStart(L4[X4])
set X4=X4+1
endloop
set s2=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),s2) then
call ShowInterface(false,0.50)
endif
set t2=Yc
set Xb[Lb]="when calling iterator in MainInit, line 89"
set Lb=Lb+1
set i2=ibw(t2,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set V4=i2
loop
exitwhen Tb[Gb[V4]]==Yb[V4]
set Gb[V4]=Tb[Gb[V4]]
set S2=fb[Gb[V4]]
set Xb[Lb]="when calling stringFromIndex in MainInit, line 89"
set Lb=Lb+1
set c2=Po
set Xb[Lb]="when calling loadString in TypeCasting, line 35"
set Lb=Lb+1
if AO[c2]==0 then
if c2==0 then
call x1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call x1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set o2=LoadStr(Eo,c2,S2)
set Lb=Lb-1
set K4=o2
set Lb=Lb-1
if not Gc then
set O2=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),O2) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,o2)
endif
call TriggerSleepAction(12.5)
endif
endloop
set Xb[Lb]="when calling close in MainInit, line 89"
set Lb=Lb+1
if hb[V4]then
call Gdw(V4,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
call CinematicModeExBJ(false,bj_FORCE_ALL_PLAYERS,bj_CINEMODE_INTERFACEFADE)
set B4=0
set N4=23
loop
exitwhen B4>N4
call FogModifierStop(L4[B4])
set B4=B4+1
endloop
set Gc=true
set Lb=Lb-1
set M4=null
set w2=null
set u2=null
set r2=null
set s2=null
set O2=null
endfunction
function Mxw takes nothing returns nothing
set Lb=0
call l2("MainInit, line 136")
endfunction
function VF takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function BF takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988801 then
return false
endif
if not VF() then
return false
endif
return true
endfunction
function NF takes nothing returns boolean
if not BF() then
return false
endif
return true
endfunction
function BH takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())==1747988531 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990328 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747989592 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990086 then
return true
endif
return false
endfunction
function NH takes nothing returns boolean
if not BH() then
return false
endif
return true
endfunction
function BP takes nothing returns boolean
if GetResearched()!=1378890051 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890051,true)!=2 then
return false
endif
return true
endfunction
function NP takes nothing returns boolean
if not BP() then
return false
endif
return true
endfunction
function NT takes nothing returns nothing
local player LT=GetOwningPlayer(GetAttacker())
local player XT=GetOwningPlayer(GetAttacker())
local player CT
local player VT
local unit BT
set r[GetPlayerId(LT)+1]=r[GetPlayerId(XT)+1]+1
set CT=GetOwningPlayer(GetTriggerUnit())
set VT=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(CT)+1]=r[GetPlayerId(VT)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set BT=GetTriggerUnit()
call SetUnitState(BT,UNIT_STATE_LIFE,GetUnitState(BT,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set LT=null
set XT=null
set CT=null
set VT=null
set BT=null
endfunction
function NY takes nothing returns nothing
set t=GetUnitLoc(GetSpellTargetUnit())
set bj_lastCreatedEffect=AddSpecialEffectLoc("Abilities\\Spells\\Orc\\Voodoo\\VoodooAuraTarget.mdl",t)
call DestroyEffect(bj_lastCreatedEffect)
set i=GetUnitLoc(GetSpellAbilityUnit())
set bj_lastCreatedEffect=AddSpecialEffectLoc("Abilities\\Spells\\Orc\\Voodoo\\VoodooAura.mdl",i)
call DestroyEffect(bj_lastCreatedEffect)
call RemoveLocation(t)
call RemoveLocation(i)
endfunction
function NZ takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,eq)
endfunction
function Njw takes nothing returns boolean
local integer Bjw
set Lb=0
set Xb[Lb]="Abilities, line 1"
set Lb=Lb+1
set Xb[Lb]="when calling asList in Abilities, line 17"
set Lb=Lb+1
set Bjw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(Bjw,1093677642,"when calling add in LinkedList, line 393")
call jfw(Bjw,1093677641,"when calling add in LinkedList, line 393")
call jfw(Bjw,1093677640,"when calling add in LinkedList, line 393")
call jfw(Bjw,1093678155,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set sS=Bjw
set Lb=Lb-1
return true
endfunction
function Bv takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function Nv takes nothing returns boolean
if not Bv() then
return false
endif
return true
endfunction
function N2 takes player L2,string X2 returns string
local integer C2
local integer V2
local integer B2
set Xb[Lb]=X2
set Lb=Lb+1
set V2=wo[GetPlayerId(L2)]
set Xb[Lb]="when calling getForceId in Messages, line 5"
set Lb=Lb+1
if yl[V2]==0 then
if V2==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set B2=Ub[V2]
set Lb=Lb-1
set C2=GetRandomInt(0,2)
if B2==0 then
set X2=no[C2]
elseif B2==1 then
set X2=do[C2]
elseif B2==2 then
set X2=fo[C2]
elseif B2==3 then
set X2=Ro[C2]
else
set X2="Warning!"
endif
set Lb=Lb-1
return "|cffff0000"+X2+"|r"
endfunction
function Rvw takes integer avw,integer nvw,string dvw returns integer
local integer fvw
if nvw<0 or nvw>=24 then
call x1("Index out of Bounds",dvw)
elseif nvw<=11 then
if nvw<=5 then
if nvw<=2 then
if nvw<=1 then
if nvw<=0 then
set fvw=Nb[avw]
else
set fvw=Mb[avw]
endif
else
set fvw=wy[avw]
endif
elseif nvw<=4 then
if nvw<=3 then
set fvw=uy[avw]
else
set fvw=ry[avw]
endif
else
set fvw=sy[avw]
endif
elseif nvw<=8 then
if nvw<=7 then
if nvw<=6 then
set fvw=ty[avw]
else
set fvw=iy[avw]
endif
else
set fvw=Sy[avw]
endif
elseif nvw<=10 then
if nvw<=9 then
set fvw=cy[avw]
else
set fvw=oy[avw]
endif
else
set fvw=Oy[avw]
endif
elseif nvw<=17 then
if nvw<=14 then
if nvw<=13 then
if nvw<=12 then
set fvw=ly[avw]
else
set fvw=by[avw]
endif
else
set fvw=yy[avw]
endif
elseif nvw<=16 then
if nvw<=15 then
set fvw=py[avw]
else
set fvw=ey[avw]
endif
else
set fvw=qy[avw]
endif
elseif nvw<=20 then
if nvw<=19 then
if nvw<=18 then
set fvw=ay[avw]
else
set fvw=ny[avw]
endif
else
set fvw=dy[avw]
endif
elseif nvw<=22 then
if nvw<=21 then
set fvw=fy[avw]
else
set fvw=Ry[avw]
endif
else
set fvw=Ty[avw]
endif
return fvw
endfunction
function qvw takes integer bvw,integer yvw,integer pvw,string evw returns nothing
if yvw<0 or yvw>=24 then
call x1("Index out of Bounds",evw)
elseif yvw<=11 then
if yvw<=5 then
if yvw<=2 then
if yvw<=1 then
if yvw<=0 then
set Nb[bvw]=pvw
else
set Mb[bvw]=pvw
endif
else
set wy[bvw]=pvw
endif
elseif yvw<=4 then
if yvw<=3 then
set uy[bvw]=pvw
else
set ry[bvw]=pvw
endif
else
set sy[bvw]=pvw
endif
elseif yvw<=8 then
if yvw<=7 then
if yvw<=6 then
set ty[bvw]=pvw
else
set iy[bvw]=pvw
endif
else
set Sy[bvw]=pvw
endif
elseif yvw<=10 then
if yvw<=9 then
set cy[bvw]=pvw
else
set oy[bvw]=pvw
endif
else
set Oy[bvw]=pvw
endif
elseif yvw<=17 then
if yvw<=14 then
if yvw<=13 then
if yvw<=12 then
set ly[bvw]=pvw
else
set by[bvw]=pvw
endif
else
set yy[bvw]=pvw
endif
elseif yvw<=16 then
if yvw<=15 then
set py[bvw]=pvw
else
set ey[bvw]=pvw
endif
else
set qy[bvw]=pvw
endif
elseif yvw<=20 then
if yvw<=19 then
if yvw<=18 then
set ay[bvw]=pvw
else
set ny[bvw]=pvw
endif
else
set dy[bvw]=pvw
endif
elseif yvw<=22 then
if yvw<=21 then
set fy[bvw]=pvw
else
set Ry[bvw]=pvw
endif
else
set Ty[bvw]=pvw
endif
endfunction
function Zew takes integer vew,player mew,integer Qew,string Wew returns nothing
local integer Eew
set Xb[Lb]=Wew
set Lb=Lb+1
set Eew=GetPlayerId(mew)
if not Pb[vew]then
set Lb=Lb-1
return
endif
if Eew>=24 then
set Lb=Lb-1
return
endif
if Rvw(vew,Eew,"when reading array PlayerStats_alliance_states in  in PlayerStats, line 61")==Qew or mew==Ib[vew]then
set Lb=Lb-1
return
endif
call qvw(vew,Eew,Qew,"when writing array PlayerStats_alliance_states in PlayerStats, line 63")
call SetPlayerAllianceStateBJ(Ib[vew],mew,Qew)
set Lb=Lb-1
endfunction
function l5 takes player i5,string S5 returns string
local integer c5
local integer o5
local integer O5
set Xb[Lb]=S5
set Lb=Lb+1
set o5=wo[GetPlayerId(i5)]
set Xb[Lb]="when calling getForceId in Messages, line 37"
set Lb=Lb+1
if yl[o5]==0 then
if o5==0 then
call x1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call x1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set O5=Ub[o5]
set Lb=Lb-1
set c5=GetRandomInt(0,2)
if O5==0 then
set S5=ho[c5]
elseif O5==1 then
set S5=Fo[c5]
elseif O5==2 then
set S5=ko[c5]
elseif O5==3 then
set S5=jo[c5]
else
set S5="Good news!"
endif
set Lb=Lb-1
return "|cff00ff00"+S5+"|r"
endfunction
function h3 takes string fM returns nothing
local player RM
local player TM
local string YM
local string GM
local integer gM
local force hM
local force FM
local integer kM
local integer jM
local integer xM
local integer vM
local integer mM
local integer QM
local integer WM
local integer EM
local integer ZM
local force UM
local force IM
local integer PM
local integer AM
local integer DM
local integer HM
local integer JM
local integer KM
local player LM
local force XM
local player CM
local player VM
local player BM
local integer NM
local integer MM
local integer w3
local integer u3
local player r3
local force s3
local player t3
local player i3
local player S3
local integer c3
local integer o3
local integer O3
local integer l3
local player b3
local force y3
local player p3
local player e3
local player q3
local integer a3
local integer n3
local integer d3
local integer f3
local player R3
local force T3
local player Y3
local player G3
local player g3
set Xb[Lb]=fM
set Lb=Lb+1
set RM=GetOwningPlayer(GetSpellAbilityUnit())
set TM=GetOwningPlayer(GetSpellTargetUnit())
set YM=UB(RM)
set GM=UB(TM)
set gM=GetPlayerId(RM)
set UM=CreateForce()
call ForceAddPlayer(UM,RM)
set hM=UM
set IM=CreateForce()
call ForceAddPlayer(IM,RM)
set FM=IM
set kM=GetSpellAbilityId()
if kM==1093677396 then
set PM=wo[gM]
set Xb[Lb]="when calling getAllianceState in Diplomacy, line 16"
set Lb=Lb+1
if yl[PM]==0 then
if PM==0 then
call x1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call x1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Xb[Lb]="when calling getAllianceState in PlayerStats, line 66"
set Lb=Lb+1
set AM=Rvw(PM,GetPlayerId(TM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Lb=Lb-1-1
if AM==bj_ALLIANCE_UNALLIED then
set Lb=Lb-1
set RM=null
set TM=null
set hM=null
set FM=null
set UM=null
set IM=null
set LM=null
set XM=null
set CM=null
set VM=null
set BM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
return
endif
set DM=wo[gM]
set HM=bj_ALLIANCE_UNALLIED
set Xb[Lb]="when calling setAlliance in Diplomacy, line 18"
set Lb=Lb+1
if yl[DM]==0 then
if DM==0 then
call x1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call x1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Zew(DM,TM,HM,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set JM=wo[GetPlayerId(TM)]
set KM=bj_ALLIANCE_UNALLIED
set Xb[Lb]="when calling setAlliance in Diplomacy, line 19"
set Lb=Lb+1
if yl[JM]==0 then
if JM==0 then
call x1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call x1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Zew(JM,RM,KM,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set jM=0
set xM=23
loop
exitwhen jM>xM
set LM=uo[jM]
set XM=CreateForce()
call ForceAddPlayer(XM,LM)
if uo[jM]==TM then
set CM=uo[jM]
set Xb[Lb]="when calling warningToPlayer in Diplomacy, line 24"
set Lb=Lb+1
call DisplayTimedTextToPlayer(CM,0.,0.,10.0,N2(CM,"when calling getWarningStringForPlayer in Messages, line 79"))
call DisplayTimedTextToPlayer(CM,0.,0.,10.0,YM+" has declared war on you!")
set Lb=Lb-1
elseif XM==hM or XM==FM then
set VM=uo[jM]
set Xb[Lb]="when calling attentionToPlayer in Diplomacy, line 26"
set Lb=Lb+1
call DisplayTimedTextToPlayer(VM,0.,0.,10.0,a5(VM,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(VM,0.,0.,10.0,YM+" has declared war on your brother-in-arms, "+GM+"!")
set Lb=Lb-1
else
set BM=uo[jM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 28"
set Lb=Lb+1
call DisplayTimedTextToPlayer(BM,0.,0.,10.0,t5(BM,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(BM,0.,0.,10.0,YM+" has declared war on "+GM)
set Lb=Lb-1
endif
set jM=jM+1
endloop
elseif kM==1093677397 then
set NM=wo[gM]
set Xb[Lb]="when calling getAllianceState in Diplomacy, line 31"
set Lb=Lb+1
if yl[NM]==0 then
if NM==0 then
call x1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call x1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Xb[Lb]="when calling getAllianceState in PlayerStats, line 66"
set Lb=Lb+1
set MM=Rvw(NM,GetPlayerId(TM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Lb=Lb-1-1
if MM==bj_ALLIANCE_ALLIED_VISION then
set Lb=Lb-1
set RM=null
set TM=null
set hM=null
set FM=null
set UM=null
set IM=null
set LM=null
set XM=null
set CM=null
set VM=null
set BM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
return
endif
set w3=wo[gM]
set u3=bj_ALLIANCE_ALLIED_VISION
set Xb[Lb]="when calling setAlliance in Diplomacy, line 33"
set Lb=Lb+1
if yl[w3]==0 then
if w3==0 then
call x1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call x1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Zew(w3,TM,u3,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set vM=0
set mM=23
loop
exitwhen vM>mM
set r3=uo[vM]
set s3=CreateForce()
call ForceAddPlayer(s3,r3)
if uo[vM]==TM then
set t3=uo[vM]
set Xb[Lb]="when calling goodNewsToPlayer in Diplomacy, line 38"
set Lb=Lb+1
call DisplayTimedTextToPlayer(t3,0.,0.,10.0,l5(t3,"when calling getGoodNewsStringForPlayer in Messages, line 85"))
call DisplayTimedTextToPlayer(t3,0.,0.,10.0,YM+" seeks an alliance with you!")
set Lb=Lb-1
elseif s3==hM or s3==FM then
set i3=uo[vM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 40"
set Lb=Lb+1
call DisplayTimedTextToPlayer(i3,0.,0.,10.0,t5(i3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(i3,0.,0.,10.0,YM+" has allied "+GM)
set Lb=Lb-1
else
set S3=uo[vM]
set fM="when calling noteToPlayer in Diplomacy, line 42"
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 42"
set Lb=Lb+1
call DisplayTimedTextToPlayer(S3,0.,0.,10.0,t5(S3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(S3,0.,0.,10.0,YM+" has allied "+GM)
set Lb=Lb-1
endif
set vM=vM+1
endloop
elseif kM==1093677398 then
set c3=wo[gM]
set Xb[Lb]="when calling getAllianceState in Diplomacy, line 45"
set Lb=Lb+1
if yl[c3]==0 then
if c3==0 then
call x1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call x1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Xb[Lb]="when calling getAllianceState in PlayerStats, line 66"
set Lb=Lb+1
set o3=Rvw(c3,GetPlayerId(TM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Lb=Lb-1-1
if o3==bj_ALLIANCE_NEUTRAL then
set Lb=Lb-1
set RM=null
set TM=null
set hM=null
set FM=null
set UM=null
set IM=null
set LM=null
set XM=null
set CM=null
set VM=null
set BM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
return
endif
set O3=wo[gM]
set l3=bj_ALLIANCE_NEUTRAL
set Xb[Lb]="when calling setAlliance in Diplomacy, line 47"
set Lb=Lb+1
if yl[O3]==0 then
if O3==0 then
call x1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call x1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Zew(O3,TM,l3,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set QM=0
set WM=23
loop
exitwhen QM>WM
set b3=uo[QM]
set y3=CreateForce()
call ForceAddPlayer(y3,b3)
if uo[QM]==TM then
set p3=uo[QM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 52"
set Lb=Lb+1
call DisplayTimedTextToPlayer(p3,0.,0.,10.0,t5(p3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(p3,0.,0.,10.0,YM+" is now neutral towards you!")
set Lb=Lb-1
elseif y3==hM or y3==FM then
set e3=uo[QM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 54"
set Lb=Lb+1
call DisplayTimedTextToPlayer(e3,0.,0.,10.0,t5(e3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(e3,0.,0.,10.0,YM+" shows neutrality towards "+GM)
set Lb=Lb-1
else
set q3=uo[QM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 56"
set Lb=Lb+1
call DisplayTimedTextToPlayer(q3,0.,0.,10.0,t5(q3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(q3,0.,0.,10.0,YM+" shows neutrality towards "+GM)
set Lb=Lb-1
endif
set QM=QM+1
endloop
elseif kM==1093677400 then
set a3=wo[gM]
set Xb[Lb]="when calling getAllianceState in Diplomacy, line 59"
set Lb=Lb+1
if yl[a3]==0 then
if a3==0 then
call x1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call x1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Xb[Lb]="when calling getAllianceState in PlayerStats, line 66"
set Lb=Lb+1
set n3=Rvw(a3,GetPlayerId(TM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Lb=Lb-1-1
if n3==bj_ALLIANCE_NEUTRAL then
set Lb=Lb-1
set RM=null
set TM=null
set hM=null
set FM=null
set UM=null
set IM=null
set LM=null
set XM=null
set CM=null
set VM=null
set BM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
return
endif
set d3=wo[gM]
set f3=bj_ALLIANCE_NEUTRAL
set Xb[Lb]="when calling setAlliance in Diplomacy, line 61"
set Lb=Lb+1
if yl[d3]==0 then
if d3==0 then
call x1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call x1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Zew(d3,TM,f3,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set EM=0
set ZM=23
loop
exitwhen EM>ZM
set R3=uo[EM]
set T3=CreateForce()
call ForceAddPlayer(T3,R3)
if uo[EM]==TM then
set Y3=uo[EM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 66"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Y3,0.,0.,10.0,t5(Y3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(Y3,0.,0.,10.0,YM+" unallies you!")
set Lb=Lb-1
elseif T3==hM or T3==FM then
set G3=uo[EM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 68"
set Lb=Lb+1
call DisplayTimedTextToPlayer(G3,0.,0.,10.0,t5(G3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(G3,0.,0.,10.0,YM+" has unallied "+GM)
set Lb=Lb-1
else
set g3=uo[EM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 70"
set Lb=Lb+1
call DisplayTimedTextToPlayer(g3,0.,0.,10.0,t5(g3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(g3,0.,0.,10.0,YM+" has unallied "+GM)
set Lb=Lb-1
endif
set EM=EM+1
endloop
endif
set Lb=Lb-1
set RM=null
set TM=null
set hM=null
set FM=null
set UM=null
set IM=null
set LM=null
set XM=null
set CM=null
set VM=null
set BM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
endfunction
function Nxw takes nothing returns nothing
set Lb=0
call h3("Diplomacy, line 119")
endfunction
function oE takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function OE takes nothing returns boolean
if not oE() then
return false
endif
return true
endfunction
function OL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function OU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989814,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989825,0)
endfunction
function OW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988818,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988552,0)
endfunction
function Eow takes integer Gow,integer gow,string how returns nothing
local integer Fow
local integer kow
local multiboard jow
local integer xow
local boolean vow
local integer mow
local string Qow
local integer Wow
set Xb[Lb]=how
set Lb=Lb+1
set Fow=0
set kow=23
loop
exitwhen Fow>kow
set xow=wo[Fow]
set Xb[Lb]="when calling isInGame in Economy, line 49"
set Lb=Lb+1
if yl[xow]==0 then
if xow==0 then
call x1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call x1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set vow=Pb[xow]
set Lb=Lb-1
if vow then
set jow=Xc[Fow]
set mow=Pc[0]
set Gow=Pc[1]
set gow=wo[Fow]
set how="when calling getUpkeep in Economy, line 51"
set Xb[Lb]="when calling getUpkeep in Economy, line 51"
set Lb=Lb+1
if yl[gow]==0 then
if gow==0 then
call x1("Nullpointer exception when calling PlayerStats.getUpkeep","when calling error in PlayerStats, line 48")
else
call x1("Called PlayerStats.getUpkeep on invalid object.","when calling error in PlayerStats, line 48")
endif
endif
set Wow=Db[gow]
set Lb=Lb-1
set Qow=xww(Wow)
call MultiboardSetItemValue(MultiboardGetItem(jow,Gow,mow),Qow)
endif
set Fow=Fow+1
endloop
set Lb=Lb-1
set jow=null
endfunction
function n1 takes string i1 returns nothing
local integer S1
local integer c1
local integer o1
local integer O1
local integer l1
local real b1
local integer y1
local timer p1
local integer e1
local integer q1
local integer a1
set Xb[Lb]=i1
set Lb=Lb+1
set S1=0
set c1=23
loop
exitwhen S1>c1
set rc[S1]=tc[S1]
set sc[S1]=0
set S1=S1+1
endloop
set o1=R2I(dS*0.5/10.0)+1
set O1=0
set l1=R2I(20)-1
loop
exitwhen O1>l1
set b1=O1*0.5
set i1="when calling alloc_Economy_CallbackSingle_line34 in Economy, line 34"
set Xb[Lb]="when calling alloc_Economy_CallbackSingle_line34 in Economy, line 34"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set y1=RO
set TO[y1]=644
else
call x1("Out of memory: Could not create Economy_CallbackSingle_line34.","when calling error in Economy, line 34")
set y1=0
endif
else
set fO=fO-1
set y1=dO[fO]
set TO[y1]=644
endif
set Lb=Lb-1
set yb[y1]=O1
set pb[y1]=o1
set Xb[Lb]="when calling doAfter in Economy, line 34"
set Lb=Lb+1
set p1=Sww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(y1,p1,b1,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1
set e1=dS-1
set q1=(O1+1)*o1-1
if e1<2147483647 then
set a1=e1
else
set a1=2147483647
endif
if q1<a1 then
set a1=q1
endif
exitwhen a1==dS-1
set O1=O1+1
endloop
set Lb=Lb-1
set p1=null
endfunction
function OOw takes integer Zow,integer Uow,string Iow returns nothing
local integer Aow
local multiboard Dow
local integer How
local integer Jow
local integer Kow
local integer Low
local integer Xow
local boolean Cow
local integer Vow
local integer Bow
local integer Now
local string Mow
local integer wOw
local integer uOw
local integer rOw
local boolean sOw
local integer tOw
local integer iOw
local integer SOw
local player cOw
local playerstate oOw
set Xb[Lb]=Iow
set Lb=Lb+1
set ic=ic+1
set Zow=0
set Aow=23
loop
exitwhen Zow>Aow
set Xow=wo[Zow]
set Xb[Lb]="when calling isInGame in Economy, line 57"
set Lb=Lb+1
if yl[Xow]==0 then
if Xow==0 then
call x1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call x1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set Cow=Pb[Xow]
set Lb=Lb-1
if Cow then
set Dow=Xc[Zow]
set Vow=Ic[0]
set Bow=Ic[1]
set Iow=xww(rc[Zow])
call MultiboardSetItemValue(MultiboardGetItem(Dow,Bow,Vow),Iow)
set Uow=Pc[0]
set Now=Pc[1]
set wOw=wo[Zow]
set Xb[Lb]="when calling getUpkeep in Economy, line 60"
set Lb=Lb+1
if yl[wOw]==0 then
if wOw==0 then
call x1("Nullpointer exception when calling PlayerStats.getUpkeep","when calling error in PlayerStats, line 48")
else
call x1("Called PlayerStats.getUpkeep on invalid object.","when calling error in PlayerStats, line 48")
endif
endif
set uOw=Db[wOw]
set Lb=Lb-1
set Mow=xww(uOw)
call MultiboardSetItemValue(MultiboardGetItem(Dow,Now,Uow),Mow)
endif
set Zow=Zow+1
endloop
if ic==R2I(12) then
set ic=0
set How=0
set Jow=23
loop
exitwhen How>Jow
set rOw=wo[How]
set Xb[Lb]="when calling isInGame in Economy, line 65"
set Lb=Lb+1
if yl[rOw]==0 then
if rOw==0 then
call x1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call x1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set sOw=Pb[rOw]
set Lb=Lb-1
if sOw then
set Kow=GetPlayerState(uo[How],PLAYER_STATE_RESOURCE_GOLD)
set Low=GetPlayerState(uo[How],PLAYER_STATE_RESOURCE_LUMBER)
set cOw=uo[How]
set oOw=PLAYER_STATE_RESOURCE_GOLD
set SOw=Kow+rc[How]
set tOw=wo[How]
set Xb[Lb]="when calling getUpkeep in Economy, line 68"
set Lb=Lb+1
if yl[tOw]==0 then
if tOw==0 then
call x1("Nullpointer exception when calling PlayerStats.getUpkeep","when calling error in PlayerStats, line 48")
else
call x1("Called PlayerStats.getUpkeep on invalid object.","when calling error in PlayerStats, line 48")
endif
endif
set iOw=Db[tOw]
set Lb=Lb-1
call SetPlayerState(cOw,oOw,SOw+iOw)
call SetPlayerState(uo[How],PLAYER_STATE_RESOURCE_LUMBER,Low+sc[How])
endif
set How=How+1
endloop
endif
call n1("when calling countIncomeForAll in Economy, line 71")
set Lb=Lb-1
set Dow=null
set cOw=null
set oOw=null
endfunction
function Qyw takes integer Fyw,integer kyw,string jyw returns nothing
local integer xyw
local integer vyw
local boolean myw
set Xb[Lb]=jyw
set Lb=Lb+1
set xyw=0
set vyw=23
loop
exitwhen xyw>vyw
set kyw=wo[xyw]
set Xb[Lb]="when calling isInGame in MultiboardCityUpdate, line 27"
set Lb=Lb+1
if yl[kyw]==0 then
if kyw==0 then
call x1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call x1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set myw=Pb[kyw]
set Lb=Lb-1
if myw then
set Fyw=wo[xyw]
set jyw="when calling refreshMultiboardCity in MultiboardCityUpdate, line 28"
set Xb[Lb]="when calling refreshMultiboardCity in MultiboardCityUpdate, line 28"
set Lb=Lb+1
if yl[Fyw]==0 then
if Fyw==0 then
call x1("Nullpointer exception when calling PlayerStats.refreshMultiboardCity","when calling error in PlayerStats, line 71")
else
call x1("Called PlayerStats.refreshMultiboardCity on invalid object.","when calling error in PlayerStats, line 71")
endif
endif
call yew(Fyw,"when calling refreshMultiboardCity in PlayerStats, line 71")
set Lb=Lb-1
endif
set xyw=xyw+1
endloop
set Lb=Lb-1
endfunction
function Ycw takes integer Scw,integer ccw,string ocw returns nothing
local integer Ocw
local real lcw
local integer bcw
local real ycw
local integer pcw
local real ecw
local real qcw
local integer acw
local real ncw
local integer dcw
local integer fcw
local integer Rcw
local integer Tcw
set Xb[Lb]=ocw
set Lb=Lb+1
set lcw=Gl[ldw(nS,2,"when calling get in City, line 155")]
if GetRandomReal(0.0,1.0)<=lcw then
set bcw=wb[Scw]
set Xb[Lb]="when calling addModifier in City, line 156"
set Lb=Lb+1
if pO[bcw]==0 then
if bcw==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(bcw,2,"when calling addModifier in City, line 368")
set Lb=Lb-1
endif
set ycw=Gl[ldw(nS,5,"when calling get in City, line 157")]
if GetRandomReal(0.0,1.0)<=ycw then
set pcw=wb[Scw]
set Xb[Lb]="when calling addModifier in City, line 158"
set Lb=Lb+1
if pO[pcw]==0 then
if pcw==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(pcw,5,"when calling addModifier in City, line 368")
set Lb=Lb-1
endif
set ecw=Gl[ldw(nS,7,"when calling get in City, line 159")]
if GetRandomReal(0.0,1.0)<=ecw then
set ccw=wb[Scw]
set Xb[Lb]="when calling addModifier in City, line 160"
set Lb=Lb+1
if pO[ccw]==0 then
if ccw==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(ccw,7,"when calling addModifier in City, line 368")
set Lb=Lb-1
endif
set qcw=Gl[ldw(nS,3,"when calling get in City, line 161")]
if GetRandomReal(0.0,1.0)<=qcw then
set acw=wb[Scw]
set Xb[Lb]="when calling addModifier in City, line 162"
set Lb=Lb+1
if pO[acw]==0 then
if acw==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(acw,3,"when calling addModifier in City, line 368")
set Lb=Lb-1
endif
set ncw=Gl[ldw(nS,4,"when calling get in City, line 163")]
if GetRandomReal(0.0,1.0)<=ncw then
set dcw=wb[Scw]
set Xb[Lb]="when calling addModifier in City, line 164"
set Lb=Lb+1
if pO[dcw]==0 then
if dcw==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(dcw,4,"when calling addModifier in City, line 368")
set Lb=Lb-1
endif
set fcw=Ll[wb[Scw]]
set Xb[Lb]="when calling iterator in City, line 166"
set Lb=Lb+1
set Rcw=ibw(fcw,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set Ocw=Rcw
loop
exitwhen Tb[Gb[Ocw]]==Yb[Ocw]
set Gb[Ocw]=Tb[Gb[Ocw]]
set Tcw=wb[Scw]
set Xb[Lb]="when calling getCityModifierOnLongCount in City, line 167"
set Lb=Lb+1
if pO[Tcw]==0 then
if Tcw==0 then
call x1("Nullpointer exception when calling City.getCityModifierOnLongCount","when calling error in City, line 416")
else
call x1("Called City.getCityModifierOnLongCount on invalid object.","when calling error in City, line 416")
endif
endif
set Lb=Lb-1
endloop
set Xb[Lb]="when calling close in City, line 166"
set Lb=Lb+1
if hb[Ocw]then
call Gdw(Ocw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1-1
endfunction
function Hiw takes integer Eiw,integer Ziw,real Uiw,string Iiw returns nothing
local integer Piw
local real Aiw
local integer Diw
set Xb[Lb]=Iiw
set Lb=Lb+1
set Piw=Ul[Eiw]
set Diw=Ul[Eiw]
set Aiw=Uiw*GetRandomReal(Udw(cS[Ziw],0,"when calling get in City, line 403")/1000.,Udw(cS[Ziw],1,"when calling get in City, line 403")/1000.)*Ul[Eiw]
set Ul[Eiw]=Diw+R2I(Aiw)
set Il[Eiw]=Il[Eiw]+(Ul[Eiw]-Piw)
set Lb=Lb-1
endfunction
function Viw takes integer Jiw,integer Kiw,string Liw returns nothing
local integer Xiw
local real Ciw
set Xb[Lb]=Liw
set Lb=Lb+1
set Xiw=gl[ldw(nS,Kiw,"when calling get in City, line 408")]
set Ciw=hl[ldw(nS,Kiw,"when calling get in City, line 409")]
set Xb[Lb]="when calling addPopulation in City, line 410"
set Lb=Lb+1
if pO[Jiw]==0 then
if Jiw==0 then
call x1("Nullpointer exception when calling City.addPopulation","when calling error in City, line 401")
else
call x1("Called City.addPopulation on invalid object.","when calling error in City, line 401")
endif
endif
call Hiw(Jiw,Xiw,Ciw,"when calling addPopulation in City, line 401")
set Lb=Lb-1
if Yl[ldw(nS,Kiw,"when calling get in City, line 412")]==false then
set Dl[Jiw]=Dl[Jiw]-Tl[ldw(nS,Kiw,"when calling get in City, line 413")]*5.0/Rl[ldw(nS,Kiw,"when calling get in City, line 413")]
endif
set Lb=Lb-1
endfunction
function icw takes integer LSw,integer XSw,string CSw returns nothing
local integer VSw
local integer BSw
local integer NSw
local integer MSw
local integer wcw
local real ucw
local integer rcw
local integer scw
local integer tcw
set Xb[Lb]=CSw
set Lb=Lb+1
set Pl[Ml[LSw]]=Pl[Ml[LSw]]+GetRandomReal(-0.0001,0.00015)*Pl[Ml[LSw]]
set VSw=Ul[Ml[LSw]]
set XSw=Ul[Ml[LSw]]
set ucw=Pow(Ul[Ml[LSw]]*Pl[Ml[LSw]],0.8)*hS[Jl[Ml[LSw]]]
set Ul[Ml[LSw]]=XSw+R2I(ucw)
set BSw=Ul[Ml[LSw]]-VSw
set NSw=GetRandomInt(R2I(-(0.25*BSw)),R2I(0.25*BSw))
set Ul[Ml[LSw]]=Ul[Ml[LSw]]+NSw
set Il[Ml[LSw]]=Ul[Ml[LSw]]-VSw
set rcw=Ll[Ml[LSw]]
set Xb[Lb]="when calling iterator in City, line 149"
set Lb=Lb+1
set scw=ibw(rcw,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set MSw=scw
loop
exitwhen Tb[Gb[MSw]]==Yb[MSw]
set Gb[MSw]=Tb[Gb[MSw]]
set wcw=fb[Gb[MSw]]
set tcw=Ml[LSw]
set Xb[Lb]="when calling getCityModifierOnFastCount in City, line 150"
set Lb=Lb+1
if pO[tcw]==0 then
if tcw==0 then
call x1("Nullpointer exception when calling City.getCityModifierOnFastCount","when calling error in City, line 407")
else
call x1("Called City.getCityModifierOnFastCount on invalid object.","when calling error in City, line 407")
endif
endif
call Viw(tcw,wcw,"when calling getCityModifierOnFastCount in City, line 407")
set Lb=Lb-1
endloop
set Xb[Lb]="when calling close in City, line 149"
set Lb=Lb+1
if hb[MSw]then
call Gdw(MSw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1-1
endfunction
function uow takes integer Ncw,integer Mcw returns nothing
local integer wow
set Ob[Ncw]=Ob[Ncw]-1.
set wow=0
set Mcw=23
loop
exitwhen wow>Mcw
call MultiboardSetTitleText(Xc[wow],"Income: "+I2S(R2I(Ob[Ncw]/60.))+":"+I2S(R2I(ModuloReal(Ob[Ncw],60.)/10.))+I2S(R2I(ModuloReal(ModuloReal(Ob[Ncw],60.),10.))))
set wow=wow+1
endloop
if Ob[Ncw]<=0. then
set Ob[Ncw]=120.0
endif
endfunction
function Onw takes integer inw,integer Snw,string cnw returns nothing
local force onw
set Xb[Lb]=cnw
set Lb=Lb+1
if hO[inw]==0 then
if inw==0 then
call x1("Nullpointer exception when calling CallbackPeriodic.call","when calling error in ClosureTimers, line 130")
else
call x1("Called CallbackPeriodic.call on invalid object.","when calling error in ClosureTimers, line 130")
endif
endif
if hO[inw]<=634 then
if hO[inw]<=632 then
if hO[inw]<=631 then
call icw(inw,Snw,"when calling City_City_call_line138 in ClosureTimers, line 130")
else
call Ycw(inw,Snw,"when calling City_City_call_line154 in ClosureTimers, line 130")
endif
elseif hO[inw]<=633 then
set onw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),onw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,20.0,"Enjoying the map? Join the |cffe100ffofficial CoE discord channel|r! Link: |cffffff00discord.gg/V6kmxsy|r")
endif
else
call uow(inw,Snw)
endif
elseif hO[inw]<=636 then
if hO[inw]<=635 then
call Eow(inw,Snw,"when calling Economy_call_line47 in ClosureTimers, line 130")
else
call OOw(inw,Snw,"when calling Economy_call_line54 in ClosureTimers, line 130")
endif
else
call Qyw(inw,Snw,"when calling MultiboardCityUpdate_call_line25 in ClosureTimers, line 130")
endif
set Lb=Lb-1
set onw=null
endfunction
function sww takes timer Nww,string Mww returns integer
local integer www
local integer uww
local integer rww
set Xb[Lb]=Mww
set Lb=Lb+1
set www=Io
set uww=GetHandleId(Nww)
set Xb[Lb]="when calling loadInt in TimerUtils, line 21"
set Lb=Lb+1
if AO[www]==0 then
if www==0 then
call x1("Nullpointer exception when calling Table.loadInt","when calling error in Table, line 39")
else
call x1("Called Table.loadInt on invalid object.","when calling error in Table, line 39")
endif
endif
set rww=LoadInteger(Eo,www,uww)
set Lb=Lb-1-1
return rww
endfunction
function Ovw takes nothing returns nothing
local integer ovw
set Lb=0
set Xb[Lb]="ClosureTimers, line 135"
set Lb=Lb+1
set ovw=sww(GetExpiredTimer(),"when calling getData in ClosureTimers, line 138")
call Onw(ovw,ovw,"when calling call in ClosureTimers, line 139")
set Lb=Lb-1
endfunction
function AX takes string IX returns boolean
local integer PX
set Xb[Lb]=IX
set Lb=Lb+1
set SS=wlw("when calling new_HashMap in CityBaseTaxes, line 5")
set PX=SS
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 9"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747988529,20)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 10"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747988530,50)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 11"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747988531,120)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 12"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747990326,20)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 13"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747990327,50)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 14"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747990328,120)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 15"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747990084,20)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 16"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747990085,50)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 17"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747990086,120)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 18"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747989590,20)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 19"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747989591,50)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 20"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747989592,120)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 22"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747989555,5)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 23"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747989297,10)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 24"
set Lb=Lb+1
if AO[PX]==0 then
if PX==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,PX,1747989325,30)
set Lb=Lb-1-1
return true
endfunction
function Oxw takes nothing returns boolean
set Lb=0
return AX("CityBaseTaxes, line 1")
endfunction
function P1 takes nothing returns boolean
call CreateGroup()
return true
endfunction
function PE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989559,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989569,0)
endfunction
function IK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988809 then
return false
endif
return true
endfunction
function PK takes nothing returns boolean
if not IK() then
return false
endif
return true
endfunction
function IQ takes nothing returns boolean
if GetResearched()!=1378889799 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889799,true)!=2 then
return false
endif
return true
endfunction
function PQ takes nothing returns boolean
if not IQ() then
return false
endif
return true
endfunction
function AOw takes string IOw returns integer
local integer POw
set Xb[Lb]=IOw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_HashList in HashList, line 105"
set Lb=Lb+1
if WO==0 then
if EO<32768 then
set EO=EO+1
set POw=EO
set ZO[POw]=692
else
call x1("Out of memory: Could not create HashList.","when calling error in HashList, line 8")
set POw=0
endif
else
set WO=WO-1
set POw=QO[WO]
set ZO[POw]=692
endif
set Lb=Lb-1
set eb[POw]=0
set Lb=Lb-1
return POw
endfunction
function TYw takes integer ORw,integer lRw,integer bRw,integer yRw,integer pRw,integer eRw,integer qRw,integer aRw,integer nRw,integer dRw,integer fRw,integer RRw,integer TRw,integer YRw,integer GRw,integer gRw,integer hRw,integer FRw,integer kRw,integer jRw,integer xRw,integer vRw,integer mRw,integer QRw,integer WRw,integer ERw,integer ZRw,integer URw,integer IRw,string PRw returns nothing
local integer ARw
local hashtable DRw
local integer HRw
local integer JRw
local hashtable KRw
local integer LRw
local integer XRw
local hashtable CRw
local integer VRw
local integer BRw
local hashtable NRw
local integer MRw
local integer wTw
local hashtable uTw
local integer rTw
local integer sTw
local hashtable tTw
local integer iTw
local integer STw
local hashtable cTw
local integer oTw
local integer OTw
local hashtable lTw
local integer bTw
local integer yTw
local hashtable pTw
local integer eTw
local integer qTw
local hashtable aTw
local integer nTw
local integer dTw
local hashtable fTw
local integer RTw
local integer TTw
local hashtable YTw
local integer GTw
local integer gTw
local hashtable hTw
local integer FTw
local integer kTw
local hashtable jTw
local integer xTw
local integer vTw
local hashtable mTw
local integer QTw
local integer WTw
local hashtable ETw
local integer ZTw
local integer UTw
local hashtable ITw
local integer PTw
local integer ATw
local hashtable DTw
local integer HTw
local integer JTw
local hashtable KTw
local integer LTw
local integer XTw
local hashtable CTw
local integer VTw
local integer BTw
local hashtable NTw
local integer MTw
local integer wYw
local hashtable uYw
local integer rYw
local integer sYw
local hashtable tYw
local integer iYw
local integer SYw
local hashtable cYw
local integer oYw
local integer OYw
local hashtable lYw
local integer bYw
local integer yYw
local hashtable pYw
local integer eYw
local integer qYw
local hashtable aYw
local integer nYw
local integer dYw
local hashtable fYw
local integer RYw
set Xb[Lb]=PRw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ARw=LoadInteger(fc,ORw,lRw)
set Lb=Lb-1
if ARw<=0 then
set DRw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set HRw=eb[ORw]
set Lb=Lb-1
call SaveInteger(DRw,ORw,lRw,HRw)
call Djw(ORw,lRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set JRw=LoadInteger(fc,ORw,bRw)
set Lb=Lb-1
if JRw<=0 then
set KRw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set LRw=eb[ORw]
set Lb=Lb-1
call SaveInteger(KRw,ORw,bRw,LRw)
call Djw(ORw,bRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set XRw=LoadInteger(fc,ORw,yRw)
set Lb=Lb-1
if XRw<=0 then
set CRw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set VRw=eb[ORw]
set Lb=Lb-1
call SaveInteger(CRw,ORw,yRw,VRw)
call Djw(ORw,yRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set BRw=LoadInteger(fc,ORw,pRw)
set Lb=Lb-1
if BRw<=0 then
set NRw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set MRw=eb[ORw]
set Lb=Lb-1
call SaveInteger(NRw,ORw,pRw,MRw)
call Djw(ORw,pRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set wTw=LoadInteger(fc,ORw,eRw)
set Lb=Lb-1
if wTw<=0 then
set uTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set rTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(uTw,ORw,eRw,rTw)
call Djw(ORw,eRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set sTw=LoadInteger(fc,ORw,qRw)
set Lb=Lb-1
if sTw<=0 then
set tTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set iTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(tTw,ORw,qRw,iTw)
call Djw(ORw,qRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set STw=LoadInteger(fc,ORw,aRw)
set Lb=Lb-1
if STw<=0 then
set cTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set oTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(cTw,ORw,aRw,oTw)
call Djw(ORw,aRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set OTw=LoadInteger(fc,ORw,nRw)
set Lb=Lb-1
if OTw<=0 then
set lTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set bTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(lTw,ORw,nRw,bTw)
call Djw(ORw,nRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set yTw=LoadInteger(fc,ORw,dRw)
set Lb=Lb-1
if yTw<=0 then
set pTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set eTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(pTw,ORw,dRw,eTw)
call Djw(ORw,dRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set qTw=LoadInteger(fc,ORw,fRw)
set Lb=Lb-1
if qTw<=0 then
set aTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set nTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(aTw,ORw,fRw,nTw)
call Djw(ORw,fRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set dTw=LoadInteger(fc,ORw,RRw)
set Lb=Lb-1
if dTw<=0 then
set fTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set RTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(fTw,ORw,RRw,RTw)
call Djw(ORw,RRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set TTw=LoadInteger(fc,ORw,TRw)
set Lb=Lb-1
if TTw<=0 then
set YTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set GTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(YTw,ORw,TRw,GTw)
call Djw(ORw,TRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set gTw=LoadInteger(fc,ORw,YRw)
set Lb=Lb-1
if gTw<=0 then
set hTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set FTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(hTw,ORw,YRw,FTw)
call Djw(ORw,YRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set kTw=LoadInteger(fc,ORw,GRw)
set Lb=Lb-1
if kTw<=0 then
set jTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set xTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(jTw,ORw,GRw,xTw)
call Djw(ORw,GRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set vTw=LoadInteger(fc,ORw,gRw)
set Lb=Lb-1
if vTw<=0 then
set mTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set QTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(mTw,ORw,gRw,QTw)
call Djw(ORw,gRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set WTw=LoadInteger(fc,ORw,hRw)
set Lb=Lb-1
if WTw<=0 then
set ETw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ZTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(ETw,ORw,hRw,ZTw)
call Djw(ORw,hRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set UTw=LoadInteger(fc,ORw,FRw)
set Lb=Lb-1
if UTw<=0 then
set ITw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set PTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(ITw,ORw,FRw,PTw)
call Djw(ORw,FRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ATw=LoadInteger(fc,ORw,kRw)
set Lb=Lb-1
if ATw<=0 then
set DTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set HTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(DTw,ORw,kRw,HTw)
call Djw(ORw,kRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set JTw=LoadInteger(fc,ORw,jRw)
set Lb=Lb-1
if JTw<=0 then
set KTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set LTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(KTw,ORw,jRw,LTw)
call Djw(ORw,jRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set XTw=LoadInteger(fc,ORw,xRw)
set Lb=Lb-1
if XTw<=0 then
set CTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set VTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(CTw,ORw,xRw,VTw)
call Djw(ORw,xRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set BTw=LoadInteger(fc,ORw,vRw)
set Lb=Lb-1
if BTw<=0 then
set NTw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set MTw=eb[ORw]
set Lb=Lb-1
call SaveInteger(NTw,ORw,vRw,MTw)
call Djw(ORw,vRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set wYw=LoadInteger(fc,ORw,mRw)
set Lb=Lb-1
if wYw<=0 then
set uYw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set rYw=eb[ORw]
set Lb=Lb-1
call SaveInteger(uYw,ORw,mRw,rYw)
call Djw(ORw,mRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set sYw=LoadInteger(fc,ORw,QRw)
set Lb=Lb-1
if sYw<=0 then
set tYw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set iYw=eb[ORw]
set Lb=Lb-1
call SaveInteger(tYw,ORw,QRw,iYw)
call Djw(ORw,QRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set SYw=LoadInteger(fc,ORw,WRw)
set Lb=Lb-1
if SYw<=0 then
set cYw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set oYw=eb[ORw]
set Lb=Lb-1
call SaveInteger(cYw,ORw,WRw,oYw)
call Djw(ORw,WRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set OYw=LoadInteger(fc,ORw,ERw)
set Lb=Lb-1
if OYw<=0 then
set lYw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set bYw=eb[ORw]
set Lb=Lb-1
call SaveInteger(lYw,ORw,ERw,bYw)
call Djw(ORw,ERw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set yYw=LoadInteger(fc,ORw,ZRw)
set Lb=Lb-1
if yYw<=0 then
set pYw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set eYw=eb[ORw]
set Lb=Lb-1
call SaveInteger(pYw,ORw,ZRw,eYw)
call Djw(ORw,ZRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set qYw=LoadInteger(fc,ORw,URw)
set Lb=Lb-1
if qYw<=0 then
set aYw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set nYw=eb[ORw]
set Lb=Lb-1
call SaveInteger(aYw,ORw,URw,nYw)
call Djw(ORw,URw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set dYw=LoadInteger(fc,ORw,IRw)
set Lb=Lb-1
if dYw<=0 then
set fYw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[ORw]==0 then
if ORw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set RYw=eb[ORw]
set Lb=Lb-1
call SaveInteger(fYw,ORw,IRw,RYw)
call Djw(ORw,IRw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set DRw=null
set KRw=null
set CRw=null
set NRw=null
set uTw=null
set tTw=null
set cTw=null
set lTw=null
set pTw=null
set aTw=null
set fTw=null
set YTw=null
set hTw=null
set jTw=null
set mTw=null
set ETw=null
set ITw=null
set DTw=null
set KTw=null
set CTw=null
set NTw=null
set uYw=null
set tYw=null
set cYw=null
set lYw=null
set pYw=null
set aYw=null
set fYw=null
endfunction
function oRw takes integer xfw,integer vfw,integer mfw,integer Qfw,integer Wfw,integer Efw,integer Zfw,integer Ufw,integer Ifw,integer Pfw,integer Afw,integer Dfw,integer Hfw,integer Jfw,integer Kfw,integer Lfw,integer Xfw,integer Cfw,integer Vfw,integer Bfw,integer Nfw,integer Mfw,integer wRw,integer uRw,integer rRw,integer sRw,integer tRw,integer iRw,integer SRw,string cRw returns nothing
set Xb[Lb]=cRw
set Lb=Lb+1
call SaveInteger(dc,xfw,eb[xfw],vfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,vfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],mfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,mfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Qfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Qfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Wfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Wfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Efw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Efw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Zfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Zfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Ufw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Ufw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Ifw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Ifw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Pfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Pfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Afw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Afw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Dfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Dfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Hfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Hfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Jfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Jfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Kfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Kfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Lfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Lfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Xfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Xfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Cfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Cfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Vfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Vfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Bfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Bfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Nfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Nfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],Mfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,Mfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],wRw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,wRw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],uRw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,uRw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],rRw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,rRw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],sRw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,sRw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],tRw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,tRw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],iRw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,iRw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
call SaveInteger(dc,xfw,eb[xfw],SRw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xfw]==0 then
if xfw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xfw,SRw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xfw]=eb[xfw]+1
set Lb=Lb-1
endfunction
function uGw takes integer YYw,integer GYw,integer gYw,integer hYw,integer FYw,integer kYw,integer jYw,integer xYw,integer vYw,integer mYw,integer QYw,integer WYw,integer EYw,integer ZYw,integer UYw,integer IYw,integer PYw,integer AYw,integer DYw,integer HYw,integer JYw,integer KYw,integer LYw,integer XYw,integer CYw,integer VYw,integer BYw,integer NYw,integer MYw,string wGw returns nothing
set Xb[Lb]=wGw
set Lb=Lb+1
if ZO[YYw]==0 then
if YYw==0 then
call x1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call x1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if ZO[YYw]<=692 then
call oRw(YYw,GYw,gYw,hYw,FYw,kYw,jYw,xYw,vYw,mYw,QYw,WYw,EYw,ZYw,UYw,IYw,PYw,AYw,DYw,HYw,JYw,KYw,LYw,XYw,CYw,VYw,BYw,NYw,MYw,"when calling add in HashList, line 25")
else
call TYw(YYw,GYw,gYw,hYw,FYw,kYw,jYw,xYw,vYw,mYw,QYw,WYw,EYw,ZYw,UYw,IYw,PYw,AYw,DYw,HYw,JYw,KYw,LYw,XYw,CYw,VYw,BYw,NYw,MYw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function n0w takes string y0w returns boolean
local integer p0w
local playerunitevent e0w
local integer q0w
local integer a0w
set Xb[Lb]=y0w
set Lb=Lb+1
set p0w=AOw("when calling new_HashList in RangeChecks, line 6")
call uGw(p0w,1747988557,1747990614,1747988789,1747989846,1747990103,1747990064,1747989075,1747990102,1747988785,1747989839,1747990101,1747989554,1747989041,1747990344,1747989059,1747989060,1747988844,1747990351,1747990352,1747990356,1747989331,1747990350,1747989809,1747990353,1747990354,1747990355,1747988568,1747990341,"when calling add in RangeChecks, line 6")
set bo=p0w
set e0w=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Xb[Lb]="when calling alloc_RangeChecks_EventListener_line12 in RangeChecks, line 12"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set q0w=iO
set SO[q0w]=678
else
call x1("Out of memory: Could not create RangeChecks_EventListener_line12.","when calling error in RangeChecks, line 12")
set q0w=0
endif
else
set tO=tO-1
set q0w=sO[tO]
set SO[q0w]=678
endif
set Lb=Lb-1
set ub[q0w]=0
set rb[q0w]=0
set sb[q0w]=0
set Xb[Lb]="when calling add in RangeChecks, line 12"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set a0w=mS[GetHandleId(e0w)]
if a0w==0 then
set a0w=QV(e0w,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[q0w]=a0w
if ZS[ub[q0w]]!=0 then
set sb[ZS[ub[q0w]]]=q0w
set rb[q0w]=ZS[ub[q0w]]
endif
set ZS[ub[q0w]]=q0w
set Lb=Lb-1-1
set e0w=null
return true
endfunction
function Pxw takes nothing returns boolean
set Lb=0
return n0w("RangeChecks, line 1")
endfunction
function Q1 takes nothing returns nothing
set ac=ac+0.030
endfunction
function QK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function QQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988559,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989064,0)
endfunction
function v2 takes string d2 returns boolean
local playerunitevent f2
local playerunitevent R2
local integer T2
local integer Y2
local integer G2
local integer g2
local integer h2
local integer F2
local integer k2
local integer j2
local integer x2
set Xb[Lb]=d2
set Lb=Lb+1
set Wc=wlw("when calling new_HashMap in MassControl, line 7")
set T2=R2I(500000)
set Y2=R2I(700000)
set G2=R2I(1000000)
set Xb[Lb]="when calling asList in MassControl, line 8"
set Lb=Lb+1
set g2=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(g2,T2,"when calling add in LinkedList, line 393")
call jfw(g2,Y2,"when calling add in LinkedList, line 393")
call jfw(g2,G2,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ec=g2
set Xb[Lb]="when calling asList in MassControl, line 14"
set Lb=Lb+1
set h2=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(h2,1211118401,"when calling add in LinkedList, line 393")
call jfw(h2,1211119699,"when calling add in LinkedList, line 393")
call jfw(h2,1211119701,"when calling add in LinkedList, line 393")
call jfw(h2,1211119700,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Zc=h2
set f2=EVENT_PLAYER_UNIT_SPELL_CAST
set Xb[Lb]="when calling alloc_MassControl_EventListener_line22 in MassControl, line 22"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set F2=iO
set SO[F2]=670
else
call x1("Out of memory: Could not create MassControl_EventListener_line22.","when calling error in MassControl, line 22")
set F2=0
endif
else
set tO=tO-1
set F2=sO[tO]
set SO[F2]=670
endif
set Lb=Lb-1
set ub[F2]=0
set rb[F2]=0
set sb[F2]=0
set Xb[Lb]="when calling add in MassControl, line 22"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set k2=mS[GetHandleId(f2)]
if k2==0 then
set k2=QV(f2,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[F2]=k2
if ZS[ub[F2]]!=0 then
set sb[ZS[ub[F2]]]=F2
set rb[F2]=ZS[ub[F2]]
endif
set ZS[ub[F2]]=F2
set Lb=Lb-1
set R2=EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER
set Xb[Lb]="when calling alloc_MassControl_EventListener_line32 in MassControl, line 32"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set j2=iO
set SO[j2]=671
else
call x1("Out of memory: Could not create MassControl_EventListener_line32.","when calling error in MassControl, line 32")
set j2=0
endif
else
set tO=tO-1
set j2=sO[tO]
set SO[j2]=671
endif
set Lb=Lb-1
set ub[j2]=0
set rb[j2]=0
set sb[j2]=0
set Xb[Lb]="when calling add in MassControl, line 32"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set x2=mS[GetHandleId(R2)]
if x2==0 then
set x2=QV(R2,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[j2]=x2
if ZS[ub[j2]]!=0 then
set sb[ZS[ub[j2]]]=j2
set rb[j2]=ZS[ub[j2]]
endif
set ZS[ub[j2]]=j2
set Lb=Lb-1-1
set f2=null
set R2=null
return true
endfunction
function Qxw takes nothing returns boolean
set Lb=0
return v2("MassControl, line 1")
endfunction
function RA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990595,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990608,0)
endfunction
function fI takes nothing returns boolean
if GetResearched()!=1378890036 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890036,true)!=1 then
return false
endif
return true
endfunction
function RI takes nothing returns boolean
if not fI() then
return false
endif
return true
endfunction
function RJ takes nothing returns nothing
call UnitAddAbility(GetConstructedStructure(),1093677896)
endfunction
function Rm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988567,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988564,0)
endfunction
function lC takes string XX returns boolean
local trigger CX
local playerunitevent VX
local playerunitevent BX
local integer NX
local integer MX
local player wC
local location uC
local real rC
local integer sC
local integer tC
local trigger iC
local playerunitevent SC
local integer cC
local integer oC
local integer OC
set Xb[Lb]=XX
set Lb=Lb+1
if hc then
set NX=5
set MX=1747988553
set wC=uo[0]
set uC=Location(-3000.0,1700.0)
set rC=0.
call GroupClear(bj_lastCreatedGroup)
loop
set NX=NX-1
exitwhen NX<0
call CreateUnitAtLocSaveLast(wC,MX,uC,rC)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
endif
set VX=EVENT_PLAYER_UNIT_SELECTED
set Xb[Lb]="when calling alloc_CityManage_EventListener_line9 in CityManage, line 9"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set sC=iO
set SO[sC]=664
else
call x1("Out of memory: Could not create CityManage_EventListener_line9.","when calling error in CityManage, line 9")
set sC=0
endif
else
set tO=tO-1
set sC=sO[tO]
set SO[sC]=664
endif
set Lb=Lb-1
set ub[sC]=0
set rb[sC]=0
set sb[sC]=0
set Xb[Lb]="when calling add in CityManage, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set tC=mS[GetHandleId(VX)]
if tC==0 then
set tC=QV(VX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[sC]=tC
if ZS[ub[sC]]!=0 then
set sb[ZS[ub[sC]]]=sC
set rb[sC]=ZS[ub[sC]]
endif
set ZS[ub[sC]]=sC
set Lb=Lb-1
set CX=CreateTrigger()
call TriggerAddCondition(CX,Condition(vf))
call TriggerAddAction(CX,mf)
set iC=CX
set SC=EVENT_PLAYER_UNIT_SPELL_CAST
set cC=0
loop
call TriggerRegisterPlayerUnitEvent(iC,Player(cC),SC,null)
set cC=cC+1
exitwhen cC==bj_MAX_PLAYER_SLOTS
endloop
set BX=EVENT_PLAYER_UNIT_ATTACKED
set Xb[Lb]="when calling alloc_CityManage_EventListener_line34 in CityManage, line 34"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set oC=iO
set SO[oC]=663
else
call x1("Out of memory: Could not create CityManage_EventListener_line34.","when calling error in CityManage, line 34")
set oC=0
endif
else
set tO=tO-1
set oC=sO[tO]
set SO[oC]=663
endif
set Lb=Lb-1
set ub[oC]=0
set rb[oC]=0
set sb[oC]=0
set Xb[Lb]="when calling add in CityManage, line 34"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set OC=mS[GetHandleId(BX)]
if OC==0 then
set OC=QV(BX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[oC]=OC
if ZS[ub[oC]]!=0 then
set sb[ZS[ub[oC]]]=oC
set rb[oC]=ZS[ub[oC]]
endif
set ZS[ub[oC]]=oC
set Lb=Lb-1-1
set CX=null
set VX=null
set BX=null
set wC=null
set uC=null
set iC=null
set SC=null
return true
endfunction
function Rxw takes nothing returns boolean
set Lb=0
return lC("CityManage, line 1")
endfunction
function S0w takes nothing returns boolean
return true
endfunction
function SA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651855,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651851,0)
endfunction
function iI takes nothing returns boolean
if GetResearched()!=1378889797 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=1 then
return false
endif
return true
endfunction
function SI takes nothing returns boolean
if not iI() then
return false
endif
return true
endfunction
function SJ takes nothing returns nothing
local integer MH=1
local integer wJ=1751343475
local player uJ=GetOwningPlayer(GetTriggerUnit())
local rect iJ=bj_mapInitialPlayableArea
local location tJ=Location(GetRectCenterX(iJ),GetRectCenterY(iJ))
local location rJ=Location(GetLocationX(tJ)+100000000.00,GetLocationY(tJ)+100000000.00)
local real sJ=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set MH=MH-1
exitwhen MH<0
call CreateUnitAtLocSaveLast(uJ,wJ,rJ,sJ)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set uJ=null
set rJ=null
set tJ=null
set iJ=null
endfunction
function Sm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988565,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988563,0)
endfunction
function Sv takes nothing returns nothing
call SetMapFlag(MAP_LOCK_RESOURCE_TRADING,false)
endfunction
function Svw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 293"
set Lb=Lb+1
call sB("when calling generalEventCallback in ClosureEvents, line 293")
set Lb=Lb-1
endfunction
function Sxw takes nothing returns boolean
set Lb=0
set Xb[Lb]="ObjectIdGenerator, line 1"
set Lb=Lb+1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 7"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call x1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 8"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call x1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call x1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 10"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call x1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 11"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call x1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 12"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if cl==0 then
if ol<32768 then
set ol=ol+1
else
call x1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set cl=cl-1
endif
set Lb=Lb-1-1-1
return true
endfunction
function TH takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988553 then
return false
endif
return true
endfunction
function TI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989836,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989837,0)
endfunction
function RP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function TP takes nothing returns boolean
if not RP() then
return false
endif
return true
endfunction
function RZ takes nothing returns boolean
if GetResearched()!=1378889810 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889810,true)!=1 then
return false
endif
return true
endfunction
function TZ takes nothing returns boolean
if not RZ() then
return false
endif
return true
endfunction
function fx takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747990581 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990580 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989813 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747988569 then
return true
endif
return false
endfunction
function Rx takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989048 then
return false
endif
if not fx() then
return false
endif
return true
endfunction
function Tx takes nothing returns boolean
if not Rx() then
return false
endif
return true
endfunction
function Nsw takes string Psw,string Asw,real Dsw,real Hsw,real Jsw,integer Ksw,real Lsw,real Xsw,boolean Csw,string Vsw returns integer
local integer Bsw
set Xb[Lb]=Vsw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_CityModifierClass in CityModifiers, line 37"
set Lb=Lb+1
if oO==0 then
if OO<32768 then
set OO=OO+1
set Bsw=OO
else
call x1("Out of memory: Could not create CityModifierClass.","when calling error in CityModifiers, line 26")
set Bsw=0
endif
else
set oO=oO-1
set Bsw=cO[oO]
endif
set Lb=Lb-1
set Rl[Bsw]=Dsw
set Tl[Bsw]=Xsw
set Yl[Bsw]=Csw
set Gl[Bsw]=Hsw
set gl[Bsw]=Ksw
set hl[Bsw]=Lsw
set Fl[Bsw]=Jsw
set kl[Bsw]=Psw
set jl[Bsw]=Asw
set Lb=Lb-1
return Bsw
endfunction
function LC takes string vC returns boolean
local integer mC
local integer QC
local integer WC
local integer EC
local integer ZC
local integer UC
local integer IC
local integer PC
local integer AC
local integer DC
local integer HC
local integer JC
local integer KC
set Xb[Lb]=vC
set Lb=Lb+1
set QC=R2I(0.5)
set WC=R2I(1)
set Xb[Lb]="when calling asList in CityModifiers, line 7"
set Lb=Lb+1
set EC=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(EC,QC,"when calling add in LinkedList, line 393")
call jfw(EC,WC,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set cS[0]=EC
set ZC=R2I(1)
set UC=R2I(3)
set Xb[Lb]="when calling asList in CityModifiers, line 8"
set Lb=Lb+1
set IC=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(IC,ZC,"when calling add in LinkedList, line 393")
call jfw(IC,UC,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set cS[1]=IC
set PC=R2I(3)
set AC=R2I(10)
set Xb[Lb]="when calling asList in CityModifiers, line 9"
set Lb=Lb+1
set DC=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(DC,PC,"when calling add in LinkedList, line 393")
call jfw(DC,AC,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set cS[2]=DC
set HC=R2I(10)
set JC=R2I(20)
set Xb[Lb]="when calling asList in CityModifiers, line 10"
set Lb=Lb+1
set KC=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(KC,HC,"when calling add in LinkedList, line 393")
call jfw(KC,JC,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set cS[3]=KC
set oS=Nsw("|cffff0000Just conquered|r","|cffc00000-PO -pop|r",240,1.0,0.0,1,-1.0,-30.0,false,"when calling new_CityModifierClass in CityModifiers, line 68")
set OS=Nsw("|cfffffb00Just revolted|r","|cff00af00+PO|r|cffc00000 -pop|r",120.0,1.0,0.0,0,0.,30.0,false,"when calling new_CityModifierClass in CityModifiers, line 76")
set lS=Nsw("|cff33ff00Population Boom|r","|cff33ff00++pop|r",120.0,0.01,0.,0,0.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 84")
set bS=Nsw("|cffff0000Plague outburst|r","|cffff0000--pop|r",240,0.03,0.,2,-1.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 92")
set yS=Nsw("|cffaf0000Big Fire|r","|cffc00000-pop|r",30,0.01,0.,2,-1.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 100")
set pS=Nsw("|cff15ff00More trade estabilished|r","|cff00af00+tax +pop|r",240,0.01,0.15,0,1.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 108")
set eS=Nsw("|cffff0000Massacred population|r","|cff00af00+PO |r|cffff0000--pop|r",30,0.05,0.,3,-1.,10.,true,"when calling new_CityModifierClass in CityModifiers, line 116")
set qS=Nsw("|cff00ff00Prospering|r","|cff00af00+PO +pop +tax|r",240,0.01,0.10,1,1.,20.0,true,"when calling new_CityModifierClass in CityModifiers, line 124")
set aS=Nsw("|cffff0000Sieged|r","|cffc00000-PO -pop|r",5,1.0,0.,0,-1.,-10.0,true,"when calling new_CityModifierClass in CityModifiers, line 132")
set nS=wlw("when calling new_HashMap in CityModifiers, line 142")
set mC=nS
call idw(mC,0,oS,"when calling put in CityModifiers, line 149")
call idw(mC,1,OS,"when calling put in CityModifiers, line 150")
call idw(mC,2,lS,"when calling put in CityModifiers, line 151")
call idw(mC,3,bS,"when calling put in CityModifiers, line 152")
call idw(mC,4,yS,"when calling put in CityModifiers, line 153")
call idw(mC,5,pS,"when calling put in CityModifiers, line 154")
call idw(mC,6,eS,"when calling put in CityModifiers, line 155")
call idw(mC,7,qS,"when calling put in CityModifiers, line 156")
call idw(mC,8,aS,"when calling put in CityModifiers, line 157")
set Lb=Lb-1
return true
endfunction
function Txw takes nothing returns boolean
set Lb=0
return LC("CityModifiers, line 1")
endfunction
function ZL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990086 then
return false
endif
return true
endfunction
function UL takes nothing returns boolean
if not ZL() then
return false
endif
return true
endfunction
function UP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990594,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990584,0)
endfunction
function ZU takes nothing returns boolean
if GetResearched()!=1378890034 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890034,true)!=2 then
return false
endif
return true
endfunction
function UU takes nothing returns boolean
if not ZU() then
return false
endif
return true
endfunction
function ZW takes nothing returns boolean
if GetResearched()!=1378889783 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889783,true)!=2 then
return false
endif
return true
endfunction
function UW takes nothing returns boolean
if not ZW() then
return false
endif
return true
endfunction
function UZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651832,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651830,0)
endfunction
function Uj takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988791 then
return false
endif
return true
endfunction
function Ek takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function Zk takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988793 then
return false
endif
if not Ek() then
return false
endif
return true
endfunction
function Uk takes nothing returns boolean
if not Zk() then
return false
endif
return true
endfunction
function Uv takes nothing returns nothing
local player hv=GetOwningPlayer(GetKillingUnit())
local playerstate Fv=PLAYER_STATE_RESOURCE_LUMBER
local playerstate kv
local playerstate jv
local player xv
local force vv
local location mv
local real Qv
local real Wv
local player Ev
local force Zv
if Fv==PLAYER_STATE_RESOURCE_GOLD then
set kv=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(hv,kv,GetPlayerState(hv,kv)+500)
elseif Fv==PLAYER_STATE_RESOURCE_LUMBER then
set jv=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(hv,jv,GetPlayerState(hv,jv)+500)
endif
call SetPlayerState(hv,Fv,GetPlayerState(hv,Fv)+500)
set xv=GetOwningPlayer(GetKillingUnit())
set vv=CreateForce()
call ForceAddPlayer(vv,xv)
if IsPlayerInForce(GetLocalPlayer(),vv) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_084")
endif
set y=GetUnitLoc(GetDyingUnit())
set Ev=GetOwningPlayer(GetDyingUnit())
set Zv=CreateForce()
call ForceAddPlayer(Zv,Ev)
set mv=y
set Qv=GetLocationX(mv)
set Wv=GetLocationY(mv)
if IsPlayerInForce(GetLocalPlayer(),Zv) then
call PingMinimap(Qv,Wv,2.00)
endif
call RemoveLocation(y)
set hv=null
set Fv=null
set kv=null
set jv=null
set xv=null
set vv=null
set mv=null
set Ev=null
set Zv=null
endfunction
function Uww takes nothing returns boolean
return true
endfunction
function n9 takes string p9 returns boolean
local playerevent e9
local integer q9
local integer a9
set Xb[Lb]=p9
set Lb=Lb+1
set e9=EVENT_PLAYER_LEAVE
set Xb[Lb]="when calling alloc_OnPlayerLeave_EventListener_line5 in OnPlayerLeave, line 5"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set q9=iO
set SO[q9]=674
else
call x1("Out of memory: Could not create OnPlayerLeave_EventListener_line5.","when calling error in OnPlayerLeave, line 5")
set q9=0
endif
else
set tO=tO-1
set q9=sO[tO]
set SO[q9]=674
endif
set Lb=Lb-1
set ub[q9]=0
set rb[q9]=0
set sb[q9]=0
set Xb[Lb]="when calling add in OnPlayerLeave, line 5"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set a9=mS[GetHandleId(e9)]
if a9==0 then
set a9=QV(e9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[q9]=a9
if ZS[ub[q9]]!=0 then
set sb[ZS[ub[q9]]]=q9
set rb[q9]=ZS[ub[q9]]
endif
set ZS[ub[q9]]=q9
set Lb=Lb-1-1
set e9=null
return true
endfunction
function Uxw takes nothing returns boolean
set Lb=0
return n9("OnPlayerLeave, line 1")
endfunction
function CA takes nothing returns boolean
if GetResearched()!=1378890052 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890052,true)!=1 then
return false
endif
return true
endfunction
function VA takes nothing returns boolean
if not CA() then
return false
endif
return true
endfunction
function VI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989815,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989816,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989825,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989814,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989830,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651844,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989833,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989832,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989835,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989836,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651848,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651846,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989828,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989826,0)
endfunction
function CJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990352 then
return false
endif
return true
endfunction
function VJ takes nothing returns boolean
if not CJ() then
return false
endif
return true
endfunction
function VW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990097,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989594,0)
endfunction
function s4 takes string r4 returns boolean
set Xb[Lb]=r4
set Lb=Lb+1
set Xb[Lb]="when calling alloc_LinkedList_Comparator_line504 in LinkedList, line 504"
set Lb=Lb+1
if DO==0 then
if HO<32768 then
set HO=HO+1
else
call x1("Out of memory: Could not create LinkedList_Comparator_line504.","when calling error in LinkedList, line 504")
endif
else
set DO=DO-1
endif
set Lb=Lb-1
set Xb[Lb]="when calling alloc_LinkedList_Comparator_line508 in LinkedList, line 508"
set Lb=Lb+1
if DO==0 then
if HO<32768 then
set HO=HO+1
else
call x1("Out of memory: Could not create LinkedList_Comparator_line508.","when calling error in LinkedList, line 508")
endif
else
set DO=DO-1
endif
set Lb=Lb-1-1
return true
endfunction
function Vjw takes nothing returns boolean
set Lb=0
return s4("LinkedList, line 1")
endfunction
function Cm takes nothing returns boolean
if GetResearched()!=1378889798 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889798,true)!=2 then
return false
endif
return true
endfunction
function Vm takes nothing returns boolean
if not Cm() then
return false
endif
return true
endfunction
function Vrw takes nothing returns boolean
return true
endfunction
function nrw takes nothing returns integer
local integer yrw=0
local integer prw=0
local integer erw=23
local player qrw
local boolean arw
loop
exitwhen prw>erw
set qrw=uo[prw]
if GetPlayerSlotState(qrw)==PLAYER_SLOT_STATE_PLAYING then
set arw=GetPlayerController(qrw)==MAP_CONTROL_USER
else
set arw=false
endif
if arw then
set yrw=yrw+1
endif
set prw=prw+1
endloop
set qrw=null
return R2I((yrw-1)*1./2)+1
endfunction
function Grw takes integer drw returns nothing
local string frw
local force Rrw
local string Trw
local force Yrw
if drw<0 then
set Rrw=null
set Yrw=null
return
endif
if uO[drw]>=nrw() then
call CustomDefeatBJ(uo[drw],"You've been kicked from the game!")
set frw="The player "+UB(uo[drw])+" has been kicked with the power of democracy!"
set Rrw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),Rrw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,frw)
endif
else
set Trw=I2S(uO[drw])+" |cffff0000out of|r "+I2S(nrw())+" |cffff0000voted to kick the player|r "+UB(uo[drw])+"! |cff00ffdd(player number is "+I2S(drw)+")|r"
set Yrw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),Yrw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,Trw)
endif
endif
set Rrw=null
set Yrw=null
endfunction
function Wrw takes integer jrw,player xrw,string vrw returns nothing
local integer mrw
local integer Qrw
set Xb[Lb]=vrw
set Lb=Lb+1
if jrw<0 then
set Lb=Lb-1
return
endif
if not Cnw(rO[jrw],GetPlayerId(xrw),"when calling has in VoteKick, line 44") then
set uO[jrw]=uO[jrw]+1
set mrw=rO[jrw]
set Qrw=GetPlayerId(xrw)
set Xb[Lb]="when calling add in VoteKick, line 46"
set Lb=Lb+1
if ZO[mrw]==0 then
if mrw==0 then
call x1("Nullpointer exception when calling HashSet.add","when calling error in HashSet, line 9")
else
call x1("Called HashSet.add on invalid object.","when calling error in HashSet, line 9")
endif
endif
call Ujw(mrw,Qrw,"when calling add in HashSet, line 9")
set Lb=Lb-1
endif
set Lb=Lb-1
endfunction
function krw takes string grw returns integer
local integer hrw=0
local integer Frw=23
loop
exitwhen hrw>Frw
if GetPlayerName(uo[hrw])==grw then
return hrw
endif
set hrw=hrw+1
endloop
return -1
endfunction
function lbw takes integer Sbw,integer cbw returns integer
local integer obw=Tb[Fb[Sbw]]
local integer Obw=0
loop
exitwhen obw==Fb[Sbw]
if fb[obw]==cbw then
return Obw
endif
set obw=Tb[obw]
set Obw=Obw+1
endloop
return -1
endfunction
function Crw takes player Erw,string Zrw,string Urw returns nothing
local integer Irw
local integer Prw
local integer Arw
local boolean Drw
local integer Hrw
local integer Jrw
local integer Krw
local boolean Lrw
local boolean Xrw
set Xb[Lb]=Urw
set Lb=Lb+1
if StringLength(Zrw)<=2 then
set Lrw=S2I(Zrw)>0
else
set Lrw=false
endif
if Lrw then
set Xrw=S2I(Zrw)<24
else
set Xrw=false
endif
if Xrw then
set Irw=S2I(Zrw)
else
set Prw=MS
set Arw=Tww(Zrw,"when calling stringToIndex in VoteKick, line 54")
set Xb[Lb]="when calling has in VoteKick, line 54"
set Lb=Lb+1
if Sl[Prw]==0 then
if Prw==0 then
call x1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call x1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Drw=ebw(Prw,Arw)
set Lb=Lb-1
if Drw then
set Hrw=MS
set Jrw=Tww(Zrw,"when calling stringToIndex in VoteKick, line 55")
set Xb[Lb]="when calling indexOf in VoteKick, line 55"
set Lb=Lb+1
if Sl[Hrw]==0 then
if Hrw==0 then
call x1("Nullpointer exception when calling LinkedList.indexOf","when calling error in LinkedList, line 54")
else
call x1("Called LinkedList.indexOf on invalid object.","when calling error in LinkedList, line 54")
endif
endif
set Krw=lbw(Hrw,Jrw)
set Lb=Lb-1
set Irw=Krw
elseif krw(Zrw)!=-1 then
set Irw=krw(Zrw)
else
set Xb[Lb]="when calling noteToPlayer in VoteKick, line 59"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Erw,0.,0.,10.0,t5(Erw,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(Erw,0.,0.,10.0,"Couldn't find player: '"+Zrw+"'")
set Lb=Lb-1-1
return
endif
endif
call Wrw(Irw,Erw,"when calling addVote in VoteKick, line 62")
call Grw(Irw)
set Lb=Lb-1
endfunction
function aaw takes integer paw,string eaw,string qaw returns nothing
set Xb[Lb]=qaw
set Lb=Lb+1
if pO[paw]==0 then
if paw==0 then
call x1("Nullpointer exception when calling City.changeCityName","when calling error in City, line 171")
else
call x1("Called City.changeCityName on invalid object.","when calling error in City, line 171")
endif
endif
set Xb[Lb]="when calling changeCityName in City, line 171"
set Lb=Lb+1
set vl[paw]=SubString(eaw,0,24)
set Xb[Lb]="when calling refreshMultiboardIfPossible in City, line 174"
set Lb=Lb+1
if pO[paw]==0 then
if paw==0 then
call x1("Nullpointer exception when calling City.refreshMultiboardIfPossible","when calling error in City, line 250")
else
call x1("Called City.refreshMultiboardIfPossible on invalid object.","when calling error in City, line 250")
endif
endif
call qtw(paw,"when calling refreshMultiboardIfPossible in City, line 250")
set Lb=Lb-1-1-1
endfunction
function jX takes string nX,string dX returns string
local integer fX
local integer RX
local integer TX
local integer YX
local integer GX
local boolean gX
local integer hX
local integer FX
local integer kX
set Xb[Lb]=dX
set Lb=Lb+1
set fX=0
set RX=23
loop
exitwhen fX>RX
if nX==GetPlayerName(uo[fX]) then
set Lb=Lb-1
return tS[fX]
endif
set fX=fX+1
endloop
set YX=MS
set GX=Tww(nX,"when calling stringToIndex in BNetName, line 26")
set Xb[Lb]="when calling has in BNetName, line 26"
set Lb=Lb+1
if Sl[YX]==0 then
if YX==0 then
call x1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call x1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set gX=ebw(YX,GX)
set Lb=Lb-1
if gX then
set hX=MS
set FX=Tww(nX,"when calling stringToIndex in BNetName, line 27")
set Xb[Lb]="when calling indexOf in BNetName, line 27"
set Lb=Lb+1
if Sl[hX]==0 then
if hX==0 then
call x1("Nullpointer exception when calling LinkedList.indexOf","when calling error in LinkedList, line 54")
else
call x1("Called LinkedList.indexOf on invalid object.","when calling error in LinkedList, line 54")
endif
endif
set kX=lbw(hX,FX)
set Lb=Lb-1
set dX=tS[kX]
set Lb=Lb-1
return dX
endif
set TX=S2I(nX)
if TX>=0 and TX<24 then
set Lb=Lb-1
return tS[TX]
endif
set Lb=Lb-1
return ""
endfunction
function q2 takes player b2 returns nothing
local fogstate y2
local location p2
local rect e2
call SetPlayerState(b2,PLAYER_STATE_RESOURCE_GOLD,99999999)
call SetPlayerState(b2,PLAYER_STATE_RESOURCE_LUMBER,99999999)
set y2=FOG_OF_WAR_VISIBLE
set e2=bj_mapInitialPlayableArea
set p2=Location(GetRectCenterX(e2),GetRectCenterY(e2))
set bj_lastCreatedFogModifier=CreateFogModifierRadiusLoc(b2,y2,p2,999999.00,true,false)
call FogModifierStart(bj_lastCreatedFogModifier)
set y2=null
set p2=null
set e2=null
endfunction
function xew takes integer pew,string eew returns nothing
local integer qew
local integer aew
local integer dew
local integer few
local player Rew
local integer Tew
local integer Yew
local player Gew
local integer gew
local player hew
local fogstate Few
local location kew
local rect jew
set Xb[Lb]=eew
set Lb=Lb+1
set Hb[pew]=true
set qew=GetPlayerId(Ib[pew])
set aew=0
set dew=23
loop
exitwhen aew>dew
set few=wo[aew]
set Rew=Ib[pew]
set Tew=bj_ALLIANCE_UNALLIED
set Xb[Lb]="when calling setAlliance in PlayerStats, line 37"
set Lb=Lb+1
if yl[few]==0 then
if few==0 then
call x1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call x1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Zew(few,Rew,Tew,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set Yew=wo[qew]
set Gew=uo[aew]
set gew=bj_ALLIANCE_UNALLIED
set eew="when calling setAlliance in PlayerStats, line 38"
set Xb[Lb]="when calling setAlliance in PlayerStats, line 38"
set Lb=Lb+1
if yl[Yew]==0 then
if Yew==0 then
call x1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call x1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call Zew(Yew,Gew,gew,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set aew=aew+1
endloop
set hew=Ib[pew]
set Few=FOG_OF_WAR_VISIBLE
set jew=bj_mapInitialPlayableArea
set kew=Location(GetRectCenterX(jew),GetRectCenterY(jew))
set bj_lastCreatedFogModifier=CreateFogModifierRadiusLoc(hew,Few,kew,999999.00,true,false)
call FogModifierStart(bj_lastCreatedFogModifier)
set Lb=Lb-1
set Rew=null
set Gew=null
set hew=null
set Few=null
set kew=null
set jew=null
endfunction
function tM takes string SN returns nothing
local string array cN
local string oN
local player ON
local integer lN
local integer bN
local integer yN
local string pN
local string eN
local integer qN
local boolean aN
local group nN
local string dN
local player fN
local camerafield RN
local player TN
local camerafield YN
local integer GN
local integer gN
local integer hN
local unit FN
local integer kN
local integer jN
local integer xN
local integer vN
local integer mN
local integer QN
local integer WN
local integer EN
local integer ZN
local integer UN
local integer IN
local player PN
local camerafield AN
local real DN
local integer HN
local boolean JN
local group KN
local unit LN
local integer XN
local string CN
local force VN
local integer BN
local integer NN
local integer MN
local real wM
local boolean uM
local boolean rM
local boolean sM
set Xb[Lb]=SN
set Lb=Lb+1
set SN=GetEventPlayerChatString()
set oN=""
set ON=GetTriggerPlayer()
set lN=0
set bN=1
set yN=StringLength(SN)
loop
exitwhen bN>yN
set pN=SubString(SN,bN,bN+1)
if lN>0 then
set uM=bN>StringLength(cN[0])+1
else
set uM=false
endif
if uM then
set oN=oN+pN
endif
if pN!=" " then
set cN[lN]=cN[lN]+pN
else
set lN=lN+1
endif
set bN=bN+1
endloop
if cN[0]=="far" then
set fN=GetTriggerPlayer()
set RN=CAMERA_FIELD_TARGET_DISTANCE
if GetLocalPlayer()==fN then
call SetCameraField(RN,3000.0,0.)
endif
elseif cN[0]=="med" then
set TN=GetTriggerPlayer()
set YN=CAMERA_FIELD_TARGET_DISTANCE
if GetLocalPlayer()==TN then
call SetCameraField(YN,2300.0,0.)
endif
elseif cN[0]=="name" then
call SetPlayerName(GetTriggerPlayer(),SubString(oN,0,40))
elseif cN[0]=="rename" then
set GN=wo[GetPlayerId(ON)]
set Xb[Lb]="when calling getSelectedCityId in Commands, line 53"
set Lb=Lb+1
if yl[GN]==0 then
if GN==0 then
call x1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call x1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set gN=Ab[GN]
set Lb=Lb-1
if gN>=0 and gN<dS then
set hN=FS[gN]
set Xb[Lb]="when calling getCityUnit in Commands, line 55"
set Lb=Lb+1
if pO[hN]==0 then
if hN==0 then
call x1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call x1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set FN=xl[hN]
set Lb=Lb-1
if GetOwningPlayer(FN)!=ON then
set Xb[Lb]="when calling noteToPlayer in Commands, line 56"
set Lb=Lb+1
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,t5(ON,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,"The city you wanted to rename so eagerly doesn't belong to you!")
set Lb=Lb-1
else
call aaw(FS[gN],oN,"when calling changeCityName in Commands, line 58")
endif
endif
elseif cN[0]=="add_mod" then
set kN=wo[GetPlayerId(ON)]
set Xb[Lb]="when calling getSelectedCityId in Commands, line 60"
set Lb=Lb+1
if yl[kN]==0 then
if kN==0 then
call x1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call x1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set jN=Ab[kN]
set Lb=Lb-1
if not hc then
set Lb=Lb-1
set ON=null
set nN=null
set fN=null
set RN=null
set TN=null
set YN=null
set FN=null
set PN=null
set AN=null
set KN=null
set LN=null
set VN=null
return
endif
if jN>=0 and jN<dS then
set eN=cN[1]
if eN=="massacred_pop" then
set xN=FS[jN]
set Xb[Lb]="when calling addModifier in Commands, line 66"
set Lb=Lb+1
if pO[xN]==0 then
if xN==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(xN,6,"when calling addModifier in City, line 368")
set Lb=Lb-1
elseif eN=="recently_conquered" then
set vN=FS[jN]
set Xb[Lb]="when calling addModifier in Commands, line 68"
set Lb=Lb+1
if pO[vN]==0 then
if vN==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(vN,0,"when calling addModifier in City, line 368")
set Lb=Lb-1
elseif eN=="recently_revolted" then
set mN=FS[jN]
set Xb[Lb]="when calling addModifier in Commands, line 70"
set Lb=Lb+1
if pO[mN]==0 then
if mN==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(mN,1,"when calling addModifier in City, line 368")
set Lb=Lb-1
elseif eN=="more_trade_estabilished" then
set QN=FS[jN]
set Xb[Lb]="when calling addModifier in Commands, line 72"
set Lb=Lb+1
if pO[QN]==0 then
if QN==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(QN,5,"when calling addModifier in City, line 368")
set Lb=Lb-1
elseif eN=="on_fire" then
set WN=FS[jN]
set Xb[Lb]="when calling addModifier in Commands, line 74"
set Lb=Lb+1
if pO[WN]==0 then
if WN==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(WN,4,"when calling addModifier in City, line 368")
set Lb=Lb-1
elseif eN=="plague_outburst" then
set EN=FS[jN]
set Xb[Lb]="when calling addModifier in Commands, line 76"
set Lb=Lb+1
if pO[EN]==0 then
if EN==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(EN,3,"when calling addModifier in City, line 368")
set Lb=Lb-1
elseif eN=="population_boom" then
set ZN=FS[jN]
set Xb[Lb]="when calling addModifier in Commands, line 78"
set Lb=Lb+1
if pO[ZN]==0 then
if ZN==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(ZN,2,"when calling addModifier in City, line 368")
set Lb=Lb-1
elseif eN=="prospering" then
set UN=FS[jN]
set Xb[Lb]="when calling addModifier in Commands, line 80"
set Lb=Lb+1
if pO[UN]==0 then
if UN==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(UN,7,"when calling addModifier in City, line 368")
set Lb=Lb-1
elseif eN=="sieged" then
set IN=FS[jN]
set Xb[Lb]="when calling addModifier in Commands, line 82"
set Lb=Lb+1
if pO[IN]==0 then
if IN==0 then
call x1("Nullpointer exception when calling City.addModifier","when calling error in City, line 368")
else
call x1("Called City.addModifier on invalid object.","when calling error in City, line 368")
endif
endif
call ctw(IN,8,"when calling addModifier in City, line 368")
set Lb=Lb-1
endif
endif
elseif cN[0]=="" then
set hc=not hc
set gc=not gc
call q2(ON)
elseif cN[0]=="votekick" then
call Crw(ON,oN,"when calling voteKick in Commands, line 88")
elseif cN[0]=="zoom" then
set qN=S2I(cN[1])
set PN=GetTriggerPlayer()
set AN=CAMERA_FIELD_TARGET_DISTANCE
set DN=qN*1.
if GetLocalPlayer()==PN then
call SetCameraField(AN,DN,0.)
endif
elseif cN[0]=="observe" then
set HN=wo[GetPlayerId(ON)]
set Xb[Lb]="when calling isObserver in Commands, line 93"
set Lb=Lb+1
if yl[HN]==0 then
if HN==0 then
call x1("Nullpointer exception when calling PlayerStats.isObserver","when calling error in PlayerStats, line 29")
else
call x1("Called PlayerStats.isObserver on invalid object.","when calling error in PlayerStats, line 29")
endif
endif
set JN=Hb[HN]
set Lb=Lb-1
if not JN then
set aN=true
set KN=CreateGroup()
call GroupEnumUnitsOfPlayer(KN,ON,null)
call DestroyBoolExpr(null)
set nc=CreateGroup()
call ForGroup(KN,Pf)
set nN=nc
loop
exitwhen FirstOfGroup(nN)==null
set LN=FirstOfGroup(nN)
call GroupRemoveUnit(nN,LN)
if not IsUnitHidden(LN) then
set rM=GetUnitTypeId(LN)!=1211118391
else
set rM=false
endif
if rM then
set sM=GetUnitTypeId(LN)!=1211118406
else
set sM=false
endif
if sM then
set aN=false
endif
endloop
call GroupClear(nN)
call DestroyGroup(nN)
if aN then
set XN=wo[GetPlayerId(ON)]
set Xb[Lb]="when calling becomeObserver in Commands, line 100"
set Lb=Lb+1
if yl[XN]==0 then
if XN==0 then
call x1("Nullpointer exception when calling PlayerStats.becomeObserver","when calling error in PlayerStats, line 32")
else
call x1("Called PlayerStats.becomeObserver on invalid object.","when calling error in PlayerStats, line 32")
endif
endif
call xew(XN,"when calling becomeObserver in PlayerStats, line 32")
set Lb=Lb-1
set CN=UB(ON)+" has just became an observer."
set VN=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),VN) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,CN)
endif
else
set Xb[Lb]="when calling noteToPlayer in Commands, line 103"
set Lb=Lb+1
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,t5(ON,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,"To become an observer, you should have no units!")
set Lb=Lb-1
endif
endif
elseif cN[0]=="add_po" then
if not hc then
set Lb=Lb-1
set ON=null
set nN=null
set fN=null
set RN=null
set TN=null
set YN=null
set FN=null
set PN=null
set AN=null
set KN=null
set LN=null
set VN=null
return
endif
set BN=wo[GetPlayerId(ON)]
set Xb[Lb]="when calling getSelectedCityId in Commands, line 107"
set Lb=Lb+1
if yl[BN]==0 then
if BN==0 then
call x1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call x1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set NN=Ab[BN]
set Lb=Lb-1
if NN>=0 and NN<dS then
set MN=FS[NN]
set wM=S2R(cN[1])
set Xb[Lb]="when calling addPublicOrder in Commands, line 109"
set Lb=Lb+1
if pO[MN]==0 then
if MN==0 then
call x1("Nullpointer exception when calling City.addPublicOrder","when calling error in City, line 332")
else
call x1("Called City.addPublicOrder on invalid object.","when calling error in City, line 332")
endif
endif
set Dl[MN]=Dl[MN]+wM
set Lb=Lb-1
endif
elseif cN[0]=="bnet" then
set dN=jX(oN,"when calling getBNetName in Commands, line 111")
if dN=="" then
set Xb[Lb]="when calling noteToPlayer in Commands, line 113"
set Lb=Lb+1
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,t5(ON,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,"Couldn't find player: '"+oN+"'")
set Lb=Lb-1
else
set Xb[Lb]="when calling noteToPlayer in Commands, line 115"
set Lb=Lb+1
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,t5(ON,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,"The name of "+oN+" is "+dN)
set Lb=Lb-1
endif
else
set Xb[Lb]="when calling noteToPlayer in Commands, line 117"
set Lb=Lb+1
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,t5(ON,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(ON,0.,0.,10.0,"Couldn't find command: '"+cN[0]+"'")
set Lb=Lb-1
endif
set Lb=Lb-1
set ON=null
set nN=null
set fN=null
set RN=null
set TN=null
set YN=null
set FN=null
set PN=null
set AN=null
set KN=null
set LN=null
set VN=null
endfunction
function Vxw takes nothing returns nothing
set Lb=0
call tM("Commands, line 126")
endfunction
function QA takes nothing returns boolean
if GetResearched()!=1378890054 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890054,true)!=1 then
return false
endif
return true
endfunction
function WA takes nothing returns boolean
if not QA() then
return false
endif
return true
endfunction
function QJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990356 then
return false
endif
return true
endfunction
function WJ takes nothing returns boolean
if not QJ() then
return false
endif
return true
endfunction
function WT takes nothing returns nothing
call ReplaceUnitBJ(GetEnumUnit(),1747988553,bj_UNIT_STATE_METHOD_RELATIVE)
endfunction
function Qm takes nothing returns boolean
if GetResearched()!=1378889796 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889796,true)!=2 then
return false
endif
return true
endfunction
function Wm takes nothing returns boolean
if not Qm() then
return false
endif
return true
endfunction
function Wx takes nothing returns nothing
local player Yx=GetOwningPlayer(GetSpellTargetUnit())
local playerstate Gx=PLAYER_STATE_RESOURCE_LUMBER
local playerstate gx
local playerstate hx
local player Fx
local force kx
local location jx
local real xx
local real vx
local player mx
local force Qx
if Gx==PLAYER_STATE_RESOURCE_GOLD then
set gx=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Yx,gx,GetPlayerState(Yx,gx)+500)
elseif Gx==PLAYER_STATE_RESOURCE_LUMBER then
set hx=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Yx,hx,GetPlayerState(Yx,hx)+500)
endif
call SetPlayerState(Yx,Gx,GetPlayerState(Yx,Gx)+500)
call RemoveUnit(GetSpellAbilityUnit())
set Fx=GetOwningPlayer(GetSpellTargetUnit())
set kx=CreateForce()
call ForceAddPlayer(kx,Fx)
if IsPlayerInForce(GetLocalPlayer(),kx) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1232")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set mx=GetOwningPlayer(GetSpellTargetUnit())
set Qx=CreateForce()
call ForceAddPlayer(Qx,mx)
set jx=y
set xx=GetLocationX(jx)
set vx=GetLocationY(jx)
if IsPlayerInForce(GetLocalPlayer(),Qx) then
call PingMinimap(xx,vx,2.00)
endif
call RemoveLocation(y)
set Yx=null
set Gx=null
set gx=null
set hx=null
set Fx=null
set kx=null
set jx=null
set mx=null
set Qx=null
endfunction
function m5 takes string F5 returns boolean
local integer k5
local timer j5
local integer x5
local timer v5
set Xb[Lb]=F5
set Lb=Lb+1
set Xb[Lb]="when calling alloc_MultiboardCityUpdate_CallbackSingle_line18 in MultiboardCityUpdate, line 18"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set k5=RO
set TO[k5]=647
else
call x1("Out of memory: Could not create MultiboardCityUpdate_CallbackSingle_line18.","when calling error in MultiboardCityUpdate, line 18")
set k5=0
endif
else
set fO=fO-1
set k5=dO[fO]
set TO[k5]=647
endif
set Lb=Lb-1
set Xb[Lb]="when calling doAfter in MultiboardCityUpdate, line 18"
set Lb=Lb+1
set j5=Sww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(k5,j5,0.01,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1
set Xb[Lb]="when calling alloc_MultiboardCityUpdate_CallbackPeriodic_line25 in MultiboardCityUpdate, line 25"
set Lb=Lb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set x5=gO
set hO[x5]=637
else
call x1("Out of memory: Could not create MultiboardCityUpdate_CallbackPeriodic_line25.","when calling error in MultiboardCityUpdate, line 25")
set x5=0
endif
else
set GO=GO-1
set x5=YO[GO]
set hO[x5]=637
endif
set Lb=Lb-1
set Xb[Lb]="when calling doPeriodically in MultiboardCityUpdate, line 25"
set Lb=Lb+1
set v5=Sww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call enw(x5,v5,1.0,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set j5=null
set v5=null
return true
endfunction
function Wxw takes nothing returns boolean
set Lb=0
return m5("MultiboardCityUpdate, line 1")
endfunction
function X9 takes nothing returns boolean
set so=ConvertPlayerColor(24)
set io=ConvertPlayerColor(25)
set So=ConvertPlayerColor(26)
set co=ConvertPlayerColor(27)
set oo[0]=PLAYER_COLOR_RED
set oo[1]=PLAYER_COLOR_BLUE
set oo[2]=PLAYER_COLOR_CYAN
set oo[3]=PLAYER_COLOR_PURPLE
set oo[4]=PLAYER_COLOR_YELLOW
set oo[5]=PLAYER_COLOR_ORANGE
set oo[6]=PLAYER_COLOR_GREEN
set oo[7]=PLAYER_COLOR_PINK
set oo[8]=PLAYER_COLOR_LIGHT_GRAY
set oo[9]=PLAYER_COLOR_LIGHT_BLUE
set oo[10]=PLAYER_COLOR_AQUA
set oo[11]=PLAYER_COLOR_BROWN
set oo[12]=PLAYER_COLOR_MAROON
set oo[13]=PLAYER_COLOR_NAVY
set oo[14]=PLAYER_COLOR_TURQUOISE
set oo[15]=PLAYER_COLOR_VIOLET
set oo[16]=PLAYER_COLOR_WHEAT
set oo[17]=PLAYER_COLOR_PEACH
set oo[18]=PLAYER_COLOR_MINT
set oo[19]=PLAYER_COLOR_LAVENDER
set oo[20]=PLAYER_COLOR_COAL
set oo[21]=PLAYER_COLOR_SNOW
set oo[22]=PLAYER_COLOR_EMERALD
set oo[23]=PLAYER_COLOR_PEANUT
set oo[24]=so
set oo[25]=io
set oo[26]=So
set oo[27]=co
return true
endfunction
function LD takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())==1747989040 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747990361 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747989831 then
return true
endif
return false
endfunction
function XD takes nothing returns boolean
if e[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]!=false then
return false
endif
if not LD() then
return false
endif
return true
endfunction
function XE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989557,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989559,0)
endfunction
function LK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989060 then
return false
endif
return true
endfunction
function XK takes nothing returns boolean
if not LK() then
return false
endif
return true
endfunction
function LQ takes nothing returns boolean
if GetResearched()!=1378889801 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889801,true)!=1 then
return false
endif
return true
endfunction
function XQ takes nothing returns boolean
if not LQ() then
return false
endif
return true
endfunction
function XV takes nothing returns nothing
call TriggerRegisterUnitEvent(jS,Ho[Jo-1],EVENT_UNIT_DAMAGED)
endfunction
function initializeTable takes string stackPos returns nothing
local integer i_2
local integer this
local integer parentKey
set Xb[Lb]=stackPos
set Lb=Lb+1
set i_2=0
loop
exitwhen i_2>15
set this=NS
set parentKey=StringHash(BS[i_2])
set stackPos="when calling saveInt in Colors, line 206"
set Xb[Lb]="when calling saveInt in Colors, line 206"
set Lb=Lb+1
if AO[this]==0 then
if this==0 then
call x1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call x1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Eo,this,parentKey,i_2)
set Lb=Lb-1
set i_2=i_2+1
endloop
set Lb=Lb-1
endfunction
function jB takes string kB returns boolean
set Xb[Lb]=kB
set Lb=Lb+1
set XS[0]=255
set CS[0]=2
set VS[0]=2
set XS[1]=0
set CS[1]=65
set VS[1]=255
set XS[2]=27
set CS[2]=229
set VS[2]=184
set XS[3]=83
set CS[3]=0
set VS[3]=128
set XS[4]=255
set CS[4]=252
set VS[4]=0
set XS[5]=254
set CS[5]=137
set VS[5]=13
set XS[6]=31
set CS[6]=191
set VS[6]=0
set XS[7]=228
set CS[7]=90
set VS[7]=175
set XS[8]=148
set CS[8]=149
set VS[8]=150
set XS[9]=125
set CS[9]=190
set VS[9]=241
set XS[10]=15
set CS[10]=97
set VS[10]=69
set XS[11]=77
set CS[11]=41
set VS[11]=3
set XS[12]=155
set CS[12]=0
set VS[12]=0
set XS[13]=0
set CS[13]=0
set VS[13]=195
set XS[14]=0
set CS[14]=234
set VS[14]=255
set XS[15]=190
set CS[15]=0
set VS[15]=254
set XS[16]=235
set CS[16]=205
set VS[16]=135
set XS[17]=248
set CS[17]=164
set VS[17]=139
set XS[18]=191
set CS[18]=255
set VS[18]=128
set XS[19]=220
set CS[19]=185
set VS[19]=235
set XS[20]=40
set CS[20]=40
set VS[20]=40
set XS[21]=235
set CS[21]=240
set VS[21]=255
set XS[22]=0
set CS[22]=120
set VS[22]=30
set XS[23]=164
set CS[23]=11
set VS[23]=51
set BS[0]="0"
set BS[1]="1"
set BS[2]="2"
set BS[3]="3"
set BS[4]="4"
set BS[5]="5"
set BS[6]="6"
set BS[7]="7"
set BS[8]="8"
set BS[9]="9"
set BS[10]="A"
set BS[11]="B"
set BS[12]="C"
set BS[13]="D"
set BS[14]="E"
set BS[15]="F"
set NS=Yqw("when calling new_Table in Colors, line 154")
call initializeTable("when calling initializeTable in Colors, line 209")
set Lb=Lb-1
return true
endfunction
function Xjw takes nothing returns boolean
set Lb=0
return jB("Colors, line 1")
endfunction
function Xww takes nothing returns boolean
set Ao=CreateTrigger()
set Do=CreateTrigger()
call TriggerAddCondition(Vc,Filter(Lf))
call TriggerAddAction(Vc,Xf)
return true
endfunction
function TF takes nothing returns boolean
local unitstate RF=UNIT_STATE_MANA
if GetUnitState(GetEnumUnit(),RF)>0.00 then
set RF=null
return false
endif
set RF=null
return true
endfunction
function YF takes nothing returns nothing
if TF() then
call KillUnit(GetEnumUnit())
endif
endfunction
function TL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990085 then
return false
endif
return true
endfunction
function YL takes nothing returns boolean
if not TL() then
return false
endif
return true
endfunction
function YP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990323,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990106,0)
endfunction
function TU takes nothing returns boolean
if GetResearched()!=1378890037 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890037,true)!=2 then
return false
endif
return true
endfunction
function YU takes nothing returns boolean
if not TU() then
return false
endif
return true
endfunction
function TW takes nothing returns boolean
if GetResearched()!=1378889803 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889803,true)!=1 then
return false
endif
return true
endfunction
function YW takes nothing returns boolean
if not TW() then
return false
endif
return true
endfunction
function YY takes nothing returns nothing
local player nY=GetOwningPlayer(GetAttacker())
local player dY=GetOwningPlayer(GetAttacker())
local player fY
local player RY
local unit TY
set r[GetPlayerId(nY)+1]=r[GetPlayerId(dY)+1]+1
set fY=GetOwningPlayer(GetTriggerUnit())
set RY=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(fY)+1]=r[GetPlayerId(RY)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set TY=GetTriggerUnit()
call SetUnitState(TY,UNIT_STATE_LIFE,GetUnitState(TY,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set nY=null
set dY=null
set fY=null
set RY=null
set TY=null
endfunction
function YZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989573,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989572,0)
endfunction
function qV takes string bV returns boolean
local playerunitevent yV
local integer pV
local integer eV
set Xb[Lb]=bV
set Lb=Lb+1
set yV=EVENT_PLAYER_UNIT_SPELL_CAST
set Xb[Lb]="when calling alloc_Clerics_EventListener_line5 in Clerics, line 5"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set pV=iO
set SO[pV]=666
else
call x1("Out of memory: Could not create Clerics_EventListener_line5.","when calling error in Clerics, line 5")
set pV=0
endif
else
set tO=tO-1
set pV=sO[tO]
set SO[pV]=666
endif
set Lb=Lb-1
set ub[pV]=0
set rb[pV]=0
set sb[pV]=0
set Xb[Lb]="when calling add in Clerics, line 5"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set eV=mS[GetHandleId(yV)]
if eV==0 then
set eV=QV(yV,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[pV]=eV
if ZS[ub[pV]]!=0 then
set sb[ZS[ub[pV]]]=pV
set rb[pV]=ZS[ub[pV]]
endif
set ZS[ub[pV]]=pV
set Lb=Lb-1-1
set yV=null
return true
endfunction
function Yxw takes nothing returns boolean
set Lb=0
return qV("Clerics, line 1")
endfunction
function Z3 takes nothing returns boolean
return true
endfunction
function EH takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())==1747988530 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990327 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747989591 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990085 then
return true
endif
return false
endfunction
function ZH takes nothing returns boolean
if not EH() then
return false
endif
return true
endfunction
function ZI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651844,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651845,0)
endfunction
function EP takes nothing returns boolean
if GetResearched()!=1378890049 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890049,true)!=2 then
return false
endif
return true
endfunction
function ZP takes nothing returns boolean
if not EP() then
return false
endif
return true
endfunction
function EZ takes nothing returns boolean
if GetResearched()!=1378889808 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889808,true)!=1 then
return false
endif
return true
endfunction
function ZZ takes nothing returns boolean
if not EZ() then
return false
endif
return true
endfunction
function Zww takes nothing returns boolean
set Eo=InitHashtable()
return true
endfunction
function Wlw takes string mlw returns integer
local integer Qlw
set Xb[Lb]=mlw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_HashSet in HashSet, line 4"
set Lb=Lb+1
if WO==0 then
if EO<32768 then
set EO=EO+1
set Qlw=EO
set ZO[Qlw]=693
else
call x1("Out of memory: Could not create HashSet.","when calling error in HashSet, line 5")
set Qlw=0
endif
else
set WO=WO-1
set Qlw=QO[WO]
set ZO[Qlw]=693
endif
set Lb=Lb-1
set eb[Qlw]=0
set Lb=Lb-1
return Qlw
endfunction
function l9 takes string S9 returns boolean
local playerunitevent c9
local integer o9
local integer O9
set Xb[Lb]=S9
set Lb=Lb+1
set Cc=Wlw("when calling new_HashSet in NoStarvationOnBoat, line 6")
set c9=EVENT_PLAYER_UNIT_ISSUED_ORDER
set Xb[Lb]="when calling alloc_NoStarvationOnBoat_EventListener_line9 in NoStarvationOnBoat, line 9"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set o9=iO
set SO[o9]=673
else
call x1("Out of memory: Could not create NoStarvationOnBoat_EventListener_line9.","when calling error in NoStarvationOnBoat, line 9")
set o9=0
endif
else
set tO=tO-1
set o9=sO[tO]
set SO[o9]=673
endif
set Lb=Lb-1
set ub[o9]=0
set rb[o9]=0
set sb[o9]=0
set Xb[Lb]="when calling add in NoStarvationOnBoat, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set O9=mS[GetHandleId(c9)]
if O9==0 then
set O9=QV(c9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[o9]=O9
if ZS[ub[o9]]!=0 then
set sb[ZS[ub[o9]]]=o9
set rb[o9]=ZS[ub[o9]]
endif
set ZS[ub[o9]]=o9
set Lb=Lb-1-1
set c9=null
return true
endfunction
function Zxw takes nothing returns boolean
set Lb=0
return l9("NoStarvationOnBoat, line 1")
endfunction
function a2 takes nothing returns nothing
set kc=kc+0.01
endfunction
function qE takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function aE takes nothing returns boolean
if not qE() then
return false
endif
return true
endfunction
function aH takes nothing returns nothing
local integer OH=1
local integer lH=1751277938
local player bH=GetOwningPlayer(GetConstructedStructure())
local rect qH=bj_mapInitialPlayableArea
local location eH=Location(GetRectCenterX(qH),GetRectCenterY(qH))
local location yH=Location(GetLocationX(eH)+100000000.00,GetLocationY(eH)+1000000000.00)
local real pH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set OH=OH-1
exitwhen OH<0
call CreateUnitAtLocSaveLast(bH,lH,yH,pH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set p[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]=true
set bH=null
set yH=null
set eH=null
set qH=null
endfunction
function aL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function aU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651846,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651847,0)
endfunction
function aW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989080,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988818,0)
endfunction
function aX takes nothing returns boolean
local integer eX=0
local integer qX=23
loop
exitwhen eX>qX
set tS[eX]=GetPlayerName(uo[eX])
set eX=eX+1
endloop
return true
endfunction
function qY takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989042 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function aY takes nothing returns boolean
if not qY() then
return false
endif
return true
endfunction
function W8 takes string X5 returns boolean
local integer C5
local integer V5
local integer B5
local integer N5
local integer M5
local integer w6
local integer u6
local integer r6
local integer s6
local integer t6
local integer i6
local integer S6
local integer c6
local integer o6
local integer O6
local integer l6
local integer b6
local integer y6
local integer p6
local integer e6
local integer q6
local integer a6
local integer n6
local integer d6
local integer f6
local integer R6
local integer T6
local integer Y6
local integer G6
local integer g6
local integer h6
local integer F6
local integer k6
local integer j6
local integer x6
local integer v6
local integer m6
local integer Q6
local integer W6
local integer E6
local integer Z6
local integer U6
local integer I6
local integer P6
local integer A6
local integer D6
local integer H6
local integer J6
local integer K6
local integer L6
local integer X6
local integer C6
local integer V6
local integer B6
local integer N6
local integer M6
local integer w7
local integer u7
local integer r7
local integer s7
local integer t7
local integer i7
local integer S7
local integer c7
local integer o7
local integer O7
local integer l7
local integer b7
local integer y7
local integer p7
local integer e7
local integer q7
local integer a7
local integer n7
local integer d7
local integer f7
local integer R7
local integer T7
local integer Y7
local integer G7
local integer g7
local integer h7
local integer F7
local integer k7
local integer j7
local integer x7
local integer v7
local integer m7
local integer Q7
local integer W7
local integer E7
local integer Z7
local integer U7
local integer I7
local integer P7
local integer A7
local integer D7
local integer H7
local integer J7
local integer K7
local integer L7
local integer X7
local integer C7
local integer V7
local integer B7
local integer N7
local integer M7
local integer w8
local integer u8
local integer r8
local integer s8
local integer t8
local integer i8
local integer S8
local integer c8
local integer o8
local integer O8
local integer l8
local integer b8
local integer y8
local integer p8
local integer e8
local integer q8
local integer a8
local integer n8
local integer d8
local integer f8
local integer R8
local integer T8
local integer Y8
local integer G8
local integer g8
local integer h8
local integer F8
local integer k8
local integer j8
local integer x8
local integer v8
local integer m8
local integer Q8
set Xb[Lb]=X5
set Lb=Lb+1
set C5=R2I(70)
set V5=R2I(30)
set B5=R2I(10)
set N5=R2I(70)
set M5=R2I(30)
set w6=R2I(140)
set Xb[Lb]="when calling asList in Multiboards, line 23"
set Lb=Lb+1
set u6=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(u6,C5,"when calling add in LinkedList, line 393")
call jfw(u6,V5,"when calling add in LinkedList, line 393")
call jfw(u6,B5,"when calling add in LinkedList, line 393")
call jfw(u6,N5,"when calling add in LinkedList, line 393")
call jfw(u6,M5,"when calling add in LinkedList, line 393")
call jfw(u6,w6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[0]=u6
set r6=R2I(70)
set s6=R2I(30)
set t6=R2I(10)
set i6=R2I(70)
set S6=R2I(30)
set c6=R2I(140)
set Xb[Lb]="when calling asList in Multiboards, line 24"
set Lb=Lb+1
set o6=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(o6,r6,"when calling add in LinkedList, line 393")
call jfw(o6,s6,"when calling add in LinkedList, line 393")
call jfw(o6,t6,"when calling add in LinkedList, line 393")
call jfw(o6,i6,"when calling add in LinkedList, line 393")
call jfw(o6,S6,"when calling add in LinkedList, line 393")
call jfw(o6,c6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[1]=o6
set O6=R2I(70)
set l6=R2I(30)
set b6=R2I(10)
set y6=R2I(70)
set p6=R2I(30)
set e6=R2I(140)
set Xb[Lb]="when calling asList in Multiboards, line 25"
set Lb=Lb+1
set q6=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(q6,O6,"when calling add in LinkedList, line 393")
call jfw(q6,l6,"when calling add in LinkedList, line 393")
call jfw(q6,b6,"when calling add in LinkedList, line 393")
call jfw(q6,y6,"when calling add in LinkedList, line 393")
call jfw(q6,p6,"when calling add in LinkedList, line 393")
call jfw(q6,e6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[2]=q6
set a6=R2I(2.5)
set n6=R2I(2.5)
set d6=R2I(400)
set f6=R2I(2.5)
set R6=R2I(2.5)
set T6=R2I(2.5)
set Xb[Lb]="when calling asList in Multiboards, line 27"
set Lb=Lb+1
set Y6=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(Y6,a6,"when calling add in LinkedList, line 393")
call jfw(Y6,n6,"when calling add in LinkedList, line 393")
call jfw(Y6,d6,"when calling add in LinkedList, line 393")
call jfw(Y6,f6,"when calling add in LinkedList, line 393")
call jfw(Y6,R6,"when calling add in LinkedList, line 393")
call jfw(Y6,T6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[3]=Y6
set G6=R2I(70)
set g6=R2I(30)
set h6=R2I(30)
set F6=R2I(10)
set k6=R2I(126)
set j6=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 28"
set Lb=Lb+1
set x6=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(x6,G6,"when calling add in LinkedList, line 393")
call jfw(x6,g6,"when calling add in LinkedList, line 393")
call jfw(x6,h6,"when calling add in LinkedList, line 393")
call jfw(x6,F6,"when calling add in LinkedList, line 393")
call jfw(x6,k6,"when calling add in LinkedList, line 393")
call jfw(x6,j6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[4]=x6
set v6=R2I(70)
set m6=R2I(30)
set Q6=R2I(30)
set W6=R2I(10)
set E6=R2I(126)
set Z6=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 29"
set Lb=Lb+1
set U6=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(U6,v6,"when calling add in LinkedList, line 393")
call jfw(U6,m6,"when calling add in LinkedList, line 393")
call jfw(U6,Q6,"when calling add in LinkedList, line 393")
call jfw(U6,W6,"when calling add in LinkedList, line 393")
call jfw(U6,E6,"when calling add in LinkedList, line 393")
call jfw(U6,Z6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[5]=U6
set I6=R2I(70)
set P6=R2I(30)
set A6=R2I(30)
set D6=R2I(10)
set H6=R2I(126)
set J6=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 30"
set Lb=Lb+1
set K6=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(K6,I6,"when calling add in LinkedList, line 393")
call jfw(K6,P6,"when calling add in LinkedList, line 393")
call jfw(K6,A6,"when calling add in LinkedList, line 393")
call jfw(K6,D6,"when calling add in LinkedList, line 393")
call jfw(K6,H6,"when calling add in LinkedList, line 393")
call jfw(K6,J6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[6]=K6
set L6=R2I(70)
set X6=R2I(30)
set C6=R2I(30)
set V6=R2I(10)
set B6=R2I(126)
set N6=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 31"
set Lb=Lb+1
set M6=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(M6,L6,"when calling add in LinkedList, line 393")
call jfw(M6,X6,"when calling add in LinkedList, line 393")
call jfw(M6,C6,"when calling add in LinkedList, line 393")
call jfw(M6,V6,"when calling add in LinkedList, line 393")
call jfw(M6,B6,"when calling add in LinkedList, line 393")
call jfw(M6,N6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[7]=M6
set w7=R2I(70)
set u7=R2I(30)
set r7=R2I(30)
set s7=R2I(10)
set t7=R2I(126)
set i7=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 32"
set Lb=Lb+1
set S7=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(S7,w7,"when calling add in LinkedList, line 393")
call jfw(S7,u7,"when calling add in LinkedList, line 393")
call jfw(S7,r7,"when calling add in LinkedList, line 393")
call jfw(S7,s7,"when calling add in LinkedList, line 393")
call jfw(S7,t7,"when calling add in LinkedList, line 393")
call jfw(S7,i7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[8]=S7
set c7=R2I(70)
set o7=R2I(30)
set O7=R2I(30)
set l7=R2I(10)
set b7=R2I(126)
set y7=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 33"
set Lb=Lb+1
set p7=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(p7,c7,"when calling add in LinkedList, line 393")
call jfw(p7,o7,"when calling add in LinkedList, line 393")
call jfw(p7,O7,"when calling add in LinkedList, line 393")
call jfw(p7,l7,"when calling add in LinkedList, line 393")
call jfw(p7,b7,"when calling add in LinkedList, line 393")
call jfw(p7,y7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc[9]=p7
set Ic[0]=4
set Ic[1]=0
set Pc[0]=4
set Pc[1]=1
set Ac[0]=1
set Ac[1]=4
set Dc[0]=1
set Dc[1]=5
set Hc[0]=1
set Hc[1]=6
set Jc[0]=2
set Jc[1]=6
set Kc[0]=2
set Kc[1]=3
set e7=Tww("Food","when calling stringToIndex in Multiboards, line 56")
set q7=Tww("0","when calling stringToIndex in Multiboards, line 56")
set a7=Tww("|","when calling stringToIndex in Multiboards, line 56")
set n7=Tww("Income","when calling stringToIndex in Multiboards, line 56")
set d7=Tww("0","when calling stringToIndex in Multiboards, line 56")
set f7=Tww(" ","when calling stringToIndex in Multiboards, line 56")
set Xb[Lb]="when calling asList in Multiboards, line 56"
set Lb=Lb+1
set R7=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(R7,e7,"when calling add in LinkedList, line 393")
call jfw(R7,q7,"when calling add in LinkedList, line 393")
call jfw(R7,a7,"when calling add in LinkedList, line 393")
call jfw(R7,n7,"when calling add in LinkedList, line 393")
call jfw(R7,d7,"when calling add in LinkedList, line 393")
call jfw(R7,f7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[0]=R7
set T7=Tww("Iron","when calling stringToIndex in Multiboards, line 57")
set Y7=Tww("0","when calling stringToIndex in Multiboards, line 57")
set G7=Tww("|","when calling stringToIndex in Multiboards, line 57")
set g7=Tww("Upkeep","when calling stringToIndex in Multiboards, line 57")
set h7=Tww("0","when calling stringToIndex in Multiboards, line 57")
set F7=Tww(" ","when calling stringToIndex in Multiboards, line 57")
set Xb[Lb]="when calling asList in Multiboards, line 57"
set Lb=Lb+1
set k7=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(k7,T7,"when calling add in LinkedList, line 393")
call jfw(k7,Y7,"when calling add in LinkedList, line 393")
call jfw(k7,G7,"when calling add in LinkedList, line 393")
call jfw(k7,g7,"when calling add in LinkedList, line 393")
call jfw(k7,h7,"when calling add in LinkedList, line 393")
call jfw(k7,F7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[1]=k7
set j7=Tww("Stone","when calling stringToIndex in Multiboards, line 58")
set x7=Tww("0","when calling stringToIndex in Multiboards, line 58")
set v7=Tww("|","when calling stringToIndex in Multiboards, line 58")
set m7=Tww(" ","when calling stringToIndex in Multiboards, line 58")
set Q7=Tww(" ","when calling stringToIndex in Multiboards, line 58")
set W7=Tww(" ","when calling stringToIndex in Multiboards, line 58")
set Xb[Lb]="when calling asList in Multiboards, line 58"
set Lb=Lb+1
set E7=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(E7,j7,"when calling add in LinkedList, line 393")
call jfw(E7,x7,"when calling add in LinkedList, line 393")
call jfw(E7,v7,"when calling add in LinkedList, line 393")
call jfw(E7,m7,"when calling add in LinkedList, line 393")
call jfw(E7,Q7,"when calling add in LinkedList, line 393")
call jfw(E7,W7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[2]=E7
set Z7=Tww(" ","when calling stringToIndex in Multiboards, line 60")
set U7=Tww(" ","when calling stringToIndex in Multiboards, line 60")
set I7=Tww("                           City info","when calling stringToIndex in Multiboards, line 60")
set P7=Tww(" ","when calling stringToIndex in Multiboards, line 60")
set A7=Tww(" ","when calling stringToIndex in Multiboards, line 60")
set D7=Tww(" ","when calling stringToIndex in Multiboards, line 60")
set Xb[Lb]="when calling asList in Multiboards, line 60"
set Lb=Lb+1
set H7=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(H7,Z7,"when calling add in LinkedList, line 393")
call jfw(H7,U7,"when calling add in LinkedList, line 393")
call jfw(H7,I7,"when calling add in LinkedList, line 393")
call jfw(H7,P7,"when calling add in LinkedList, line 393")
call jfw(H7,A7,"when calling add in LinkedList, line 393")
call jfw(H7,D7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[3]=H7
set J7=Tww("Tax","when calling stringToIndex in Multiboards, line 61")
set K7=Tww("0","when calling stringToIndex in Multiboards, line 61")
set L7=Tww(" ","when calling stringToIndex in Multiboards, line 61")
set X7=Tww("|","when calling stringToIndex in Multiboards, line 61")
set C7=Tww(" ","when calling stringToIndex in Multiboards, line 61")
set V7=Tww(" ","when calling stringToIndex in Multiboards, line 61")
set Xb[Lb]="when calling asList in Multiboards, line 61"
set Lb=Lb+1
set B7=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(B7,J7,"when calling add in LinkedList, line 393")
call jfw(B7,K7,"when calling add in LinkedList, line 393")
call jfw(B7,L7,"when calling add in LinkedList, line 393")
call jfw(B7,X7,"when calling add in LinkedList, line 393")
call jfw(B7,C7,"when calling add in LinkedList, line 393")
call jfw(B7,V7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[4]=B7
set N7=Tww("Public order","when calling stringToIndex in Multiboards, line 62")
set M7=Tww("0","when calling stringToIndex in Multiboards, line 62")
set w8=Tww(" ","when calling stringToIndex in Multiboards, line 62")
set u8=Tww("|","when calling stringToIndex in Multiboards, line 62")
set r8=Tww(" ","when calling stringToIndex in Multiboards, line 62")
set s8=Tww(" ","when calling stringToIndex in Multiboards, line 62")
set Xb[Lb]="when calling asList in Multiboards, line 62"
set Lb=Lb+1
set t8=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(t8,N7,"when calling add in LinkedList, line 393")
call jfw(t8,M7,"when calling add in LinkedList, line 393")
call jfw(t8,w8,"when calling add in LinkedList, line 393")
call jfw(t8,u8,"when calling add in LinkedList, line 393")
call jfw(t8,r8,"when calling add in LinkedList, line 393")
call jfw(t8,s8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[5]=t8
set i8=Tww("Population","when calling stringToIndex in Multiboards, line 63")
set S8=Tww("0","when calling stringToIndex in Multiboards, line 63")
set c8=Tww(" ","when calling stringToIndex in Multiboards, line 63")
set o8=Tww("|","when calling stringToIndex in Multiboards, line 63")
set O8=Tww(" ","when calling stringToIndex in Multiboards, line 63")
set l8=Tww(" ","when calling stringToIndex in Multiboards, line 63")
set Xb[Lb]="when calling asList in Multiboards, line 63"
set Lb=Lb+1
set b8=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(b8,i8,"when calling add in LinkedList, line 393")
call jfw(b8,S8,"when calling add in LinkedList, line 393")
call jfw(b8,c8,"when calling add in LinkedList, line 393")
call jfw(b8,o8,"when calling add in LinkedList, line 393")
call jfw(b8,O8,"when calling add in LinkedList, line 393")
call jfw(b8,l8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[6]=b8
set y8=Tww(" ","when calling stringToIndex in Multiboards, line 64")
set p8=Tww(" ","when calling stringToIndex in Multiboards, line 64")
set e8=Tww(" ","when calling stringToIndex in Multiboards, line 64")
set q8=Tww("|","when calling stringToIndex in Multiboards, line 64")
set a8=Tww(" ","when calling stringToIndex in Multiboards, line 64")
set n8=Tww(" ","when calling stringToIndex in Multiboards, line 64")
set Xb[Lb]="when calling asList in Multiboards, line 64"
set Lb=Lb+1
set d8=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(d8,y8,"when calling add in LinkedList, line 393")
call jfw(d8,p8,"when calling add in LinkedList, line 393")
call jfw(d8,e8,"when calling add in LinkedList, line 393")
call jfw(d8,q8,"when calling add in LinkedList, line 393")
call jfw(d8,a8,"when calling add in LinkedList, line 393")
call jfw(d8,n8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[7]=d8
set f8=Tww(" ","when calling stringToIndex in Multiboards, line 65")
set R8=Tww(" ","when calling stringToIndex in Multiboards, line 65")
set T8=Tww(" ","when calling stringToIndex in Multiboards, line 65")
set Y8=Tww("|","when calling stringToIndex in Multiboards, line 65")
set G8=Tww(" ","when calling stringToIndex in Multiboards, line 65")
set g8=Tww(" ","when calling stringToIndex in Multiboards, line 65")
set Xb[Lb]="when calling asList in Multiboards, line 65"
set Lb=Lb+1
set h8=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(h8,f8,"when calling add in LinkedList, line 393")
call jfw(h8,R8,"when calling add in LinkedList, line 393")
call jfw(h8,T8,"when calling add in LinkedList, line 393")
call jfw(h8,Y8,"when calling add in LinkedList, line 393")
call jfw(h8,G8,"when calling add in LinkedList, line 393")
call jfw(h8,g8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[8]=h8
set F8=Tww(" ","when calling stringToIndex in Multiboards, line 66")
set k8=Tww(" ","when calling stringToIndex in Multiboards, line 66")
set j8=Tww(" ","when calling stringToIndex in Multiboards, line 66")
set x8=Tww("|","when calling stringToIndex in Multiboards, line 66")
set v8=Tww(" ","when calling stringToIndex in Multiboards, line 66")
set m8=Tww(" ","when calling stringToIndex in Multiboards, line 66")
set Xb[Lb]="when calling asList in Multiboards, line 66"
set Lb=Lb+1
set Q8=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(Q8,F8,"when calling add in LinkedList, line 393")
call jfw(Q8,k8,"when calling add in LinkedList, line 393")
call jfw(Q8,j8,"when calling add in LinkedList, line 393")
call jfw(Q8,x8,"when calling add in LinkedList, line 393")
call jfw(Q8,v8,"when calling add in LinkedList, line 393")
call jfw(Q8,m8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lc[9]=Q8
set Lb=Lb-1
return true
endfunction
function axw takes nothing returns boolean
set Lb=0
return W8("Multiboards, line 1")
endfunction
function b0w takes nothing returns boolean
return true
endfunction
function b4 takes nothing returns boolean
return true
endfunction
function b9 takes nothing returns boolean
return true
endfunction
function bD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990598,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990597,0)
endfunction
function iG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988824 then
return false
endif
return true
endfunction
function SG takes nothing returns boolean
if not iG() then
return false
endif
return true
endfunction
function OG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989079 then
return false
endif
return true
endfunction
function lG takes nothing returns boolean
if not OG() then
return false
endif
return true
endfunction
function cG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988826 then
return false
endif
return true
endfunction
function oG takes nothing returns boolean
if not cG() then
return false
endif
return true
endfunction
function sG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988825 then
return false
endif
return true
endfunction
function tG takes nothing returns boolean
if not sG() then
return false
endif
return true
endfunction
function bG takes nothing returns nothing
if tG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989047,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if SG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989046,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if oG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989077,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if lG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989078,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
endfunction
function bK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function bQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651826,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651824,0)
endfunction
function brw takes nothing returns boolean
call Location(0.,0.)
return true
endfunction
function cF takes nothing returns nothing
local location Nh
local location Mh
local real wF
local real uF
local rect rF
local group sF
local group tF
local code iF
local boolean SF
set u=GetUnitLoc(GetSpellAbilityUnit())
set Nh=u
set S=Location(GetLocationX(Nh)+0.00,GetLocationY(Nh)+200.00)
set Mh=u
set wF=GetLocationX(Mh)
set uF=GetLocationY(Mh)
set o=Rect(wF-140,uF-150,wF+140,uF+150)
set rF=o
set sF=CreateGroup()
call GroupEnumUnitsInRect(sF,rF,null)
call DestroyBoolExpr(null)
set l=sF
set tF=l
set iF=Op
set SF=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(tF,iF)
if SF then
call DestroyGroup(tF)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990072,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set Nh=null
set Mh=null
set rF=null
set sF=null
set tF=null
endfunction
function cI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989833,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989834,0)
endfunction
function SP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function cP takes nothing returns boolean
if not SP() then
return false
endif
return true
endfunction
function SZ takes nothing returns boolean
if GetResearched()!=1378889809 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889809,true)!=2 then
return false
endif
return true
endfunction
function cZ takes nothing returns boolean
if not SZ() then
return false
endif
return true
endfunction
function cg takes nothing returns nothing
local location NG
local location MG
local real wg
local real ug
local rect rg
local group sg
local group tg
local code ig
local boolean Sg
set u=GetUnitLoc(GetSpellAbilityUnit())
set NG=u
set c=Location(GetLocationX(NG)+200.00,GetLocationY(NG)+0.00)
set MG=u
set wg=GetLocationX(MG)
set ug=GetLocationY(MG)
set O=Rect(wg-150,ug-140,wg+150,ug+140)
set rg=O
set sg=CreateGroup()
call GroupEnumUnitsInRect(sg,rg,null)
call DestroyBoolExpr(null)
set l=sg
set tg=l
set ig=Jy
set Sg=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(tg,ig)
if Sg then
call DestroyGroup(tg)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990092,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set NG=null
set MG=null
set rg=null
set sg=null
set tg=null
endfunction
function ch takes nothing returns nothing
local location Ng
local location Mg
local real wh
local real uh
local rect rh
local group sh
local group th
local code ih
local boolean Sh
set u=GetUnitLoc(GetSpellAbilityUnit())
set Ng=u
set c=Location(GetLocationX(Ng)+200.00,GetLocationY(Ng)+0.00)
set Mg=u
set wh=GetLocationX(Mg)
set uh=GetLocationY(Mg)
set O=Rect(wh-150,uh-140,wh+150,uh+140)
set rh=O
set sh=CreateGroup()
call GroupEnumUnitsInRect(sh,rh,null)
call DestroyBoolExpr(null)
set l=sh
set th=l
set ih=wp
set Sh=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(th,ih)
if Sh then
call DestroyGroup(th)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747988826,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set Ng=null
set Mg=null
set rh=null
set sh=null
set th=null
endfunction
function cv takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747989049 then
return false
endif
return true
endfunction
function Baw takes integer Xaw,unit Caw,string Vaw returns nothing
set Xb[Lb]=Vaw
set Lb=Lb+1
if kO[Xaw]==0 then
if Xaw==0 then
call x1("Nullpointer exception when calling OnCastListener.fire","when calling error in ClosureEvents, line 56")
else
call x1("Called OnCastListener.fire on invalid object.","when calling error in ClosureEvents, line 56")
endif
endif
set Lb=Lb-1
endfunction
function OB takes string tB returns nothing
local unit iB
local integer SB
local integer cB
local integer oB
set Xb[Lb]=tB
set Lb=Lb+1
set iB=GetTriggerUnit()
set SB=GetSpellAbilityId()
if wdw(ES,GetHandleId(iB),"when calling has in ClosureEvents, line 189") then
set cB=ldw(ES,GetHandleId(iB),"when calling get in ClosureEvents, line 190")
loop
exitwhen cB==0
if Sb[cB]==-1 or Sb[cB]==SB then
call Baw(cB,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 193")
endif
set cB=tb[cB]
endloop
endif
if wdw(WS,SB,"when calling has in ClosureEvents, line 195") then
set oB=ldw(WS,SB,"when calling get in ClosureEvents, line 196")
loop
exitwhen oB==0
if cb[oB]==null or cb[oB]==iB then
call Baw(oB,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 199")
endif
set oB=tb[oB]
endloop
endif
set Lb=Lb-1
set iB=null
endfunction
function cvw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 308"
set Lb=Lb+1
call OB("when calling onSpellEffect in ClosureEvents, line 308")
set Lb=Lb-1
endfunction
function G9 takes string d9 returns boolean
local integer f9
local integer R9
local integer T9
local timer Y9
set Xb[Lb]=d9
set Lb=Lb+1
set Vc=CreateTrigger()
set Bc=CreateGroup()
set f9=0
set R9=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen f9>R9
call SetPlayerAbilityAvailable(uo[f9],1095577649,false)
set f9=f9+1
endloop
set Xb[Lb]="when calling alloc_OnUnitEnterLeave_CallbackSingle_line62 in OnUnitEnterLeave, line 62"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set T9=RO
set TO[T9]=649
else
call x1("Out of memory: Could not create OnUnitEnterLeave_CallbackSingle_line62.","when calling error in OnUnitEnterLeave, line 62")
set T9=0
endif
else
set fO=fO-1
set T9=dO[fO]
set TO[T9]=649
endif
set Lb=Lb-1
set Xb[Lb]="when calling nullTimer in OnUnitEnterLeave, line 62"
set Lb=Lb+1
set Xb[Lb]="when calling doAfter in ClosureTimers, line 33"
set Lb=Lb+1
set Y9=Sww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(T9,Y9,0.,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1
set Lb=Lb-1-1-1
set Y9=null
return true
endfunction
function cxw takes nothing returns boolean
set Lb=0
return G9("OnUnitEnterLeave, line 1")
endfunction
function d0w takes nothing returns boolean
set yo=-340282366920938000000000000000000000000.
return true
endfunction
function d1 takes nothing returns boolean
set Sc=InitHashtable()
return true
endfunction
function dD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651850,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651849,0)
endfunction
function dF takes nothing returns nothing
local group qF
local code aF
local boolean nF
set w=GetUnitsOfTypeIdAll(1747988790)
set qF=w
set aF=yp
set nF=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(qF,aF)
if nF then
call DestroyGroup(qF)
endif
call DestroyGroup(w)
set qF=null
endfunction
function dK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function dM takes nothing returns boolean
local trigger eM=CreateTrigger()
local trigger qM=eM
local playerunitevent aM=EVENT_PLAYER_UNIT_SPELL_EFFECT
local integer nM=0
loop
call TriggerRegisterPlayerUnitEvent(qM,Player(nM),aM,null)
set nM=nM+1
exitwhen nM==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(eM,Condition(Af))
call TriggerAddAction(eM,Df)
set eM=null
set qM=null
set aM=null
return true
endfunction
function dQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989065,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989296,0)
endfunction
function UX takes string QX returns boolean
local playerunitevent WX
local integer EX
local integer ZX
set Xb[Lb]=QX
set Lb=Lb+1
set WX=EVENT_PLAYER_UNIT_ATTACKED
set Xb[Lb]="when calling alloc_CastleCapture_EventListener_line8 in CastleCapture, line 8"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set EX=iO
set SO[EX]=661
else
call x1("Out of memory: Could not create CastleCapture_EventListener_line8.","when calling error in CastleCapture, line 8")
set EX=0
endif
else
set tO=tO-1
set EX=sO[tO]
set SO[EX]=661
endif
set Lb=Lb-1
set ub[EX]=0
set rb[EX]=0
set sb[EX]=0
set Xb[Lb]="when calling add in CastleCapture, line 8"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set ZX=mS[GetHandleId(WX)]
if ZX==0 then
set ZX=QV(WX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[EX]=ZX
if ZS[ub[EX]]!=0 then
set sb[ZS[ub[EX]]]=EX
set rb[EX]=ZS[ub[EX]]
endif
set ZS[ub[EX]]=EX
set Lb=Lb-1-1
set WX=null
return true
endfunction
function dxw takes nothing returns boolean
set Lb=0
return UX("CastleCapture, line 1")
endfunction
function pF takes nothing returns boolean
local unitstate yF=UNIT_STATE_MANA
if GetUnitState(GetEnumUnit(),yF)>0.00 then
set yF=null
return false
endif
set yF=null
return true
endfunction
function eF takes nothing returns nothing
if pF() then
call KillUnit(GetEnumUnit())
endif
endfunction
function eI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989832,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989833,0)
endfunction
function pP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function eP takes nothing returns boolean
if not pP() then
return false
endif
return true
endfunction
function pZ takes nothing returns boolean
if GetResearched()!=1378889811 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889811,true)!=1 then
return false
endif
return true
endfunction
function eZ takes nothing returns boolean
if not pZ() then
return false
endif
return true
endfunction
function pg takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function eg takes nothing returns nothing
if pg() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function ph takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function eh takes nothing returns nothing
if ph() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function ej takes nothing returns nothing
local player sj=GetOwningPlayer(GetKillingUnit())
local playerstate tj=PLAYER_STATE_RESOURCE_LUMBER
local playerstate ij
local playerstate Sj
local player cj
local force oj
local location Oj
local real lj
local real bj
local player yj
local force pj
if tj==PLAYER_STATE_RESOURCE_GOLD then
set ij=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(sj,ij,GetPlayerState(sj,ij)+125)
elseif tj==PLAYER_STATE_RESOURCE_LUMBER then
set Sj=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(sj,Sj,GetPlayerState(sj,Sj)+125)
endif
call SetPlayerState(sj,tj,GetPlayerState(sj,tj)+125)
set cj=GetOwningPlayer(GetKillingUnit())
set oj=CreateForce()
call ForceAddPlayer(oj,cj)
if IsPlayerInForce(GetLocalPlayer(),oj) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_089")
endif
set y=GetUnitLoc(GetDyingUnit())
set yj=GetOwningPlayer(GetDyingUnit())
set pj=CreateForce()
call ForceAddPlayer(pj,yj)
set Oj=y
set lj=GetLocationX(Oj)
set bj=GetLocationY(Oj)
if IsPlayerInForce(GetLocalPlayer(),pj) then
call PingMinimap(lj,bj,2.00)
endif
call RemoveLocation(y)
set sj=null
set tj=null
set ij=null
set Sj=null
set cj=null
set oj=null
set Oj=null
set yj=null
set pj=null
endfunction
function ex takes nothing returns nothing
local player sx=GetOwningPlayer(GetKillingUnit())
local playerstate tx=PLAYER_STATE_RESOURCE_GOLD
local playerstate ix
local playerstate Sx
local player cx
local force ox
local location Ox
local real lx
local real bx
local player yx
local force px
if tx==PLAYER_STATE_RESOURCE_GOLD then
set ix=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(sx,ix,GetPlayerState(sx,ix)+250)
elseif tx==PLAYER_STATE_RESOURCE_LUMBER then
set Sx=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(sx,Sx,GetPlayerState(sx,Sx)+250)
endif
call SetPlayerState(sx,tx,GetPlayerState(sx,tx)+250)
set cx=GetOwningPlayer(GetKillingUnit())
set ox=CreateForce()
call ForceAddPlayer(ox,cx)
if IsPlayerInForce(GetLocalPlayer(),ox) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_092")
endif
set y=GetUnitLoc(GetDyingUnit())
set yx=GetOwningPlayer(GetDyingUnit())
set px=CreateForce()
call ForceAddPlayer(px,yx)
set Ox=y
set lx=GetLocationX(Ox)
set bx=GetLocationY(Ox)
if IsPlayerInForce(GetLocalPlayer(),px) then
call PingMinimap(lx,bx,2.00)
endif
call RemoveLocation(y)
set sx=null
set tx=null
set ix=null
set Sx=null
set cx=null
set ox=null
set Ox=null
set yx=null
set px=null
endfunction
function dA takes nothing returns boolean
if GetResearched()!=1378890040 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890040,true)!=1 then
return false
endif
return true
endfunction
function fA takes nothing returns boolean
if not dA() then
return false
endif
return true
endfunction
function dJ takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747990353 then
return false
endif
return true
endfunction
function fJ takes nothing returns boolean
if not dJ() then
return false
endif
return true
endfunction
function fj takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988801 then
return false
endif
return true
endfunction
function dm takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function fm takes nothing returns boolean
if not dm() then
return false
endif
return true
endfunction
function fv takes nothing returns nothing
local player ov=GetOwningPlayer(GetKillingUnit())
local playerstate Ov=PLAYER_STATE_RESOURCE_GOLD
local playerstate lv
local playerstate bv
local player yv
local force pv
local location ev
local real qv
local real av
local player nv
local force dv
if Ov==PLAYER_STATE_RESOURCE_GOLD then
set lv=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(ov,lv,GetPlayerState(ov,lv)+500)
elseif Ov==PLAYER_STATE_RESOURCE_LUMBER then
set bv=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(ov,bv,GetPlayerState(ov,bv)+500)
endif
call SetPlayerState(ov,Ov,GetPlayerState(ov,Ov)+500)
set yv=GetOwningPlayer(GetKillingUnit())
set pv=CreateForce()
call ForceAddPlayer(pv,yv)
if IsPlayerInForce(GetLocalPlayer(),pv) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_083")
endif
set y=GetUnitLoc(GetDyingUnit())
set nv=GetOwningPlayer(GetDyingUnit())
set dv=CreateForce()
call ForceAddPlayer(dv,nv)
set ev=y
set qv=GetLocationX(ev)
set av=GetLocationY(ev)
if IsPlayerInForce(GetLocalPlayer(),dv) then
call PingMinimap(qv,av,2.00)
endif
call RemoveLocation(y)
set ov=null
set Ov=null
set lv=null
set bv=null
set yv=null
set pv=null
set ev=null
set nv=null
set dv=null
endfunction
function LX takes string DX returns boolean
local playerunitevent HX
local integer JX
local integer KX
set Xb[Lb]=DX
set Lb=Lb+1
set HX=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set Xb[Lb]="when calling alloc_CityBuilded_EventListener_line9 in CityBuilded, line 9"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set JX=iO
set SO[JX]=662
else
call x1("Out of memory: Could not create CityBuilded_EventListener_line9.","when calling error in CityBuilded, line 9")
set JX=0
endif
else
set tO=tO-1
set JX=sO[tO]
set SO[JX]=662
endif
set Lb=Lb-1
set ub[JX]=0
set rb[JX]=0
set sb[JX]=0
set Xb[Lb]="when calling add in CityBuilded, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set KX=mS[GetHandleId(HX)]
if KX==0 then
set KX=QV(HX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[JX]=KX
if ZS[ub[JX]]!=0 then
set sb[ZS[ub[JX]]]=JX
set rb[JX]=ZS[ub[JX]]
endif
set ZS[ub[JX]]=JX
set Lb=Lb-1-1
set HX=null
return true
endfunction
function fxw takes nothing returns boolean
set Lb=0
return LX("CityBuilded, line 1")
endfunction
function gD takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,ma)
endfunction
function gE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989570,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989571,0)
endfunction
function YG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990072 then
return false
endif
return true
endfunction
function GG takes nothing returns boolean
if not YG() then
return false
endif
return true
endfunction
function RG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990081 then
return false
endif
return true
endfunction
function TG takes nothing returns boolean
if not RG() then
return false
endif
return true
endfunction
function dG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990090 then
return false
endif
return true
endfunction
function fG takes nothing returns boolean
if not dG() then
return false
endif
return true
endfunction
function aG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990092 then
return false
endif
return true
endfunction
function nG takes nothing returns boolean
if not aG() then
return false
endif
return true
endfunction
function gG takes nothing returns nothing
if nG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990091,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if fG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990089,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if TG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990073,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if GG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990071,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
endfunction
function GK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989809 then
return false
endif
return true
endfunction
function gK takes nothing returns boolean
if not GK() then
return false
endif
return true
endfunction
function GQ takes nothing returns boolean
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=2 then
return false
endif
return true
endfunction
function gQ takes nothing returns boolean
if not GQ() then
return false
endif
return true
endfunction
function gg takes nothing returns nothing
local location qg
local location ag
local real ng
local real dg
local rect fg
local group Rg
local group Tg
local code Yg
local boolean Gg
set u=GetUnitLoc(GetSpellAbilityUnit())
set qg=u
set S=Location(GetLocationX(qg)+0.00,GetLocationY(qg)+200.00)
set ag=u
set ng=GetLocationX(ag)
set dg=GetLocationY(ag)
set o=Rect(ng-140,dg-150,ng+140,dg+150)
set fg=o
set Rg=CreateGroup()
call GroupEnumUnitsInRect(Rg,fg,null)
call DestroyBoolExpr(null)
set l=Rg
set Tg=l
set Yg=Xy
set Gg=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Tg,Yg)
if Gg then
call DestroyGroup(Tg)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747988824,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set qg=null
set ag=null
set fg=null
set Rg=null
set Tg=null
endfunction
function gh takes nothing returns nothing
local location qh
local location ah
local real nh
local real dh
local rect fh
local group Rh
local group Th
local code Yh
local boolean Gh
set u=GetUnitLoc(GetSpellAbilityUnit())
set qh=u
set c=Location(GetLocationX(qh)+200.00,GetLocationY(qh)+0.00)
set ah=u
set nh=GetLocationX(ah)
set dh=GetLocationY(ah)
set O=Rect(nh-150,dh-140,nh+150,dh+140)
set fh=O
set Rh=CreateGroup()
call GroupEnumUnitsInRect(Rh,fh,null)
call DestroyBoolExpr(null)
set l=Rh
set Th=l
set Yh=sp
set Gh=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Th,Yh)
if Gh then
call DestroyGroup(Th)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990081,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set qh=null
set ah=null
set fh=null
set Rh=null
set Th=null
endfunction
function gv takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747989048 then
return false
endif
return true
endfunction
function gww takes nothing returns boolean
return true
endfunction
function hK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function hQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989067,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989065,0)
endfunction
function hww takes nothing returns boolean
return true
endfunction
function hxw takes nothing returns boolean
local integer Gxw
local integer gxw
set Lb=0
set Xb[Lb]="VoteKick, line 1"
set Lb=Lb+1
set Gxw=0
set gxw=23
loop
exitwhen Gxw>gxw
set rO[Gxw]=Wlw("when calling new_HashSet in VoteKick, line 11")
set Gxw=Gxw+1
endloop
set Lb=Lb-1
return true
endfunction
function tA takes nothing returns boolean
if GetResearched()!=1378890053 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890053,true)!=1 then
return false
endif
return true
endfunction
function iA takes nothing returns boolean
if not tA() then
return false
endif
return true
endfunction
function Www takes string vww,string mww returns boolean
local integer Qww=StringLength(vww)
if StringLength(mww)>Qww then
return false
endif
return SubString(vww,0,StringLength(mww))==mww
endfunction
function iM takes nothing returns boolean
return Www(GetEventPlayerChatString(),"-")
endfunction
function iN takes nothing returns boolean
local trigger rN=CreateTrigger()
local trigger uN
local integer sN
local integer tN
call TriggerAddCondition(rN,Condition(Uf))
call TriggerAddAction(rN,If)
set uN=rN
set sN=0
set tN=23
loop
exitwhen sN>tN
call TriggerRegisterPlayerChatEvent(uN,uo[sN],"-",false)
set sN=sN+1
endloop
set uN=null
set rN=null
return true
endfunction
function tm takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function im takes nothing returns boolean
if not tm() then
return false
endif
return true
endfunction
function ivw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 292"
set Lb=Lb+1
call sB("when calling generalEventCallback in ClosureEvents, line 292")
set Lb=Lb-1
endfunction
function u0w takes string C9 returns boolean
local integer V9
local integer B9
local integer N9
local integer M9
local timer w0w
set Xb[Lb]=C9
set Lb=Lb+1
set Oo=CreateGroup()
set lo=CreateUnit(iS,2019849581,0.,0.,0)
if lo==null then
set C9=""
set V9=2019849581
set B9=0
loop
exitwhen B9>3
set N9=ModuloInteger(V9,256)
set V9=V9/256
set C9=SubString(".................................!.#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~.................................................................................................................................",N9,N9+1)+C9
set B9=B9+1
endloop
call x1("DUMMY_UNITID ("+C9+") not added correctly to the map.","when calling error in Preloader, line 52")
endif
set Xb[Lb]="when calling alloc_Preloader_CallbackSingle_line54 in Preloader, line 54"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set M9=RO
set TO[M9]=650
else
call x1("Out of memory: Could not create Preloader_CallbackSingle_line54.","when calling error in Preloader, line 54")
set M9=0
endif
else
set fO=fO-1
set M9=dO[fO]
set TO[M9]=650
endif
set Lb=Lb-1
set Xb[Lb]="when calling nullTimer in Preloader, line 54"
set Lb=Lb+1
set Xb[Lb]="when calling doAfter in ClosureTimers, line 33"
set Lb=Lb+1
set w0w=Sww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(M9,w0w,0.,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1
set Lb=Lb-1-1-1
set w0w=null
return true
endfunction
function ixw takes nothing returns boolean
set Lb=0
return u0w("Preloader, line 1")
endfunction
function j9 takes nothing returns nothing
local unit k9=GetTriggerUnit()
if GetUnitAbilityLevel(k9,1095577649)==0 then
set Nc[Mc]=k9
set Mc=Mc+1
call TriggerExecute(Vc)
set Mc=Mc-1
endif
set k9=null
endfunction
function jD takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())==1747988535 then
call ReplaceUnitBJ(GetEnumUnit(),1747988788,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990325 then
call ReplaceUnitBJ(GetEnumUnit(),1747990324,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747989594 then
call ReplaceUnitBJ(GetEnumUnit(),1747990097,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988784 then
call ReplaceUnitBJ(GetEnumUnit(),1747988561,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988563 then
call ReplaceUnitBJ(GetEnumUnit(),1747988565,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988562 then
call ReplaceUnitBJ(GetEnumUnit(),1747988566,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988564 then
call ReplaceUnitBJ(GetEnumUnit(),1747988567,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990104 then
call ReplaceUnitBJ(GetEnumUnit(),1747990321,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990105 then
call ReplaceUnitBJ(GetEnumUnit(),1747990322,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990106 then
call ReplaceUnitBJ(GetEnumUnit(),1747990323,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747989811 then
call ReplaceUnitBJ(GetEnumUnit(),1747989812,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990095 then
call ReplaceUnitBJ(GetEnumUnit(),1747990098,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990096 then
call ReplaceUnitBJ(GetEnumUnit(),1747990099,bj_UNIT_STATE_METHOD_RELATIVE)
endif
endfunction
function jI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989835,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989836,0)
endfunction
function kP takes nothing returns boolean
if GetResearched()!=1378890049 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890049,true)!=1 then
return false
endif
return true
endfunction
function jP takes nothing returns boolean
if not kP() then
return false
endif
return true
endfunction
function kY takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989044 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function jY takes nothing returns boolean
if not kY() then
return false
endif
return true
endfunction
function kZ takes nothing returns boolean
if GetResearched()!=1378889810 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889810,true)!=2 then
return false
endif
return true
endfunction
function jZ takes nothing returns boolean
if not kZ() then
return false
endif
return true
endfunction
function pM takes string lM returns boolean
local integer bM
local timer yM
set Xb[Lb]=lM
set Lb=Lb+1
set Xb[Lb]="when calling alloc_DateTime_CallbackPeriodic_line31 in DateTime, line 31"
set Lb=Lb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set bM=gO
set hO[bM]=634
else
call x1("Out of memory: Could not create DateTime_CallbackPeriodic_line31.","when calling error in DateTime, line 31")
set bM=0
endif
else
set GO=GO-1
set bM=YO[GO]
set hO[bM]=634
endif
set Lb=Lb-1
set Ob[bM]=120.0
set Xb[Lb]="when calling doPeriodically in DateTime, line 31"
set Lb=Lb+1
set yM=Sww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call enw(bM,yM,1.0,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set yM=null
return true
endfunction
function jxw takes nothing returns boolean
set Lb=0
return pM("DateTime, line 1")
endfunction
function kA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990596,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990595,0)
endfunction
function kD takes nothing returns boolean
return IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)==true
endfunction
function FI takes nothing returns boolean
if GetResearched()!=1378890036 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890036,true)!=2 then
return false
endif
return true
endfunction
function kI takes nothing returns boolean
if not FI() then
return false
endif
return true
endfunction
function kJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function km takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989057,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989058,0)
endfunction
function t1 takes string B3 returns boolean
local integer N3
local integer M3
local integer w1
local timer u1
local integer r1
local timer s1
set Xb[Lb]=B3
set Lb=Lb+1
set N3=0
set M3=23
loop
exitwhen N3>M3
set tc[N3]=0
set N3=N3+1
endloop
set Xb[Lb]="when calling alloc_Economy_CallbackPeriodic_line47 in Economy, line 47"
set Lb=Lb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set w1=gO
set hO[w1]=635
else
call x1("Out of memory: Could not create Economy_CallbackPeriodic_line47.","when calling error in Economy, line 47")
set w1=0
endif
else
set GO=GO-1
set w1=YO[GO]
set hO[w1]=635
endif
set Lb=Lb-1
set Xb[Lb]="when calling doPeriodically in Economy, line 47"
set Lb=Lb+1
set u1=Sww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call enw(w1,u1,0.333333343,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1
set Xb[Lb]="when calling alloc_Economy_CallbackPeriodic_line54 in Economy, line 54"
set Lb=Lb+1
if GO==0 then
if gO<32768 then
set gO=gO+1
set r1=gO
set hO[r1]=636
else
call x1("Out of memory: Could not create Economy_CallbackPeriodic_line54.","when calling error in Economy, line 54")
set r1=0
endif
else
set GO=GO-1
set r1=YO[GO]
set hO[r1]=636
endif
set Lb=Lb-1
set Xb[Lb]="when calling doPeriodically in Economy, line 54"
set Lb=Lb+1
set s1=Sww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call enw(r1,s1,10.0,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set u1=null
set s1=null
return true
endfunction
function kxw takes nothing returns boolean
set Lb=0
return t1("Economy, line 1")
endfunction
function l4 takes nothing returns boolean
return true
endfunction
function lB takes nothing returns boolean
set PS=CreateGroup()
set HS=2147483647
set KS=Filter(Zf)
return true
endfunction
function OD takes nothing returns boolean
if GetResearched()!=1378889818 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889818,true)!=1 then
return false
endif
return true
endfunction
function lD takes nothing returns boolean
if not OD() then
return false
endif
return true
endfunction
function lE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990098,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990095,0)
endfunction
function OK takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747989331 then
return false
endif
return true
endfunction
function lK takes nothing returns boolean
if not OK() then
return false
endif
return true
endfunction
function OQ takes nothing returns boolean
if GetResearched()!=1378889802 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889802,true)!=2 then
return false
endif
return true
endfunction
function lQ takes nothing returns boolean
if not OQ() then
return false
endif
return true
endfunction
function lY takes nothing returns nothing
local player iY=GetOwningPlayer(GetAttacker())
local player SY=GetOwningPlayer(GetAttacker())
local player cY
local player oY
local unit OY
set r[GetPlayerId(iY)+1]=r[GetPlayerId(SY)+1]+1
set cY=GetOwningPlayer(GetTriggerUnit())
set oY=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(cY)+1]=r[GetPlayerId(oY)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set OY=GetTriggerUnit()
call SetUnitState(OY,UNIT_STATE_LIFE,GetUnitState(OY,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set iY=null
set SY=null
set cY=null
set oY=null
set OY=null
endfunction
function lk takes nothing returns nothing
local player MF=GetOwningPlayer(GetSpellTargetUnit())
local playerstate wk=PLAYER_STATE_RESOURCE_LUMBER
local playerstate uk
local playerstate rk
local player sk
local force tk
local location ik
local real Sk
local real ck
local player ok
local force Ok
if wk==PLAYER_STATE_RESOURCE_GOLD then
set uk=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(MF,uk,GetPlayerState(MF,uk)+500)
elseif wk==PLAYER_STATE_RESOURCE_LUMBER then
set rk=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(MF,rk,GetPlayerState(MF,rk)+500)
endif
call SetPlayerState(MF,wk,GetPlayerState(MF,wk)+500)
call RemoveUnit(GetSpellAbilityUnit())
set sk=GetOwningPlayer(GetSpellTargetUnit())
set tk=CreateForce()
call ForceAddPlayer(tk,sk)
if IsPlayerInForce(GetLocalPlayer(),tk) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1228")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set ok=GetOwningPlayer(GetSpellTargetUnit())
set Ok=CreateForce()
call ForceAddPlayer(Ok,ok)
set ik=y
set Sk=GetLocationX(ik)
set ck=GetLocationY(ik)
if IsPlayerInForce(GetLocalPlayer(),Ok) then
call PingMinimap(Sk,ck,2.00)
endif
call RemoveLocation(y)
set MF=null
set wk=null
set uk=null
set rk=null
set sk=null
set tk=null
set ik=null
set ok=null
set Ok=null
endfunction
function Oww takes timer cww,string oww returns nothing
set Xb[Lb]=oww
set Lb=Lb+1
if cww==null then
call x1("Trying to release a null timer","when calling error in TimerUtils, line 37")
set Lb=Lb-1
return
endif
if sww(cww,"when calling getData in TimerUtils, line 39")==679645218 then
call x1("ReleaseTimer: Double free!","when calling error in TimerUtils, line 40")
set Lb=Lb-1
return
endif
call Bww(cww,679645218,"when calling setData in TimerUtils, line 42")
call PauseTimer(cww)
set Zo[Uo]=cww
set Uo=Uo+1
set Lb=Lb-1
endfunction
function Bcw takes integer Ccw,string Vcw returns nothing
set Xb[Lb]=Vcw
set Lb=Lb+1
set Xb[Lb]="when calling CallbackSingle_onDestroy in ClosureTimers, line 123"
set Lb=Lb+1
call Oww(ob[Ccw],"when calling release in ClosureTimers, line 124")
set Lb=Lb-1
set Xb[Lb]="when calling dealloc_CallbackSingle in ClosureTimers, line 123"
set Lb=Lb+1
if TO[Ccw]==0 then
call x1("Double free: object of type CallbackSingle","when calling error in ClosureTimers, line 107")
else
set dO[fO]=Ccw
set fO=fO+1
set TO[Ccw]=0
endif
set Lb=Lb-1-1
endfunction
function Nrw takes string Brw returns nothing
endfunction
function Wcw takes integer vcw returns nothing
local integer mcw
local trigger Qcw
call TriggerAddAction(jS,Vf)
call TriggerAddAction(xS,Bf)
call TriggerAddAction(vS,Nf)
set mcw=0
set vcw=bj_MAX_PLAYERS-1
loop
exitwhen mcw>vcw
call TriggerRegisterPlayerEvent(xS,uo[mcw],EVENT_PLAYER_LEAVE)
set Qcw=vS
call TriggerRegisterPlayerEvent(Qcw,uo[mcw],EVENT_PLAYER_ARROW_DOWN_DOWN)
call TriggerRegisterPlayerEvent(Qcw,uo[mcw],EVENT_PLAYER_ARROW_DOWN_UP)
call TriggerRegisterPlayerEvent(Qcw,uo[mcw],EVENT_PLAYER_ARROW_UP_DOWN)
call TriggerRegisterPlayerEvent(Qcw,uo[mcw],EVENT_PLAYER_ARROW_UP_UP)
call TriggerRegisterPlayerEvent(Qcw,uo[mcw],EVENT_PLAYER_ARROW_LEFT_DOWN)
call TriggerRegisterPlayerEvent(Qcw,uo[mcw],EVENT_PLAYER_ARROW_LEFT_UP)
call TriggerRegisterPlayerEvent(Qcw,uo[mcw],EVENT_PLAYER_ARROW_RIGHT_DOWN)
call TriggerRegisterPlayerEvent(Qcw,uo[mcw],EVENT_PLAYER_ARROW_RIGHT_UP)
call TriggerRegisterPlayerEvent(Qcw,uo[mcw],EVENT_PLAYER_END_CINEMATIC)
call TriggerRegisterPlayerChatEvent(Qcw,uo[mcw],"",false)
set mcw=mcw+1
endloop
call Z0w(EVENT_PLAYER_UNIT_SPELL_EFFECT,null,Mf,null)
set Qcw=null
endfunction
function Paw takes integer Zaw,integer Uaw,string Iaw returns nothing
set Xb[Lb]=Iaw
set Lb=Lb+1
if pO[Zaw]==0 then
if Zaw==0 then
call x1("Nullpointer exception when calling City.getCityModifierOnRemove","when calling error in City, line 425")
else
call x1("Called City.getCityModifierOnRemove on invalid object.","when calling error in City, line 425")
endif
endif
set Xb[Lb]="when calling getCityModifierOnRemove in City, line 425"
set Lb=Lb+1
if Yl[ldw(nS,Uaw,"when calling get in City, line 426")]then
set Dl[Zaw]=Dl[Zaw]-Tl[ldw(nS,Uaw,"when calling get in City, line 427")]
endif
set Hl[Zaw]=Hl[Zaw]-Fl[ldw(nS,Uaw,"when calling get in City, line 428")]
set Lb=Lb-1-1
endfunction
function Rdw takes integer ddw,string fdw returns nothing
set Xb[Lb]=fdw
set Lb=Lb+1
if NO[ddw]==0 then
if ddw==0 then
call x1("Nullpointer exception when calling LLEntry.LLEntry","when calling error in LinkedList, line 396")
else
call x1("Called LLEntry.LLEntry on invalid object.","when calling error in LinkedList, line 396")
endif
endif
set Xb[Lb]="when calling destroyLLEntry in LinkedList, line 396"
set Lb=Lb+1
set Xb[Lb]="when calling dealloc_LLEntry in LinkedList, line 396"
set Lb=Lb+1
if NO[ddw]==0 then
call x1("Double free: object of type LLEntry","when calling error in LinkedList, line 396")
else
set CO[VO]=ddw
set VO=VO+1
set NO[ddw]=0
endif
set Lb=Lb-1-1-1
endfunction
function Ddw takes integer Idw,integer Pdw,string Adw returns nothing
set Xb[Lb]=Adw
set Lb=Lb+1
if Sl[Idw]==0 then
if Idw==0 then
call x1("Nullpointer exception when calling LinkedList.removeEntry","when calling error in LinkedList, line 373")
else
call x1("Called LinkedList.removeEntry on invalid object.","when calling error in LinkedList, line 373")
endif
endif
set Xb[Lb]="when calling removeEntry in LinkedList, line 373"
set Lb=Lb+1
set Tb[Rb[Pdw]]=Tb[Pdw]
set Rb[Tb[Pdw]]=Rb[Pdw]
call Rdw(Pdw,"when calling dispatch_LLEntry_destroyLLEntry in LinkedList, line 376")
set kb[Idw]=kb[Idw]-1
set Lb=Lb-1-1
endfunction
function fbw takes integer qbw,integer abw,string nbw returns nothing
local integer dbw
set Xb[Lb]=nbw
set Lb=Lb+1
set dbw=Tb[Fb[qbw]]
loop
exitwhen dbw==Fb[qbw]
if fb[dbw]==abw then
call Ddw(qbw,dbw,"when calling removeEntry in LinkedList, line 126")
set Lb=Lb-1
return
endif
set dbw=Tb[dbw]
endloop
set Lb=Lb-1
endfunction
function Wiw takes integer kiw,integer jiw,string xiw returns boolean
local integer viw
local boolean miw
local integer Qiw
set Xb[Lb]=xiw
set Lb=Lb+1
set viw=Ll[kiw]
set Xb[Lb]="when calling has in City, line 379"
set Lb=Lb+1
if Sl[viw]==0 then
if viw==0 then
call x1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call x1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set miw=ebw(viw,jiw)
set Lb=Lb-1
if not miw then
set Lb=Lb-1
return false
endif
set Qiw=Ll[kiw]
set Xb[Lb]="when calling remove in City, line 381"
set Lb=Lb+1
if Sl[Qiw]==0 then
if Qiw==0 then
call x1("Nullpointer exception when calling LinkedList.remove","when calling error in LinkedList, line 122")
else
call x1("Called LinkedList.remove on invalid object.","when calling error in LinkedList, line 122")
endif
endif
call fbw(Qiw,jiw,"when calling remove in LinkedList, line 122")
set Lb=Lb-1
call K2("Removed a modifier "+kl[ldw(nS,jiw,"when calling get in City, line 382")])
call Paw(kiw,jiw,"when calling getCityModifierOnRemove in City, line 383")
set Lb=Lb-1
return true
endfunction
function Yow takes integer iow,string Sow returns nothing
local integer cow
local integer oow
local integer Oow
local integer low
local integer bow
local integer yow
local integer pow
local unit eow
local player qow
local integer aow
local unit now
local integer dow
local integer fow
local boolean Row
local integer Tow
set Xb[Lb]=Sow
set Lb=Lb+1
set cow=yb[iow]*pb[iow]
set low=dS-1
set bow=(yb[iow]+1)*pb[iow]-1
if low<2147483647 then
set yow=low
else
set yow=2147483647
endif
if bow<yow then
set yow=bow
endif
set oow=yow
loop
exitwhen cow>oow
set pow=FS[cow]
set Xb[Lb]="when calling getCityUnit in Economy, line 36"
set Lb=Lb+1
if pO[pow]==0 then
if pow==0 then
call x1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call x1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set eow=xl[pow]
set Lb=Lb-1
set Oow=GetPlayerId(GetOwningPlayer(eow))
set aow=FS[cow]
set Sow="when calling getCityUnit in Economy, line 37"
set Xb[Lb]="when calling getCityUnit in Economy, line 37"
set Lb=Lb+1
if pO[aow]==0 then
if aow==0 then
call x1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call x1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set now=xl[aow]
set Lb=Lb-1
set qow=GetOwningPlayer(now)
if GetPlayerSlotState(qow)==PLAYER_SLOT_STATE_PLAYING then
set Row=GetPlayerController(qow)==MAP_CONTROL_USER
else
set Row=false
endif
if Row then
set Tow=rc[Oow]
set dow=FS[cow]
set Xb[Lb]="when calling countTax in Economy, line 38"
set Lb=Lb+1
if pO[dow]==0 then
if dow==0 then
call x1("Nullpointer exception when calling City.countTax","when calling error in City, line 279")
else
call x1("Called City.countTax on invalid object.","when calling error in City, line 279")
endif
endif
set fow=iiw(dow,"when calling countTax in City, line 279")
set Lb=Lb-1
set rc[Oow]=Tow+fow
endif
set cow=cow+1
endloop
set Lb=Lb-1
set eow=null
set qow=null
set now=null
endfunction
function H8 takes multiboard Z8,integer U8,integer I8,real P8,string A8 returns nothing
local multiboarditem D8=MultiboardGetItem(Z8,I8,U8)
call MultiboardSetItemWidth(D8,P8)
call MultiboardSetItemValue(D8,A8)
set D8=null
endfunction
function L5 takes string Q5 returns multiboard
local multiboard W5
local integer E5
local integer Z5
local integer U5
local integer I5
local integer P5
local integer A5
local integer D5
local integer H5
local string J5
local real K5
set Xb[Lb]=Q5
set Lb=Lb+1
set W5=CreateMultiboardBJ(6,10,"Income: 2:00")
call MultiboardMinimize(W5,true)
call MultiboardSetItemsStyle(W5,true,false)
set E5=0
set Z5=23
loop
exitwhen E5>Z5
if ro==uo[E5]then
call MultiboardDisplay(W5,false)
endif
set E5=E5+1
endloop
set U5=0
set I5=9
loop
exitwhen U5>I5
set P5=0
set A5=5
loop
exitwhen P5>A5
set K5=Udw(Uc[U5],P5,"when calling get in MultiboardCityUpdate, line 14")/1000.
set D5=Udw(Lc[U5],P5,"when calling get in MultiboardCityUpdate, line 14")
set Xb[Lb]="when calling stringFromIndex in MultiboardCityUpdate, line 14"
set Lb=Lb+1
set H5=Po
set Q5="when calling loadString in TypeCasting, line 35"
set Xb[Lb]="when calling loadString in TypeCasting, line 35"
set Lb=Lb+1
if AO[H5]==0 then
if H5==0 then
call x1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call x1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set J5=LoadStr(Eo,H5,D5)
set Lb=Lb-1-1
call H8(W5,P5,U5,K5,J5)
set P5=P5+1
endloop
set U5=U5+1
endloop
set Lb=Lb-1
set cR=W5
set W5=null
return cR
endfunction
function hyw takes integer nyw,string dyw returns nothing
local integer fyw
local integer Ryw
local integer Tyw
local integer Yyw
local boolean Gyw
local multiboard gyw
set Xb[Lb]=dyw
set Lb=Lb+1
set fyw=0
set nyw=23
loop
exitwhen fyw>nyw
set Yyw=wo[fyw]
set dyw="when calling isInGame in MultiboardCityUpdate, line 20"
set Xb[Lb]="when calling isInGame in MultiboardCityUpdate, line 20"
set Lb=Lb+1
if yl[Yyw]==0 then
if Yyw==0 then
call x1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call x1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set Gyw=Pb[Yyw]
set Lb=Lb-1
if Gyw then
set Xc[fyw]=L5("when calling createCoEMultiboard in MultiboardCityUpdate, line 21")
endif
set fyw=fyw+1
endloop
set Ryw=0
set Tyw=23
loop
exitwhen Ryw>Tyw
set gyw=Xc[Ryw]
if ro==uo[Ryw]then
call MultiboardDisplay(gyw,true)
endif
set Ryw=Ryw+1
endloop
set Lb=Lb-1
set gyw=null
endfunction
function aB takes group bB,integer yB,string pB returns nothing
local group eB
local unit qB
set Xb[Lb]=pB
set Lb=Lb+1
set eB=bB
loop
exitwhen FirstOfGroup(eB)==null
set qB=FirstOfGroup(eB)
call GroupRemoveUnit(eB,qB)
call tnw(yB,qB,"when calling callback in ClosureForGroups, line 40")
endloop
call wnw(yB,"when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 41")
set Lb=Lb-1
set eB=null
set qB=null
endfunction
function i0w takes string r0w returns nothing
local group s0w
local integer t0w
set Xb[Lb]=r0w
set Lb=Lb+1
call RemoveUnit(lo)
set s0w=Oo
set Xb[Lb]="when calling alloc_Preloader_ForGroupCallback_line45 in Preloader, line 45"
set Lb=Lb+1
if qO==0 then
if aO<32768 then
set aO=aO+1
set t0w=aO
set nO[t0w]=689
else
call x1("Out of memory: Could not create Preloader_ForGroupCallback_line45.","when calling error in Preloader, line 45")
set t0w=0
endif
else
set qO=qO-1
set t0w=eO[qO]
set nO[t0w]=689
endif
set Lb=Lb-1
call aB(s0w,t0w,"when calling forEachFrom in Preloader, line 45")
call DestroyGroup(Oo)
set Oo=null
set Lb=Lb-1
set s0w=null
endfunction
function opw takes integer Spw returns nothing
local group cpw
call TriggerRegisterEnterRegion(CreateTrigger(),vc,Filter(uR))
call Z0w(EVENT_PLAYER_UNIT_ISSUED_ORDER,null,rR,null)
call GroupEnumUnitsInRect(Bc,xc,null)
call ForGroup(Bc,sR)
set cpw=Bc
call GroupClear(cpw)
call DestroyGroup(cpw)
set cpw=null
endfunction
function Rnw takes integer qnw,string anw returns nothing
local integer nnw
local integer dnw
local integer fnw
set Xb[Lb]=anw
set Lb=Lb+1
if TO[qnw]==0 then
if qnw==0 then
call x1("Nullpointer exception when calling CallbackSingle.call","when calling error in ClosureTimers, line 109")
else
call x1("Called CallbackSingle.call on invalid object.","when calling error in ClosureTimers, line 109")
endif
endif
if TO[qnw]<=645 then
if TO[qnw]<=642 then
if TO[qnw]<=640 then
if TO[qnw]<=639 then
set Xb[Lb]="when calling City_City_call_line374 in ClosureTimers, line 109"
set Lb=Lb+1
set nnw=Vl[qnw]
set dnw=Bl[qnw]
set Xb[Lb]="when calling removeModifier in City, line 375"
set Lb=Lb+1
if pO[nnw]==0 then
if nnw==0 then
call x1("Nullpointer exception when calling City.removeModifier","when calling error in City, line 378")
else
call x1("Called City.removeModifier on invalid object.","when calling error in City, line 378")
endif
endif
call Wiw(nnw,dnw,"when calling removeModifier in City, line 378")
set Lb=Lb-1-1
else
call Wcw(qnw)
endif
elseif TO[qnw]<=641 then
set LS=LS+50
else
set LS=LS*2
endif
elseif TO[qnw]<=644 then
if TO[qnw]<=643 then
set LS=LS/2
set fnw=LS
if fnw!=250 then
call Nrw("Expected <"+I2S(250)+">, Actual <"+I2S(fnw)+">")
endif
else
call Yow(qnw,"when calling Economy_call_line34 in ClosureTimers, line 109")
endif
else
call IssueImmediateOrderById(nb[qnw],851976)
endif
elseif TO[qnw]<=648 then
if TO[qnw]<=647 then
if TO[qnw]<=646 then
call IssuePointOrderById(mb[qnw],Qb[qnw],Wb[qnw],Eb[qnw])
else
call hyw(qnw,"when calling MultiboardCityUpdate_call_line18 in ClosureTimers, line 109")
endif
else
call IssueImmediateOrderById(Zb[qnw],851976)
endif
elseif TO[qnw]<=650 then
if TO[qnw]<=649 then
call opw(qnw)
else
set Xb[Lb]="when calling Preloader_call_line54 in ClosureTimers, line 109"
set Lb=Lb+1
call i0w("when calling finishPreload in Preloader, line 54")
set Lb=Lb-1
endif
else
call IssueImmediateOrderById(Jb[qnw],851976)
endif
set Lb=Lb-1
endfunction
function FB takes string gB returns nothing
local integer hB
set Xb[Lb]=gB
set Lb=Lb+1
set hB=sww(GetExpiredTimer(),"when calling getData in ClosureTimers, line 119")
call Rnw(hB,"when calling call in ClosureTimers, line 120")
set Xb[Lb]="when calling dispatch_CallbackSingle_destroyCallbackSingle in ClosureTimers, line 121"
set Lb=Lb+1
if TO[hB]==0 then
if hB==0 then
call x1("Nullpointer exception when calling CallbackSingle.CallbackSingle","when calling error in ClosureTimers, line 107")
else
call x1("Called CallbackSingle.CallbackSingle on invalid object.","when calling error in ClosureTimers, line 107")
endif
endif
call Bcw(hB,"when calling destroyCallbackSingle in ClosureTimers, line 107")
set Lb=Lb-1-1
endfunction
function lvw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureTimers, line 114"
set Lb=Lb+1
call FB("when calling staticCallback in ClosureTimers, line 114")
set Lb=Lb-1
endfunction
function m1 takes nothing returns boolean
set qc=CreateTimer()
call TimerStart(qc,100000.,false,null)
call TimerStart(CreateTimer(),0.030,true,Hf)
return true
endfunction
function m2 takes nothing returns boolean
return true
endfunction
function mE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989556,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989570,0)
endfunction
function vG takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function mG takes nothing returns nothing
if vG() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function vK takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747989059 then
return false
endif
return true
endfunction
function mK takes nothing returns boolean
if not vK() then
return false
endif
return true
endfunction
function vQ takes nothing returns boolean
if GetResearched()!=1378889799 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889799,true)!=1 then
return false
endif
return true
endfunction
function mQ takes nothing returns boolean
if not vQ() then
return false
endif
return true
endfunction
function mX takes nothing returns boolean
return true
endfunction
function vg takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function mg takes nothing returns nothing
if vg() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function vh takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function mh takes nothing returns nothing
if vh() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function mj takes nothing returns nothing
local player Rj=GetOwningPlayer(GetKillingUnit())
local playerstate Tj=PLAYER_STATE_RESOURCE_LUMBER
local playerstate Yj
local playerstate Gj
local player gj
local force hj
local location Fj
local real kj
local real jj
local player xj
local force vj
if Tj==PLAYER_STATE_RESOURCE_GOLD then
set Yj=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Rj,Yj,GetPlayerState(Rj,Yj)+250)
elseif Tj==PLAYER_STATE_RESOURCE_LUMBER then
set Gj=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Rj,Gj,GetPlayerState(Rj,Gj)+250)
endif
call SetPlayerState(Rj,Tj,GetPlayerState(Rj,Tj)+250)
set gj=GetOwningPlayer(GetKillingUnit())
set hj=CreateForce()
call ForceAddPlayer(hj,gj)
if IsPlayerInForce(GetLocalPlayer(),hj) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_090")
endif
set y=GetUnitLoc(GetDyingUnit())
set xj=GetOwningPlayer(GetDyingUnit())
set vj=CreateForce()
call ForceAddPlayer(vj,xj)
set Fj=y
set kj=GetLocationX(Fj)
set jj=GetLocationY(Fj)
if IsPlayerInForce(GetLocalPlayer(),vj) then
call PingMinimap(kj,jj,2.00)
endif
call RemoveLocation(y)
set Rj=null
set Tj=null
set Yj=null
set Gj=null
set gj=null
set hj=null
set Fj=null
set xj=null
set vj=null
endfunction
function Gww takes rect aww,string nww,integer dww,integer fww,string Rww returns nothing
local group Tww_2
local unit Yww
set Xb[Lb]=Rww
set Lb=Lb+1
set Tww_2=CreateGroup()
call GroupEnumUnitsInRect(Tww_2,aww,null)
call DestroyBoolExpr(null)
set Yww=FirstOfGroup(Tww_2)
call GroupRemoveUnit(Tww_2,Yww)
set FS[dS]=sSw(Yww,nww,dww,fww,"when calling new_City in SettingCities, line 8")
set Lb=Lb-1
set Tww_2=null
set Yww=null
endfunction
function J4 takes string j4 returns nothing
local integer x4
local integer v4
local real m4
local player Q4
local integer W4
local integer E4
local integer Z4
local boolean U4
local location I4
local integer P4
local real A4
local real D4
local real H4
set Xb[Lb]=j4
set Lb=Lb+1
set x4=24
set v4=6
set m4=100.0
loop
exitwhen x4<=0
set W4=1
set E4=v4
loop
exitwhen W4>E4
set A4=W4*6.28318/v4
set D4=311.2+m4*Cos(A4)
set H4=5166.7+m4*Sin(A4)
set Q4=uo[24-x4+W4-1]
set Z4=wo[GetPlayerId(Q4)]
set j4="when calling isInGame in MainInit, line 54"
set Xb[Lb]="when calling isInGame in MainInit, line 54"
set Lb=Lb+1
if yl[Z4]==0 then
if Z4==0 then
call x1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call x1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set U4=Pb[Z4]
set Lb=Lb-1
if U4 then
set I4=Location(D4,H4)
call CreateNUnitsAtLoc(1,1747988554,Q4,I4,AngleBetweenPoints(I4,Location(311.2,5166.7)))
endif
set W4=W4+1
endloop
set m4=m4+50.0
set x4=x4-v4
set v4=v4+2
if x4<2147483647 then
set P4=x4
else
set P4=2147483647
endif
if v4<P4 then
set P4=v4
endif
set v4=P4
endloop
set Lb=Lb-1
set Q4=null
set I4=null
endfunction
function New takes player Dew,string Hew returns integer
local integer Jew
local integer Kew
local integer Lew
local player Xew
local integer Cew
local integer Vew
local boolean Bew
set Xb[Lb]=Hew
set Lb=Lb+1
set Xb[Lb]="when calling alloc_PlayerStats in PlayerStats, line 16"
set Lb=Lb+1
if ll==0 then
if bl<32768 then
set bl=bl+1
set Kew=bl
set yl[Kew]=714
else
call x1("Out of memory: Could not create PlayerStats.","when calling error in PlayerStats, line 6")
set Kew=0
endif
else
set ll=ll-1
set Kew=Ol[ll]
set yl[Kew]=714
endif
set Lb=Lb-1
set Jew=Kew
set Lew=Kew
set Xew=Dew
set Xb[Lb]="when calling construct_PlayerStats in PlayerStats, line 16"
set Lb=Lb+1
set Pb[Kew]=false
set Hb[Kew]=false
set Db[Kew]=0
set Ub[Kew]=-1
set Ab[Kew]=-1
set Ib[Kew]=Dew
if GetPlayerSlotState(Dew)==PLAYER_SLOT_STATE_PLAYING then
set Bew=GetPlayerController(Dew)==MAP_CONTROL_USER
else
set Bew=false
endif
set Pb[Kew]=Bew
set Cew=0
set Vew=23
loop
exitwhen Cew>Vew
if uo[Cew]==Xew then
call qvw(Lew,Cew,-1,"when writing array PlayerStats_alliance_states in PlayerStats, line 25")
else
call qvw(Lew,Cew,bj_ALLIANCE_UNALLIED,"when writing array PlayerStats_alliance_states in PlayerStats, line 27")
endif
set Cew=Cew+1
endloop
set Lb=Lb-1-1
set Xew=null
return Jew
endfunction
function k4 takes string p4 returns boolean
local integer e4
local integer q4
local trigger a4
local integer n4
local integer d4
local integer f4
local integer R4
local integer T4
local player Y4
local integer G4
local player g4
local boolean h4
local boolean F4
set Xb[Lb]=p4
set Lb=Lb+1
set n4=Tww("You're playing |cffffff65Crusade over Europe|r.\n\nUse your |cff0011ffsettler|r to choose the foundation of your new kingdom.\nThe location you choose will |cffff0000determine the faction you will get|r.\nUse the |cff00ffffF1|r menu to create alliances.\nExpand quickly, Capture cities and ores to |cffff0000increase your income|r.\nUse the |cff00fff2F2|r menu to set the taxes of your newly acquired |cff0026ffcities|r.\nFor more information, please, go to |cff00d3f8F9 menu|r.","when calling stringToIndex in MainInit, line 21")
set Xb[Lb]="when calling asList in MainInit, line 20"
set Lb=Lb+1
set d4=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(d4,n4,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Yc=d4
set f4=0
set R4=0
set T4=23
loop
exitwhen R4>T4
set Y4=uo[R4]
if GetPlayerSlotState(Y4)==PLAYER_SLOT_STATE_PLAYING then
set h4=GetPlayerController(Y4)==MAP_CONTROL_USER
else
set h4=false
endif
if h4 then
set f4=f4+1
endif
set R4=R4+1
endloop
if gc then
call K2("Debug info is enabled. Only for Red.")
endif
if hc then
call DisplayTimedTextToPlayer(ro,0.,0.,45.,"Debug mode is on.")
endif
set Xb[Lb]="when calling setupCities in MainInit, line 106"
set Lb=Lb+1
call Gww(h,"Adrianopolis",3,1,"when calling newCity in SettingCities, line 27")
call Gww(Ss,"Arta",3,0,"when calling newCity in SettingCities, line 28")
call Gww(Br,"Athens",3,1,"when calling newCity in SettingCities, line 29")
call Gww(Vr,"Ragusa",3,0,"when calling newCity in SettingCities, line 30")
call Gww(ls,"Canakkale",3,0,"when calling newCity in SettingCities, line 31")
call Gww(cs,"Candia",3,0,"when calling newCity in SettingCities, line 32")
call Gww(k,"Constantinople",3,4,"when calling newCity in SettingCities, line 33")
call Gww(is,"Corinth",3,0,"when calling newCity in SettingCities, line 34")
call Gww(g,"Durazzo",3,0,"when calling newCity in SettingCities, line 35")
call Gww(ws,"Nikomedeia",3,0,"when calling newCity in SettingCities, line 36")
call Gww(lu,"Kutaisi",3,0,"when calling newCity in SettingCities, line 37")
call Gww(Dw,"Nicae",3,2,"when calling newCity in SettingCities, line 38")
call Gww(Zw,"Nicosia",3,0,"when calling newCity in SettingCities, line 39")
call Gww(Nr,"Rhodes",3,0,"when calling newCity in SettingCities, line 40")
call Gww(x,"Scopia",3,0,"when calling newCity in SettingCities, line 41")
call Gww(Pw,"Smyrna",3,0,"when calling newCity in SettingCities, line 42")
call Gww(bu,"Tbilisi",3,0,"when calling newCity in SettingCities, line 43")
call Gww(Ew,"Trebizond",3,1,"when calling newCity in SettingCities, line 44")
call Gww(F,"Thessalonika",3,3,"when calling newCity in SettingCities, line 45")
call Gww(Qu,"Astrakhan'",1,2,"when calling newCity in SettingCities, line 49")
call Gww(Gw,"Azaq",1,0,"when calling newCity in SettingCities, line 50")
call Gww(ru,"Baia",1,0,"when calling newCity in SettingCities, line 51")
call Gww(cu,"Bryansk",1,0,"when calling newCity in SettingCities, line 52")
call Gww(sw,"Caffa",1,0,"when calling newCity in SettingCities, line 53")
call Gww(U,"Constanta",1,0,"when calling newCity in SettingCities, line 54")
call Gww(iu,"Dnipro",1,0,"when calling newCity in SettingCities, line 55")
call Gww(nw,"Halych",1,0,"when calling newCity in SettingCities, line 56")
call Gww(gw,"Kiev",1,2,"when calling newCity in SettingCities, line 57")
call Gww(N,"Konigsberg",1,0,"when calling newCity in SettingCities, line 58")
call Gww(uw,"Hrodna",1,0,"when calling newCity in SettingCities, line 59")
call Gww(hw,"Minsk",1,1,"when calling newCity in SettingCities, line 60")
call Gww(Su,"Moscow",1,0,"when calling newCity in SettingCities, line 61")
call Gww(Sw,"Novgorod",1,0,"when calling newCity in SettingCities, line 62")
call Gww(tu,"Olesh'e",1,0,"when calling newCity in SettingCities, line 63")
call Gww(cw,"Polotsk",1,0,"when calling newCity in SettingCities, line 64")
call Gww(tw,"Pskov",1,0,"when calling newCity in SettingCities, line 65")
call Gww(iw,"Reval",1,0,"when calling newCity in SettingCities, line 66")
call Gww(M,"Riga",1,1,"when calling newCity in SettingCities, line 67")
call Gww(bs,"Bulgar",1,0,"when calling newCity in SettingCities, line 68")
call Gww(Wu,"Ryazan'",1,0,"when calling newCity in SettingCities, line 69")
call Gww(Ou,"Sarkel",1,0,"when calling newCity in SettingCities, line 70")
call Gww(Fw,"Smolensk",1,1,"when calling newCity in SettingCities, line 71")
call Gww(L,"Sofia",1,0,"when calling newCity in SettingCities, line 72")
call Gww(I,"Targovitse",1,1,"when calling newCity in SettingCities, line 73")
call Gww(uu,"Tmutarakan'",1,0,"when calling newCity in SettingCities, line 74")
call Gww(Mr,"Turku",1,0,"when calling newCity in SettingCities, line 75")
call Gww(rw,"Vilnius",1,1,"when calling newCity in SettingCities, line 76")
call Gww(su,"Zhytomir",1,0,"when calling newCity in SettingCities, line 77")
call Gww(au,"Acre",2,2,"when calling newCity in SettingCities, line 81")
call Gww(mw,"Adana",2,0,"when calling newCity in SettingCities, line 82")
call Gww(as,"Alamut",2,0,"when calling newCity in SettingCities, line 83")
call Gww(nu,"Al-Aqaba",2,0,"when calling newCity in SettingCities, line 84")
call Gww(Nw,"Alexandria",2,2,"when calling newCity in SettingCities, line 85")
call Gww(Kw,"Algiers",2,0,"when calling newCity in SettingCities, line 86")
call Gww(Aw,"Ankara",2,1,"when calling newCity in SettingCities, line 87")
call Gww(Ww,"Antioch",2,2,"when calling newCity in SettingCities, line 88")
call Gww(us,"Badajoz",2,0,"when calling newCity in SettingCities, line 89")
call Gww(Os,"Baghdad",2,4,"when calling newCity in SettingCities, line 90")
call Gww(ns,"Baku",2,0,"when calling newCity in SettingCities, line 91")
call Gww(Cw,"Benghazi",2,1,"when calling newCity in SettingCities, line 92")
call Gww(es,"Beleb-el-Anab",2,0,"when calling newCity in SettingCities, line 93")
call Gww(wu,"Cairo",2,3,"when calling newCity in SettingCities, line 94")
call Gww(Tr,"Cordoba",2,4,"when calling newCity in SettingCities, line 95")
call Gww(yu,"Damascus",2,2,"when calling newCity in SettingCities, line 96")
call Gww(Mw,"Damietta",2,1,"when calling newCity in SettingCities, line 97")
call Gww(Ru,"Diyarbakir",2,0,"when calling newCity in SettingCities, line 98")
call Gww(Iw,"Edessa",2,1,"when calling newCity in SettingCities, line 99")
call Gww(Tu,"Erez",2,1,"when calling newCity in SettingCities, line 100")
call Gww(Hw,"Fes",2,3,"when calling newCity in SettingCities, line 101")
call Gww(eu,"Gaza",2,0,"when calling newCity in SettingCities, line 102")
call Gww(Rr,"Granada",2,2,"when calling newCity in SettingCities, line 103")
call Gww(xw,"Isparta",2,0,"when calling newCity in SettingCities, line 104")
call Gww(Uw,"Jerusalem",2,3,"when calling newCity in SettingCities, line 105")
call Gww(vw,"Kayseri",2,1,"when calling newCity in SettingCities, line 106")
call Gww(os,"Kerak",2,0,"when calling newCity in SettingCities, line 107")
call Gww(ds,"Kermanshah",2,0,"when calling newCity in SettingCities, line 108")
call Gww(Qw,"Konya",2,0,"when calling newCity in SettingCities, line 109")
call Gww(Sr,"Lisbon",2,0,"when calling newCity in SettingCities, line 110")
call Gww(Ur,"Luxor",2,0,"when calling newCity in SettingCities, line 111")
call Gww(tr,"Madrid",2,0,"when calling newCity in SettingCities, line 112")
call Gww(Lw,"Mahdya",2,0,"when calling newCity in SettingCities, line 113")
call Gww(Zr,"Marrakesh",2,3,"when calling newCity in SettingCities, line 114")
call Gww(Bw,"Medina",2,2,"when calling newCity in SettingCities, line 115")
call Gww(ps,"Melilla",2,0,"when calling newCity in SettingCities, line 116")
call Gww(qu,"Mosul",2,1,"when calling newCity in SettingCities, line 117")
call Gww(Yr,"Murcia",2,1,"when calling newCity in SettingCities, line 118")
call Gww(Jw,"Oran",2,0,"when calling newCity in SettingCities, line 119")
call Gww(mu,"Palma",2,1,"when calling newCity in SettingCities, line 120")
call Gww(du,"Quarisiya",2,1,"when calling newCity in SettingCities, line 121")
call Gww(Er,"Silves",2,0,"when calling newCity in SettingCities, line 122")
call Gww(jw,"Sinop",2,0,"when calling newCity in SettingCities, line 123")
call Gww(fu,"Tamiya",2,0,"when calling newCity in SettingCities, line 124")
call Gww(pu,"Tartus",2,0,"when calling newCity in SettingCities, line 125")
call Gww(qs,"Tabriz",2,0,"when calling newCity in SettingCities, line 126")
call Gww(Xw,"Tripoli",2,1,"when calling newCity in SettingCities, line 127")
call Gww(Yw,"Tunis",2,1,"when calling newCity in SettingCities, line 128")
call Gww(Gr,"Valencia",2,0,"when calling newCity in SettingCities, line 129")
call Gww(ou,"Yerevan",2,0,"when calling newCity in SettingCities, line 130")
call Gww(J,"Aarhus",0,1,"when calling newCity in SettingCities, line 134")
call Gww(Zu,"Aberdeen",0,1,"when calling newCity in SettingCities, line 135")
call Gww(Ar,"Ajaccio",0,0,"when calling newCity in SettingCities, line 136")
call Gww(dr,"Ancona",0,1,"when calling newCity in SettingCities, line 137")
call Gww(Pr,"Angers",0,0,"when calling newCity in SettingCities, line 138")
call Gww(yr,"Antwerp",0,0,"when calling newCity in SettingCities, line 139")
call Gww(ur,"Barcelona",0,1,"when calling newCity in SettingCities, line 140")
call Gww(Kr,"Bari",0,0,"when calling newCity in SettingCities, line 141")
call Gww(A,"Belgrade",0,1,"when calling newCity in SettingCities, line 142")
call Gww(mr,"Bergen",0,1,"when calling newCity in SettingCities, line 143")
call Gww(hr,"Bern",0,0,"when calling newCity in SettingCities, line 144")
call Gww(ar,"Bologna",0,1,"when calling newCity in SettingCities, line 145")
call Gww(Mu,"Bordeaux",0,1,"when calling newCity in SettingCities, line 146")
call Gww(P,"Brasov",0,0,"when calling newCity in SettingCities, line 147")
call Gww(br,"Bruges",0,0,"when calling newCity in SettingCities, line 148")
call Gww(f,"Burgh",0,0,"when calling newCity in SettingCities, line 149")
call Gww(sr,"Burgos",0,1,"when calling newCity in SettingCities, line 150")
call Gww(Lu,"Caen",0,0,"when calling newCity in SettingCities, line 151")
call Gww(Du,"Caenarfon",0,0,"when calling newCity in SettingCities, line 152")
call Gww(Dr,"Cagliari",0,0,"when calling newCity in SettingCities, line 153")
call Gww(R,"Cardiff",0,0,"when calling newCity in SettingCities, line 154")
call Gww(Bu,"Clermont",0,1,"when calling newCity in SettingCities, line 155")
call Gww(ju,"Cologne",0,1,"when calling newCity in SettingCities, line 156")
call Gww(Vu,"Dijon",0,0,"when calling newCity in SettingCities, line 157")
call Gww(Pu,"Dublin",0,0,"when calling newCity in SettingCities, line 158")
call Gww(Eu,"Edinburgh",0,0,"when calling newCity in SettingCities, line 159")
call Gww(vr,"Eikundarsund",0,0,"when calling newCity in SettingCities, line 160")
call Gww(Q,"Esztergom",0,1,"when calling newCity in SettingCities, line 161")
call Gww(Ku,"Exeter",0,0,"when calling newCity in SettingCities, line 162")
call Gww(ww,"Gdansk",0,0,"when calling newCity in SettingCities, line 163")
call Gww(D,"Flensburg",0,0,"when calling newCity in SettingCities, line 164")
call Gww(xu,"Frankfurt",0,1,"when calling newCity in SettingCities, line 165")
call Gww(T,"Galway",0,0,"when calling newCity in SettingCities, line 166")
call Gww(pr,"Genoa",0,2,"when calling newCity in SettingCities, line 167")
call Gww(Tw,"Groningen",0,0,"when calling newCity in SettingCities, line 168")
call Gww(ku,"Innsbruck",0,0,"when calling newCity in SettingCities, line 169")
call Gww(Uu,"Inverness",0,0,"when calling newCity in SettingCities, line 170")
call Gww(Au,"Desmond",0,0,"when calling newCity in SettingCities, line 171")
call Gww(Jr,"Reggio",0,0,"when calling newCity in SettingCities, line 173")
call Gww(ts,"Kalmar",0,0,"when calling newCity in SettingCities, line 174")
call Gww(V,"Kassa",0,0,"when calling newCity in SettingCities, line 175")
call Gww(E,"Krakow",0,2,"when calling newCity in SettingCities, line 176")
call Gww(rr,"Leon",0,1,"when calling newCity in SettingCities, line 177")
call Gww(Hu,"London",0,0,"when calling newCity in SettingCities, line 178")
call Gww(kr,"Lund",0,0,"when calling newCity in SettingCities, line 179")
call Gww(Fr,"Lyon",0,0,"when calling newCity in SettingCities, line 180")
call Gww(K,"Madgeburg",0,0,"when calling newCity in SettingCities, line 181")
call Gww(lr,"Marsellie",0,1,"when calling newCity in SettingCities, line 182")
call Gww(Cr,"Metz",0,0,"when calling newCity in SettingCities, line 183")
call Gww(er,"Milan",0,1,"when calling newCity in SettingCities, line 184")
call Gww(Hr,"Naples",0,1,"when calling newCity in SettingCities, line 185")
call Gww(gr,"Nuremburg",0,0,"when calling newCity in SettingCities, line 186")
call Gww(Wr,"Nykoping",0,0,"when calling newCity in SettingCities, line 187")
call Gww(rs,"Oporto",0,0,"when calling newCity in SettingCities, line 188")
call Gww(xr,"Oslo",0,1,"when calling newCity in SettingCities, line 189")
call Gww(ys,"Buda",0,1,"when calling newCity in SettingCities, line 190")
call Gww(Lr,"Palermo",0,3,"when calling newCity in SettingCities, line 191")
call Gww(cr,"Pamplona",0,0,"when calling newCity in SettingCities, line 192")
call Gww(Cu,"Paris",0,1,"when calling newCity in SettingCities, line 193")
call Gww(nr,"Pisa",0,0,"when calling newCity in SettingCities, line 194")
call Gww(X,"Plock",0,0,"when calling newCity in SettingCities, line 195")
call Gww(C,"Poznan",0,1,"when calling newCity in SettingCities, line 196")
call Gww(m,"Prague",0,0,"when calling newCity in SettingCities, line 197")
call Gww(G,"Zadar",0,0,"when calling newCity in SettingCities, line 198")
call Gww(Ir,"Rennes",0,0,"when calling newCity in SettingCities, line 199")
call Gww(Xu,"Rheims",0,0,"when calling newCity in SettingCities, line 200")
call Gww(fr,"Rome",0,1,"when calling newCity in SettingCities, line 201")
call Gww(H,"Roskilde",0,0,"when calling newCity in SettingCities, line 202")
call Gww(ir,"Salamanca",0,0,"when calling newCity in SettingCities, line 203")
call Gww(Fu,"Salzburg",0,0,"when calling newCity in SettingCities, line 204")
call Gww(jr,"Skara",0,0,"when calling newCity in SettingCities, line 205")
call Gww(W,"Stettin",0,0,"when calling newCity in SettingCities, line 206")
call Gww(ss,"Stockholm",0,1,"when calling newCity in SettingCities, line 207")
call Gww(Xr,"Syracuse",0,0,"when calling newCity in SettingCities, line 208")
call Gww(Nu,"Toulouse",0,0,"when calling newCity in SettingCities, line 209")
call Gww(B,"Varad",0,0,"when calling newCity in SettingCities, line 210")
call Gww(qr,"Venice",0,2,"when calling newCity in SettingCities, line 211")
call Gww(v,"Vienna",0,0,"when calling newCity in SettingCities, line 212")
call Gww(Qr,"Visby",0,0,"when calling newCity in SettingCities, line 213")
call Gww(j,"Warwick",0,0,"when calling newCity in SettingCities, line 214")
call Gww(Ju,"Winchester",0,1,"when calling newCity in SettingCities, line 215")
call Gww(Z,"Wroclaw",0,0,"when calling newCity in SettingCities, line 216")
call Gww(Iu,"York",0,1,"when calling newCity in SettingCities, line 217")
call Gww(Y,"Zagreb",0,0,"when calling newCity in SettingCities, line 218")
call Gww(wr,"Zaragoza",0,0,"when calling newCity in SettingCities, line 219")
call Gww(vu,"Hamburg",0,1,"when calling newCity in SettingCities, line 220")
set Lb=Lb-1
call SetForceAllianceStateBJ(bj_FORCE_ALL_PLAYERS,bj_FORCE_PLAYER[PLAYER_NEUTRAL_PASSIVE],bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(bj_FORCE_ALL_PLAYERS,bj_FORCE_ALL_PLAYERS,bj_ALLIANCE_UNALLIED)
call SetForceAllianceStateBJ(cc,cc,bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(oc,oc,bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(Oc,Oc,bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(lc,lc,bj_ALLIANCE_NEUTRAL)
set e4=0
set q4=23
loop
exitwhen e4>q4
call SetPlayerState(uo[e4],PLAYER_STATE_RESOURCE_GOLD,200)
call SetPlayerState(uo[e4],PLAYER_STATE_RESOURCE_LUMBER,200)
if hc then
call q2(uo[e4])
endif
set wo[e4]=New(uo[e4],"when calling new_PlayerStats in MainInit, line 127")
set G4=wo[e4]
set g4=uo[e4]
if GetPlayerSlotState(g4)==PLAYER_SLOT_STATE_PLAYING then
set F4=GetPlayerController(g4)==MAP_CONTROL_USER
else
set F4=false
endif
set Xb[Lb]="when calling setInGame in MainInit, line 128"
set Lb=Lb+1
if yl[G4]==0 then
if G4==0 then
call x1("Nullpointer exception when calling PlayerStats.setInGame","when calling error in PlayerStats, line 45")
else
call x1("Called PlayerStats.setInGame on invalid object.","when calling error in PlayerStats, line 45")
endif
endif
set Pb[G4]=F4
set Lb=Lb-1
set e4=e4+1
endloop
call J4("when calling setPlayersAtStart in MainInit, line 130")
set a4=CreateTrigger()
call TriggerRegisterTimerEvent(a4,0.01,false)
call TriggerAddAction(a4,Kf)
set Lb=Lb-1
set a4=null
set Y4=null
set g4=null
return true
endfunction
function mxw takes nothing returns boolean
set Lb=0
return k4("MainInit, line 1")
endfunction
function initMapBounds takes nothing returns nothing
local rect cond_result
local region receiver
local real temp
local real tuple_temp
set jc=bj_mapInitialPlayableArea
call RegionAddRect(CreateRegion(),jc)
set cond_result=GetWorldBounds()
set xc=cond_result
set receiver=CreateRegion()
call RegionAddRect(receiver,xc)
set vc=receiver
set temp=GetRectMaxX(xc)
set tuple_temp=GetRectMaxY(xc)
set mc=temp
set Qc=tuple_temp
endfunction
function n2 takes nothing returns boolean
call initMapBounds()
return true
endfunction
function aD takes nothing returns boolean
if GetResearched()!=1378890041 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890041,true)!=1 then
return false
endif
return true
endfunction
function nD takes nothing returns boolean
if not aD() then
return false
endif
return true
endfunction
function nE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990099,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990096,0)
endfunction
function aK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990350 then
return false
endif
return true
endfunction
function nK takes nothing returns boolean
if not aK() then
return false
endif
return true
endfunction
function aQ takes nothing returns boolean
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=1 then
return false
endif
return true
endfunction
function nQ takes nothing returns boolean
if not aQ() then
return false
endif
return true
endfunction
function qk takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function ak takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988791 then
return false
endif
if not qk() then
return false
endif
return true
endfunction
function nk takes nothing returns boolean
if not ak() then
return false
endif
return true
endfunction
function Gfw takes integer Bdw,integer Ndw,integer Mdw,integer wfw,integer ufw,integer rfw,integer sfw,integer tfw,integer ifw,integer Sfw,integer cfw,integer ofw,integer Ofw,integer lfw,integer bfw,integer yfw,integer pfw,integer efw,integer qfw,integer afw,integer nfw,integer dfw,integer ffw,integer Rfw,string Tfw returns integer
local integer Yfw
set Xb[Lb]=Tfw
set Lb=Lb+1
set Yfw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(Yfw,Bdw,"when calling add in LinkedList, line 393")
call jfw(Yfw,Ndw,"when calling add in LinkedList, line 393")
call jfw(Yfw,Mdw,"when calling add in LinkedList, line 393")
call jfw(Yfw,wfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,ufw,"when calling add in LinkedList, line 393")
call jfw(Yfw,rfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,sfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,tfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,ifw,"when calling add in LinkedList, line 393")
call jfw(Yfw,Sfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,cfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,ofw,"when calling add in LinkedList, line 393")
call jfw(Yfw,Ofw,"when calling add in LinkedList, line 393")
call jfw(Yfw,lfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,bfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,yfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,pfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,efw,"when calling add in LinkedList, line 393")
call jfw(Yfw,qfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,afw,"when calling add in LinkedList, line 393")
call jfw(Yfw,nfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,dfw,"when calling add in LinkedList, line 393")
call jfw(Yfw,ffw,"when calling add in LinkedList, line 393")
call jfw(Yfw,Rfw,"when calling add in LinkedList, line 393")
set Lb=Lb-1
return Yfw
endfunction
function wN takes string MB returns boolean
set Xb[Lb]=MB
set Lb=Lb+1
set MS=Gfw(Tww("red","when calling stringToIndex in CommandTools, line 5"),Tww("blue","when calling stringToIndex in CommandTools, line 6"),Tww("teal","when calling stringToIndex in CommandTools, line 7"),Tww("purple","when calling stringToIndex in CommandTools, line 8"),Tww("yellow","when calling stringToIndex in CommandTools, line 9"),Tww("orange","when calling stringToIndex in CommandTools, line 10"),Tww("green","when calling stringToIndex in CommandTools, line 11"),Tww("pink","when calling stringToIndex in CommandTools, line 12"),Tww("grey","when calling stringToIndex in CommandTools, line 13"),Tww("light blue","when calling stringToIndex in CommandTools, line 14"),Tww("dark green","when calling stringToIndex in CommandTools, line 15"),Tww("brown","when calling stringToIndex in CommandTools, line 16"),Tww("maroon","when calling stringToIndex in CommandTools, line 17"),Tww("navy","when calling stringToIndex in CommandTools, line 18"),Tww("turquoise","when calling stringToIndex in CommandTools, line 19"),Tww("violet","when calling stringToIndex in CommandTools, line 20"),Tww("wheat","when calling stringToIndex in CommandTools, line 21"),Tww("peach","when calling stringToIndex in CommandTools, line 22"),Tww("mint","when calling stringToIndex in CommandTools, line 23"),Tww("lavender","when calling stringToIndex in CommandTools, line 24"),Tww("coal","when calling stringToIndex in CommandTools, line 25"),Tww("snow","when calling stringToIndex in CommandTools, line 26"),Tww("emerald","when calling stringToIndex in CommandTools, line 27"),Tww("peanut","when calling stringToIndex in CommandTools, line 28"),"when calling asList in CommandTools, line 4")
set Lb=Lb-1
return true
endfunction
function nxw takes nothing returns boolean
set Lb=0
return wN("CommandTools, line 1")
endfunction
function cH takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())==1747988545 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747989577 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747990320 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747989845 then
return true
endif
return false
endfunction
function oH takes nothing returns boolean
if p[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]!=false then
return false
endif
if not cH() then
return false
endif
return true
endfunction
function cL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989591 then
return false
endif
return true
endfunction
function oL takes nothing returns boolean
if not cL() then
return false
endif
return true
endfunction
function oP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990321,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990104,0)
endfunction
function cU takes nothing returns boolean
if GetResearched()!=1378889818 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889818,true)!=2 then
return false
endif
return true
endfunction
function oU takes nothing returns boolean
if not cU() then
return false
endif
return true
endfunction
function cW takes nothing returns boolean
if GetResearched()!=1378889800 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889800,true)!=1 then
return false
endif
return true
endfunction
function oW takes nothing returns boolean
if not cW() then
return false
endif
return true
endfunction
function oZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651833,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651841,0)
endfunction
function fV takes string aV returns boolean
local integer nV
local timer dV
set Xb[Lb]=aV
set Lb=Lb+1
set kS=ConvertPlayerEvent(96)
set WS=wlw("when calling new_HashMap in ClosureEvents, line 99")
set ES=wlw("when calling new_HashMap in ClosureEvents, line 100")
set jS=CreateTrigger()
set xS=CreateTrigger()
set vS=CreateTrigger()
call TriggerAddCondition(Ao,Condition(Qf))
call TriggerAddCondition(Do,Condition(Wf))
set Xb[Lb]="when calling alloc_ClosureEvents_CallbackSingle_line290 in ClosureEvents, line 290"
set Lb=Lb+1
if fO==0 then
if RO<32768 then
set RO=RO+1
set nV=RO
set TO[nV]=640
else
call x1("Out of memory: Could not create ClosureEvents_CallbackSingle_line290.","when calling error in ClosureEvents, line 290")
set nV=0
endif
else
set fO=fO-1
set nV=dO[fO]
set TO[nV]=640
endif
set Lb=Lb-1
set Xb[Lb]="when calling nullTimer in ClosureEvents, line 290"
set Lb=Lb+1
set Xb[Lb]="when calling doAfter in ClosureTimers, line 33"
set Lb=Lb+1
set dV=Sww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call hnw(nV,dV,0.,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1
set Lb=Lb-1-1-1
set dV=null
return true
endfunction
function oxw takes nothing returns boolean
set Lb=0
return fV("ClosureEvents, line 1")
endfunction
function pA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651852,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651855,0)
endfunction
function pC takes nothing returns boolean
local boolean bC
local boolean yC
if GetUnitTypeId(GetSpellAbilityUnit())==1747988553 then
set bC=GetUnitTypeId(GetSpellTargetUnit())==1747989297
else
set bC=false
endif
if bC then
set yC=GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))==PLAYER_NEUTRAL_AGGRESSIVE
else
set yC=false
endif
return yC
endfunction
function yI takes nothing returns boolean
if GetResearched()!=1378889797 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=2 then
return false
endif
return true
endfunction
function pI takes nothing returns boolean
if not yI() then
return false
endif
return true
endfunction
function pJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function pX takes nothing returns boolean
return true
endfunction
function pm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988566,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988562,0)
endfunction
function eL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990327 then
return false
endif
return true
endfunction
function qL takes nothing returns boolean
if not eL() then
return false
endif
return true
endfunction
function qP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990322,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990105,0)
endfunction
function eU takes nothing returns boolean
if GetResearched()!=1378890037 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890037,true)!=1 then
return false
endif
return true
endfunction
function qU takes nothing returns boolean
if not eU() then
return false
endif
return true
endfunction
function eW takes nothing returns boolean
if GetResearched()!=1378889800 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889800,true)!=2 then
return false
endif
return true
endfunction
function qW takes nothing returns boolean
if not eW() then
return false
endif
return true
endfunction
function qZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989560,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989579,0)
endfunction
function qxw takes nothing returns boolean
local integer lxw
local integer bxw
local integer yxw
local integer pxw
local integer exw
set Lb=0
set Xb[Lb]="City, line 1"
set Lb=Lb+1
set fS=120.0
set RS[0]=0.0020
set RS[1]=0.0025
set Xb[Lb]="when calling asList in City, line 37"
set Lb=Lb+1
set lxw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(lxw,10000,"when calling add in LinkedList, line 393")
call jfw(lxw,20000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set TS[0]=lxw
set Xb[Lb]="when calling asList in City, line 38"
set Lb=Lb+1
set bxw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(bxw,30000,"when calling add in LinkedList, line 393")
call jfw(bxw,40000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set TS[1]=bxw
set Xb[Lb]="when calling asList in City, line 39"
set Lb=Lb+1
set yxw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(yxw,60000,"when calling add in LinkedList, line 393")
call jfw(yxw,90000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set TS[2]=yxw
set Xb[Lb]="when calling asList in City, line 40"
set Lb=Lb+1
set pxw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(pxw,120000,"when calling add in LinkedList, line 393")
call jfw(pxw,160000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set TS[3]=pxw
set Xb[Lb]="when calling asList in City, line 41"
set Lb=Lb+1
set exw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(exw,180000,"when calling add in LinkedList, line 393")
call jfw(exw,220000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set TS[4]=exw
set YS[0]=1.0
set YS[1]=0.5
set YS[2]=1.6
set YS[3]=2.0
set GS[0]=0.0
set GS[1]=20.0
set GS[2]=-25.0
set GS[3]=-60.0
set gS[0]=0.05
set gS[1]=0.0
set gS[2]=0.15
set gS[3]=0.30
set hS[0]=1.0
set hS[1]=1.1
set hS[2]=0.85
set hS[3]=0.7
set Lb=Lb-1
return true
endfunction
function uE takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function rE takes nothing returns boolean
if not uE() then
return false
endif
return true
endfunction
function rH takes nothing returns nothing
local integer CD=1
local integer VD=1747988787
local player BD=GetOwningPlayer(GetConstructedStructure())
local rect uH=bj_mapInitialPlayableArea
local location wH=Location(GetRectCenterX(uH),GetRectCenterY(uH))
local location ND=Location(GetLocationX(wH)+100000000.00,GetLocationY(wH)+1000000000.00)
local real MD=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set CD=CD-1
exitwhen CD<0
call CreateUnitAtLocSaveLast(BD,VD,ND,MD)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call UnitRemoveAbility(bj_lastCreatedUnit,1093677905)
call ShowUnit(bj_lastCreatedUnit,false)
set e[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]=true
set BD=null
set ND=null
set wH=null
set uH=null
endfunction
function rL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function rU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989825,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989817,0)
endfunction
function rW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989082,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989072,0)
endfunction
function rj takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988792 then
return false
endif
return true
endfunction
function Aqw takes integer Iqw,unit Pqw returns nothing
set Kb[Iqw]=Pqw
call SetUnitUserData(Kb[Iqw],Iqw)
set Ho[Jo]=Pqw
set Jo=Jo+1
call TriggerEvaluate(Ao)
set Jo=Jo-1
endfunction
function Uqw takes unit Wqw,string Eqw returns integer
local integer Zqw
set Xb[Lb]=Eqw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_UnitIndex in UnitIndexer, line 181"
set Lb=Lb+1
if nl==0 then
if dl<32768 then
set dl=dl+1
set Zqw=dl
set fl[Zqw]=738
else
call x1("Out of memory: Could not create UnitIndex.","when calling error in UnitIndexer, line 172")
set Zqw=0
endif
else
set nl=nl-1
set Zqw=al[nl]
set fl[Zqw]=738
endif
set Lb=Lb-1
call Aqw(Zqw,Wqw)
set Lb=Lb-1
return Zqw
endfunction
function Hqw takes integer Dqw returns nothing
set Ho[Jo]=Kb[Dqw]
set Jo=Jo+1
call TriggerEvaluate(Do)
set Jo=Jo-1
call SetUnitUserData(Kb[Dqw],0)
endfunction
function Vdw takes integer Xdw,string Cdw returns nothing
set Xb[Lb]=Cdw
set Lb=Lb+1
if fl[Xdw]==0 then
if Xdw==0 then
call x1("Nullpointer exception when calling UnitIndex.UnitIndex","when calling error in UnitIndexer, line 172")
else
call x1("Called UnitIndex.UnitIndex on invalid object.","when calling error in UnitIndexer, line 172")
endif
endif
set Xb[Lb]="when calling destroyUnitIndex in UnitIndexer, line 172"
set Lb=Lb+1
call Hqw(Xdw)
set Xb[Lb]="when calling dealloc_UnitIndex in UnitIndexer, line 188"
set Lb=Lb+1
if fl[Xdw]==0 then
call x1("Double free: object of type UnitIndex","when calling error in UnitIndexer, line 172")
else
set al[nl]=Xdw
set nl=nl+1
set fl[Xdw]=0
endif
set Lb=Lb-1-1-1
endfunction
function Nww takes unit Cww,string Vww returns boolean
local integer Bww_2
set Xb[Lb]=Vww
set Lb=Lb+1
if GetUnitUserData(Cww)==0 then
set Lb=Lb-1
return false
else
set Xb[Lb]="when calling toUnitIndex in UnitIndexer, line 169"
set Lb=Lb+1
set Bww_2=GetUnitUserData(Cww)
if Bww_2==0 then
set Bww_2=Uqw(Cww,"when calling new_UnitIndex in UnitIndexer, line 135")
endif
set Lb=Lb-1
call Vdw(Bww_2,"when calling dispatch_UnitIndex_destroyUnitIndex in UnitIndexer, line 169")
set Lb=Lb-1
return true
endif
endfunction
function suw takes string ruw returns nothing
set Xb[Lb]=ruw
set Lb=Lb+1
call Nww(Nc[Mc-1],"when calling deindex in UnitIndexer, line 197")
set Lb=Lb-1
endfunction
function rvw takes nothing returns nothing
set Lb=0
call suw("UnitIndexer, line 197")
endfunction
function rx takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988793 then
return false
endif
return true
endfunction
function YGw takes integer rGw,integer sGw,integer tGw,integer iGw,integer SGw,integer cGw,integer oGw,integer OGw,integer lGw,integer bGw,integer yGw,integer pGw,integer eGw,integer qGw,integer aGw,integer nGw,integer dGw,integer fGw,string RGw returns integer
local integer TGw
set Xb[Lb]=RGw
set Lb=Lb+1
set TGw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(TGw,rGw,"when calling add in LinkedList, line 393")
call jfw(TGw,sGw,"when calling add in LinkedList, line 393")
call jfw(TGw,tGw,"when calling add in LinkedList, line 393")
call jfw(TGw,iGw,"when calling add in LinkedList, line 393")
call jfw(TGw,SGw,"when calling add in LinkedList, line 393")
call jfw(TGw,cGw,"when calling add in LinkedList, line 393")
call jfw(TGw,oGw,"when calling add in LinkedList, line 393")
call jfw(TGw,OGw,"when calling add in LinkedList, line 393")
call jfw(TGw,lGw,"when calling add in LinkedList, line 393")
call jfw(TGw,bGw,"when calling add in LinkedList, line 393")
call jfw(TGw,yGw,"when calling add in LinkedList, line 393")
call jfw(TGw,pGw,"when calling add in LinkedList, line 393")
call jfw(TGw,eGw,"when calling add in LinkedList, line 393")
call jfw(TGw,qGw,"when calling add in LinkedList, line 393")
call jfw(TGw,aGw,"when calling add in LinkedList, line 393")
call jfw(TGw,nGw,"when calling add in LinkedList, line 393")
call jfw(TGw,dGw,"when calling add in LinkedList, line 393")
call jfw(TGw,fGw,"when calling add in LinkedList, line 393")
set Lb=Lb-1
return TGw
endfunction
function Kgw takes integer xgw,integer vgw,integer mgw,integer Qgw,integer Wgw,integer Egw,integer Zgw,integer Ugw,integer Igw,integer Pgw,integer Agw,integer Dgw,integer Hgw,string Jgw returns nothing
set Xb[Lb]=Jgw
set Lb=Lb+1
call SaveInteger(dc,xgw,eb[xgw],vgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,vgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],mgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,mgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Qgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Qgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Wgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Wgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Egw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Egw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Zgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Zgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Ugw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Ugw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Igw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Igw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Pgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Pgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Agw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Agw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Dgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Dgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
call SaveInteger(dc,xgw,eb[xgw],Hgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[xgw]==0 then
if xgw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(xgw,Hgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xgw]=eb[xgw]+1
set Lb=Lb-1
endfunction
function Khw takes integer Lgw,integer Xgw,integer Cgw,integer Vgw,integer Bgw,integer Ngw,integer Mgw,integer whw,integer uhw,integer rhw,integer shw,integer thw,integer ihw,string Shw returns nothing
local integer chw
local hashtable ohw
local integer Ohw
local integer lhw
local hashtable bhw
local integer yhw
local integer phw
local hashtable ehw
local integer qhw
local integer ahw
local hashtable nhw
local integer dhw
local integer fhw
local hashtable Rhw
local integer Thw
local integer Yhw
local hashtable Ghw
local integer ghw
local integer hhw
local hashtable Fhw
local integer khw
local integer jhw
local hashtable xhw
local integer vhw
local integer mhw
local hashtable Qhw
local integer Whw
local integer Ehw
local hashtable Zhw
local integer Uhw
local integer Ihw
local hashtable Phw
local integer Ahw
local integer Dhw
local hashtable Hhw
local integer Jhw
set Xb[Lb]=Shw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set chw=LoadInteger(fc,Lgw,Xgw)
set Lb=Lb-1
if chw<=0 then
set ohw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Ohw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(ohw,Lgw,Xgw,Ohw)
call Djw(Lgw,Xgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set lhw=LoadInteger(fc,Lgw,Cgw)
set Lb=Lb-1
if lhw<=0 then
set bhw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set yhw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(bhw,Lgw,Cgw,yhw)
call Djw(Lgw,Cgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set phw=LoadInteger(fc,Lgw,Vgw)
set Lb=Lb-1
if phw<=0 then
set ehw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set qhw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(ehw,Lgw,Vgw,qhw)
call Djw(Lgw,Vgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ahw=LoadInteger(fc,Lgw,Bgw)
set Lb=Lb-1
if ahw<=0 then
set nhw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set dhw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(nhw,Lgw,Bgw,dhw)
call Djw(Lgw,Bgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set fhw=LoadInteger(fc,Lgw,Ngw)
set Lb=Lb-1
if fhw<=0 then
set Rhw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Thw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(Rhw,Lgw,Ngw,Thw)
call Djw(Lgw,Ngw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Yhw=LoadInteger(fc,Lgw,Mgw)
set Lb=Lb-1
if Yhw<=0 then
set Ghw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ghw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(Ghw,Lgw,Mgw,ghw)
call Djw(Lgw,Mgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set hhw=LoadInteger(fc,Lgw,whw)
set Lb=Lb-1
if hhw<=0 then
set Fhw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set khw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(Fhw,Lgw,whw,khw)
call Djw(Lgw,whw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set jhw=LoadInteger(fc,Lgw,uhw)
set Lb=Lb-1
if jhw<=0 then
set xhw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set vhw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(xhw,Lgw,uhw,vhw)
call Djw(Lgw,uhw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set mhw=LoadInteger(fc,Lgw,rhw)
set Lb=Lb-1
if mhw<=0 then
set Qhw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Whw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(Qhw,Lgw,rhw,Whw)
call Djw(Lgw,rhw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Ehw=LoadInteger(fc,Lgw,shw)
set Lb=Lb-1
if Ehw<=0 then
set Zhw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Uhw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(Zhw,Lgw,shw,Uhw)
call Djw(Lgw,shw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Ihw=LoadInteger(fc,Lgw,thw)
set Lb=Lb-1
if Ihw<=0 then
set Phw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Ahw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(Phw,Lgw,thw,Ahw)
call Djw(Lgw,thw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Dhw=LoadInteger(fc,Lgw,ihw)
set Lb=Lb-1
if Dhw<=0 then
set Hhw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[Lgw]==0 then
if Lgw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Jhw=eb[Lgw]
set Lb=Lb-1
call SaveInteger(Hhw,Lgw,ihw,Jhw)
call Djw(Lgw,ihw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set ohw=null
set bhw=null
set ehw=null
set nhw=null
set Rhw=null
set Ghw=null
set Fhw=null
set xhw=null
set Qhw=null
set Zhw=null
set Phw=null
set Hhw=null
endfunction
function cFw takes integer Lhw,integer Xhw,integer Chw,integer Vhw,integer Bhw,integer Nhw,integer Mhw,integer wFw,integer uFw,integer rFw,integer sFw,integer tFw,integer iFw,string SFw returns nothing
set Xb[Lb]=SFw
set Lb=Lb+1
if ZO[Lhw]==0 then
if Lhw==0 then
call x1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call x1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if ZO[Lhw]<=692 then
call Kgw(Lhw,Xhw,Chw,Vhw,Bhw,Nhw,Mhw,wFw,uFw,rFw,sFw,tFw,iFw,"when calling add in HashList, line 25")
else
call Khw(Lhw,Xhw,Chw,Vhw,Bhw,Nhw,Mhw,wFw,uFw,rFw,sFw,tFw,iFw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function WGw takes integer GGw,integer gGw,integer hGw,integer FGw,integer kGw,integer jGw,integer xGw,integer vGw,integer mGw,string QGw returns nothing
set Xb[Lb]=QGw
set Lb=Lb+1
call SaveInteger(dc,GGw,eb[GGw],gGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[GGw]==0 then
if GGw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(GGw,gGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[GGw]=eb[GGw]+1
call SaveInteger(dc,GGw,eb[GGw],hGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[GGw]==0 then
if GGw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(GGw,hGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[GGw]=eb[GGw]+1
call SaveInteger(dc,GGw,eb[GGw],FGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[GGw]==0 then
if GGw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(GGw,FGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[GGw]=eb[GGw]+1
call SaveInteger(dc,GGw,eb[GGw],kGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[GGw]==0 then
if GGw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(GGw,kGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[GGw]=eb[GGw]+1
call SaveInteger(dc,GGw,eb[GGw],jGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[GGw]==0 then
if GGw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(GGw,jGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[GGw]=eb[GGw]+1
call SaveInteger(dc,GGw,eb[GGw],xGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[GGw]==0 then
if GGw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(GGw,xGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[GGw]=eb[GGw]+1
call SaveInteger(dc,GGw,eb[GGw],vGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[GGw]==0 then
if GGw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(GGw,vGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[GGw]=eb[GGw]+1
call SaveInteger(dc,GGw,eb[GGw],mGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[GGw]==0 then
if GGw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(GGw,mGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[GGw]=eb[GGw]+1
set Lb=Lb-1
endfunction
function ngw takes integer EGw,integer ZGw,integer UGw,integer IGw,integer PGw,integer AGw,integer DGw,integer HGw,integer JGw,string KGw returns nothing
local integer LGw
local hashtable XGw
local integer CGw
local integer VGw
local hashtable BGw
local integer NGw
local integer MGw
local hashtable wgw
local integer ugw
local integer rgw
local hashtable sgw
local integer tgw
local integer igw
local hashtable Sgw
local integer cgw
local integer ogw
local hashtable Ogw
local integer lgw
local integer bgw
local hashtable ygw
local integer pgw
local integer egw
local hashtable qgw
local integer agw
set Xb[Lb]=KGw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set LGw=LoadInteger(fc,EGw,ZGw)
set Lb=Lb-1
if LGw<=0 then
set XGw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set CGw=eb[EGw]
set Lb=Lb-1
call SaveInteger(XGw,EGw,ZGw,CGw)
call Djw(EGw,ZGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set VGw=LoadInteger(fc,EGw,UGw)
set Lb=Lb-1
if VGw<=0 then
set BGw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set NGw=eb[EGw]
set Lb=Lb-1
call SaveInteger(BGw,EGw,UGw,NGw)
call Djw(EGw,UGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set MGw=LoadInteger(fc,EGw,IGw)
set Lb=Lb-1
if MGw<=0 then
set wgw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ugw=eb[EGw]
set Lb=Lb-1
call SaveInteger(wgw,EGw,IGw,ugw)
call Djw(EGw,IGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set rgw=LoadInteger(fc,EGw,PGw)
set Lb=Lb-1
if rgw<=0 then
set sgw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set tgw=eb[EGw]
set Lb=Lb-1
call SaveInteger(sgw,EGw,PGw,tgw)
call Djw(EGw,PGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set igw=LoadInteger(fc,EGw,AGw)
set Lb=Lb-1
if igw<=0 then
set Sgw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set cgw=eb[EGw]
set Lb=Lb-1
call SaveInteger(Sgw,EGw,AGw,cgw)
call Djw(EGw,AGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ogw=LoadInteger(fc,EGw,DGw)
set Lb=Lb-1
if ogw<=0 then
set Ogw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set lgw=eb[EGw]
set Lb=Lb-1
call SaveInteger(Ogw,EGw,DGw,lgw)
call Djw(EGw,DGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set bgw=LoadInteger(fc,EGw,HGw)
set Lb=Lb-1
if bgw<=0 then
set ygw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set pgw=eb[EGw]
set Lb=Lb-1
call SaveInteger(ygw,EGw,HGw,pgw)
call Djw(EGw,HGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set egw=LoadInteger(fc,EGw,JGw)
set Lb=Lb-1
if egw<=0 then
set qgw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[EGw]==0 then
if EGw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set agw=eb[EGw]
set Lb=Lb-1
call SaveInteger(qgw,EGw,JGw,agw)
call Djw(EGw,JGw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set XGw=null
set BGw=null
set wgw=null
set sgw=null
set Sgw=null
set Ogw=null
set ygw=null
set qgw=null
endfunction
function jgw takes integer dgw,integer fgw,integer Rgw,integer Tgw,integer Ygw,integer Ggw,integer ggw,integer hgw,integer Fgw,string kgw returns nothing
set Xb[Lb]=kgw
set Lb=Lb+1
if ZO[dgw]==0 then
if dgw==0 then
call x1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call x1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if ZO[dgw]<=692 then
call WGw(dgw,fgw,Rgw,Tgw,Ygw,Ggw,ggw,hgw,Fgw,"when calling add in HashList, line 25")
else
call ngw(dgw,fgw,Rgw,Tgw,Ygw,Ggw,ggw,hgw,Fgw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function Ikw takes integer FFw,integer kFw,integer jFw,integer xFw,integer vFw,integer mFw,integer QFw,integer WFw,integer EFw,integer ZFw,integer UFw,integer IFw,integer PFw,integer AFw,integer DFw,integer HFw,string JFw returns nothing
local integer KFw
local hashtable LFw
local integer XFw
local integer CFw
local hashtable VFw
local integer BFw
local integer NFw
local hashtable MFw
local integer wkw
local integer ukw
local hashtable rkw
local integer skw
local integer tkw
local hashtable ikw
local integer Skw
local integer ckw
local hashtable okw
local integer Okw
local integer lkw
local hashtable bkw
local integer ykw
local integer pkw
local hashtable ekw
local integer qkw
local integer akw
local hashtable nkw
local integer dkw
local integer fkw
local hashtable Rkw
local integer Tkw
local integer Ykw
local hashtable Gkw
local integer gkw
local integer hkw
local hashtable Fkw
local integer kkw
local integer jkw
local hashtable xkw
local integer vkw
local integer mkw
local hashtable Qkw
local integer Wkw
local integer Ekw
local hashtable Zkw
local integer Ukw
set Xb[Lb]=JFw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set KFw=LoadInteger(fc,FFw,kFw)
set Lb=Lb-1
if KFw<=0 then
set LFw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set XFw=eb[FFw]
set Lb=Lb-1
call SaveInteger(LFw,FFw,kFw,XFw)
call Djw(FFw,kFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set CFw=LoadInteger(fc,FFw,jFw)
set Lb=Lb-1
if CFw<=0 then
set VFw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set BFw=eb[FFw]
set Lb=Lb-1
call SaveInteger(VFw,FFw,jFw,BFw)
call Djw(FFw,jFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set NFw=LoadInteger(fc,FFw,xFw)
set Lb=Lb-1
if NFw<=0 then
set MFw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set wkw=eb[FFw]
set Lb=Lb-1
call SaveInteger(MFw,FFw,xFw,wkw)
call Djw(FFw,xFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ukw=LoadInteger(fc,FFw,vFw)
set Lb=Lb-1
if ukw<=0 then
set rkw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set skw=eb[FFw]
set Lb=Lb-1
call SaveInteger(rkw,FFw,vFw,skw)
call Djw(FFw,vFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set tkw=LoadInteger(fc,FFw,mFw)
set Lb=Lb-1
if tkw<=0 then
set ikw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Skw=eb[FFw]
set Lb=Lb-1
call SaveInteger(ikw,FFw,mFw,Skw)
call Djw(FFw,mFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ckw=LoadInteger(fc,FFw,QFw)
set Lb=Lb-1
if ckw<=0 then
set okw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Okw=eb[FFw]
set Lb=Lb-1
call SaveInteger(okw,FFw,QFw,Okw)
call Djw(FFw,QFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set lkw=LoadInteger(fc,FFw,WFw)
set Lb=Lb-1
if lkw<=0 then
set bkw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ykw=eb[FFw]
set Lb=Lb-1
call SaveInteger(bkw,FFw,WFw,ykw)
call Djw(FFw,WFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set pkw=LoadInteger(fc,FFw,EFw)
set Lb=Lb-1
if pkw<=0 then
set ekw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set qkw=eb[FFw]
set Lb=Lb-1
call SaveInteger(ekw,FFw,EFw,qkw)
call Djw(FFw,EFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set akw=LoadInteger(fc,FFw,ZFw)
set Lb=Lb-1
if akw<=0 then
set nkw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set dkw=eb[FFw]
set Lb=Lb-1
call SaveInteger(nkw,FFw,ZFw,dkw)
call Djw(FFw,ZFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set fkw=LoadInteger(fc,FFw,UFw)
set Lb=Lb-1
if fkw<=0 then
set Rkw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Tkw=eb[FFw]
set Lb=Lb-1
call SaveInteger(Rkw,FFw,UFw,Tkw)
call Djw(FFw,UFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Ykw=LoadInteger(fc,FFw,IFw)
set Lb=Lb-1
if Ykw<=0 then
set Gkw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set gkw=eb[FFw]
set Lb=Lb-1
call SaveInteger(Gkw,FFw,IFw,gkw)
call Djw(FFw,IFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set hkw=LoadInteger(fc,FFw,PFw)
set Lb=Lb-1
if hkw<=0 then
set Fkw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set kkw=eb[FFw]
set Lb=Lb-1
call SaveInteger(Fkw,FFw,PFw,kkw)
call Djw(FFw,PFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set jkw=LoadInteger(fc,FFw,AFw)
set Lb=Lb-1
if jkw<=0 then
set xkw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set vkw=eb[FFw]
set Lb=Lb-1
call SaveInteger(xkw,FFw,AFw,vkw)
call Djw(FFw,AFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set mkw=LoadInteger(fc,FFw,DFw)
set Lb=Lb-1
if mkw<=0 then
set Qkw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Wkw=eb[FFw]
set Lb=Lb-1
call SaveInteger(Qkw,FFw,DFw,Wkw)
call Djw(FFw,DFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call x1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Ekw=LoadInteger(fc,FFw,HFw)
set Lb=Lb-1
if Ekw<=0 then
set Zkw=Rc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if ZO[FFw]==0 then
if FFw==0 then
call x1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call x1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Ukw=eb[FFw]
set Lb=Lb-1
call SaveInteger(Zkw,FFw,HFw,Ukw)
call Djw(FFw,HFw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set LFw=null
set VFw=null
set MFw=null
set rkw=null
set ikw=null
set okw=null
set bkw=null
set ekw=null
set nkw=null
set Rkw=null
set Gkw=null
set Fkw=null
set xkw=null
set Qkw=null
set Zkw=null
endfunction
function hFw takes integer oFw,integer OFw,integer lFw,integer bFw,integer yFw,integer pFw,integer eFw,integer qFw,integer aFw,integer nFw,integer dFw,integer fFw,integer RFw,integer TFw,integer YFw,integer GFw,string gFw returns nothing
set Xb[Lb]=gFw
set Lb=Lb+1
call SaveInteger(dc,oFw,eb[oFw],OFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,OFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],lFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,lFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],bFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,bFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],yFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,yFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],pFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,pFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],eFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,eFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],qFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,qFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],aFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,aFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],nFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,nFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],dFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,dFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],fFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,fFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],RFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,RFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],TFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,TFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],YFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,YFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
call SaveInteger(dc,oFw,eb[oFw],GFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if ZO[oFw]==0 then
if oFw==0 then
call x1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call x1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call GOw(oFw,GFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[oFw]=eb[oFw]+1
set Lb=Lb-1
endfunction
function tjw takes integer Pkw,integer Akw,integer Dkw,integer Hkw,integer Jkw,integer Kkw,integer Lkw,integer Xkw,integer Ckw,integer Vkw,integer Bkw,integer Nkw,integer Mkw,integer wjw,integer ujw,integer rjw,string sjw returns nothing
set Xb[Lb]=sjw
set Lb=Lb+1
if ZO[Pkw]==0 then
if Pkw==0 then
call x1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call x1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if ZO[Pkw]<=692 then
call hFw(Pkw,Akw,Dkw,Hkw,Jkw,Kkw,Lkw,Xkw,Ckw,Vkw,Bkw,Nkw,Mkw,wjw,ujw,rjw,"when calling add in HashList, line 25")
else
call Ikw(Pkw,Akw,Dkw,Hkw,Jkw,Kkw,Lkw,Xkw,Ckw,Vkw,Bkw,Nkw,Mkw,wjw,ujw,rjw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function xjw takes integer ijw,integer Sjw,integer cjw,integer ojw,integer Ojw,integer ljw,integer bjw,integer yjw,integer pjw,integer ejw,integer qjw,integer ajw,integer njw,integer djw,integer fjw,integer Rjw,integer Tjw,integer Yjw,integer Gjw,integer gjw,integer hjw,integer Fjw,string kjw returns integer
local integer jjw
set Xb[Lb]=kjw
set Lb=Lb+1
set jjw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(jjw,ijw,"when calling add in LinkedList, line 393")
call jfw(jjw,Sjw,"when calling add in LinkedList, line 393")
call jfw(jjw,cjw,"when calling add in LinkedList, line 393")
call jfw(jjw,ojw,"when calling add in LinkedList, line 393")
call jfw(jjw,Ojw,"when calling add in LinkedList, line 393")
call jfw(jjw,ljw,"when calling add in LinkedList, line 393")
call jfw(jjw,bjw,"when calling add in LinkedList, line 393")
call jfw(jjw,yjw,"when calling add in LinkedList, line 393")
call jfw(jjw,pjw,"when calling add in LinkedList, line 393")
call jfw(jjw,ejw,"when calling add in LinkedList, line 393")
call jfw(jjw,qjw,"when calling add in LinkedList, line 393")
call jfw(jjw,ajw,"when calling add in LinkedList, line 393")
call jfw(jjw,njw,"when calling add in LinkedList, line 393")
call jfw(jjw,djw,"when calling add in LinkedList, line 393")
call jfw(jjw,fjw,"when calling add in LinkedList, line 393")
call jfw(jjw,Rjw,"when calling add in LinkedList, line 393")
call jfw(jjw,Tjw,"when calling add in LinkedList, line 393")
call jfw(jjw,Yjw,"when calling add in LinkedList, line 393")
call jfw(jjw,Gjw,"when calling add in LinkedList, line 393")
call jfw(jjw,gjw,"when calling add in LinkedList, line 393")
call jfw(jjw,hjw,"when calling add in LinkedList, line 393")
call jfw(jjw,Fjw,"when calling add in LinkedList, line 393")
set Lb=Lb-1
return jjw
endfunction
function Juw takes string buw returns boolean
local integer yuw
local integer puw
local integer euw
local integer quw
local integer auw
local integer nuw
local integer duw
local integer fuw
local integer Ruw
local integer Tuw
local integer Yuw
local integer Guw
local integer guw
local integer huw
local integer Fuw
local integer kuw
local integer juw
local integer xuw
local integer vuw
local integer muw
local integer Quw
local integer Wuw
local integer Euw
local integer Zuw
local integer Uuw
local integer Iuw
local integer Puw
local integer Auw
local integer Duw
local integer Huw
set Xb[Lb]=buw
set Lb=Lb+1
set Xb[Lb]="when calling asList in Units, line 112"
set Lb=Lb+1
set nuw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(nuw,1747989317,"when calling add in LinkedList, line 393")
call jfw(nuw,1747989305,"when calling add in LinkedList, line 393")
call jfw(nuw,1747989316,"when calling add in LinkedList, line 393")
call jfw(nuw,1747989315,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ko=nuw
set Lo=wlw("when calling new_HashMap in Units, line 113")
set Xo[0]=YGw(1747988528,1747988528,1747988528,1747988528,1747988528,1747988528,1747988532,1747988532,1747988532,1747988532,1211118401,1747989058,1747989058,1747989058,1747989058,1747989058,1747989058,1747988790,"when calling asList in Units, line 120")
set Xo[1]=YGw(1747990339,1747990339,1747990339,1747990339,1747990339,1747990339,1747990340,1747990340,1747990340,1747990340,1211119699,1747990593,1747990593,1747990593,1747990593,1747990593,1747990593,1747988790,"when calling asList in Units, line 126")
set Xo[2]=YGw(1747990087,1747990087,1747990087,1747990087,1747990087,1747990087,1747990088,1747990088,1747990088,1747990088,1211119701,1747989817,1747989817,1747989817,1747989817,1747989817,1747989817,1747988790,"when calling asList in Units, line 133")
set Xo[3]=YGw(1747989558,1747989558,1747989558,1747989558,1747989558,1747989558,1747989575,1747989575,1747989575,1747989575,1211119700,1747989571,1747989571,1747989571,1747989571,1747989571,1747989571,1747988790,"when calling asList in Units, line 140")
set yuw=AOw("when calling new_HashList in Units, line 149")
call jgw(yuw,1747989558,1747990339,1747990087,1747988528,1747989575,1747990340,1747990088,1747988532,"when calling add in Units, line 150")
set Co=yuw
set puw=AOw("when calling new_HashList in Units, line 162")
call cFw(puw,1747988529,1747988530,1747988531,1747990326,1747990327,1747990328,1747990084,1747990085,1747990086,1747989590,1747989591,1747989592,"when calling add in Units, line 163")
set Vo=puw
set euw=AOw("when calling new_HashList in Units, line 178")
call cFw(euw,1747989059,1747989060,1747988844,1747990351,1747990352,1747990356,1747989331,1747990350,1747989809,1747990353,1747990354,1747990355,"when calling add in Units, line 179")
set Bo=euw
set quw=AOw("when calling new_HashList in Units, line 194")
call tjw(quw,1747988529,1747988530,1747988531,1747990326,1747990327,1747990328,1747990084,1747990085,1747990086,1747989590,1747989591,1747989592,1747989555,1747989297,1747989325,"when calling add in Units, line 195")
set No=quw
set Xb[Lb]="when calling asList in Units, line 204"
set Lb=Lb+1
set duw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(duw,1747989321,"when calling add in LinkedList, line 393")
call jfw(duw,1747989321,"when calling add in LinkedList, line 393")
call jfw(duw,1747989321,"when calling add in LinkedList, line 393")
call jfw(duw,1747989321,"when calling add in LinkedList, line 393")
call jfw(duw,1747989321,"when calling add in LinkedList, line 393")
call jfw(duw,1747989321,"when calling add in LinkedList, line 393")
call jfw(duw,1747988790,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Mo[0]=duw
set Xb[Lb]="when calling asList in Units, line 205"
set Lb=Lb+1
set fuw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(fuw,1747989321,"when calling add in LinkedList, line 393")
call jfw(fuw,1747989321,"when calling add in LinkedList, line 393")
call jfw(fuw,1747989321,"when calling add in LinkedList, line 393")
call jfw(fuw,1747989326,"when calling add in LinkedList, line 393")
call jfw(fuw,1747989326,"when calling add in LinkedList, line 393")
call jfw(fuw,1747989321,"when calling add in LinkedList, line 393")
call jfw(fuw,1747989321,"when calling add in LinkedList, line 393")
call jfw(fuw,1747989321,"when calling add in LinkedList, line 393")
call jfw(fuw,1747988790,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Mo[1]=fuw
set Xb[Lb]="when calling asList in Units, line 206"
set Lb=Lb+1
set Ruw=Ybw("when calling new_LinkedList in LinkedList, line 391")
call jfw(Ruw,1747989321,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747989321,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747989321,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747989321,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747989326,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747989326,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747989326,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747989326,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747989337,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747989337,"when calling add in LinkedList, line 393")
call jfw(Ruw,1747988790,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Mo[2]=Ruw
set Tuw=GetHandleId(gu)
set Yuw=GetHandleId(kw)
set Guw=GetHandleId(ew)
set guw=GetHandleId(qw)
set huw=GetHandleId(Ow)
set Fuw=GetHandleId(hu)
set kuw=GetHandleId(Yu)
set juw=GetHandleId(Vw)
set xuw=GetHandleId(q)
set vuw=GetHandleId(Gu)
set muw=GetHandleId(a)
set Quw=GetHandleId(fw)
set Wuw=GetHandleId(dw)
set Euw=GetHandleId(Rw)
set Zuw=GetHandleId(ow)
set Uuw=GetHandleId(lw)
set Iuw=GetHandleId(bw)
set Puw=GetHandleId(yw)
set Auw=GetHandleId(pw)
set Duw=GetHandleId(aw)
set Huw=GetHandleId(d)
set wO=xjw(Tuw,Yuw,Guw,guw,huw,Fuw,kuw,juw,xuw,vuw,muw,Quw,Wuw,Euw,Zuw,Uuw,Iuw,Puw,Auw,Duw,Huw,GetHandleId(n),"when calling asList in Units, line 209")
set auw=Lo
call idw(auw,1747989317,15,"when calling put in Units, line 236")
call idw(auw,1747989305,50,"when calling put in Units, line 237")
call idw(auw,1747989316,25,"when calling put in Units, line 238")
call idw(auw,1747989315,40,"when calling put in Units, line 239")
set Lb=Lb-1
return true
endfunction
function rxw takes nothing returns boolean
set Lb=0
return Juw("Units, line 1")
endfunction
function rD takes nothing returns boolean
if GetResearched()!=1378890052 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890052,true)!=2 then
return false
endif
return true
endfunction
function sD takes nothing returns boolean
if not rD() then
return false
endif
return true
endfunction
function sE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989812,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989811,0)
endfunction
function rK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990356 then
return false
endif
return true
endfunction
function sK takes nothing returns boolean
if not rK() then
return false
endif
return true
endfunction
function rQ takes nothing returns boolean
if GetResearched()!=1378889802 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889802,true)!=1 then
return false
endif
return true
endfunction
function sQ takes nothing returns boolean
if not rQ() then
return false
endif
return true
endfunction
function lrw takes string srw returns nothing
local unit trw
local integer irw
local player Srw
local integer crw
local integer orw
local boolean Orw
set Xb[Lb]=srw
set Lb=Lb+1
set trw=GetEnteringUnit()
set irw=GetPlayerId(GetOwningPlayer(trw))
set Srw=uo[irw]
if GetPlayerSlotState(Srw)==PLAYER_SLOT_STATE_PLAYING then
set Orw=GetPlayerController(Srw)==MAP_CONTROL_USER
else
set Orw=false
endif
if Orw and(not IsUnitType(trw,UNIT_TYPE_STRUCTURE)) then
set crw=wo[irw]
set orw=-GetUnitLevel(trw)
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 25"
set Lb=Lb+1
if yl[crw]==0 then
if crw==0 then
call x1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call x1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[crw]=Db[crw]+orw
set Lb=Lb-1
endif
set Lb=Lb-1
set trw=null
set Srw=null
endfunction
function svw takes nothing returns nothing
set Lb=0
call lrw("Upkeep, line 21")
endfunction
function V3 takes real J3,real K3,player L3,real X3 returns unit
local unit C3=CreateUnit(L3,2019849581,J3,K3,X3*57.295779513)
call SetUnitX(C3,J3)
call SetUnitY(C3,K3)
call UnitAddAbility(C3,1097691750)
call UnitRemoveAbility(C3,1097691750)
call UnitAddAbility(C3,1097625443)
set SR=C3
set C3=null
return SR
endfunction
function tow takes string row returns integer
local integer sow
set Xb[Lb]=row
set Lb=Lb+1
set Xb[Lb]="when calling alloc_ArrayQueue in DummyRecycler, line 49"
set Lb=Lb+1
if xO==0 then
if vO<32768 then
set vO=vO+1
set sow=vO
set mO[sow]=626
else
call x1("Out of memory: Could not create ArrayQueue.","when calling error in DummyRecycler, line 49")
set sow=0
endif
else
set xO=xO-1
set sow=jO[xO]
set mO[sow]=626
endif
set Lb=Lb-1
set lb[sow]=0
set bb[sow]=0
set Lb=Lb-1
return sow
endfunction
function xnw takes integer Fnw,unit knw,string jnw returns nothing
set Xb[Lb]=jnw
set Lb=Lb+1
if mO[Fnw]==0 then
if Fnw==0 then
call x1("Nullpointer exception when calling ArrayQueue.enqueue","when calling error in DummyRecycler, line 55")
else
call x1("Called ArrayQueue.enqueue on invalid object.","when calling error in DummyRecycler, line 55")
endif
endif
set Xb[Lb]="when calling enqueue in DummyRecycler, line 55"
set Lb=Lb+1
if bb[Fnw]<6 then
set bb[Fnw]=bb[Fnw]+1
set lb[Fnw]=ModuloInteger(lb[Fnw]+1,6)
else
call x1("Queue Overflow","when calling error in DummyRecycler, line 61")
endif
set Lb=Lb-1-1
endfunction
function H3 takes string U3 returns boolean
local integer I3
local integer P3
local integer A3
local integer D3
set Xb[Lb]=U3
set Lb=Lb+1
set wc=360*1./8
call CreateTimer()
set I3=0
set P3=7
loop
exitwhen I3>P3
set uc[I3]=tow("when calling new_ArrayQueue in DummyRecycler, line 140")
set A3=0
set D3=5
loop
exitwhen A3>D3
call xnw(uc[I3],V3(mc,Qc,iS,I3*wc*0.017453293),"when calling enqueue in DummyRecycler, line 142")
set A3=A3+1
endloop
set I3=I3+1
endloop
set Lb=Lb-1
return true
endfunction
function sxw takes nothing returns boolean
set Lb=0
return H3("DummyRecycler, line 1")
endfunction
function tD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990601,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990599,0)
endfunction
function tK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function tQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651824,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651825,0)
endfunction
function sY takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989045 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function tY takes nothing returns boolean
if not sY() then
return false
endif
return true
endfunction
function tvw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 291"
set Lb=Lb+1
call sB("when calling generalEventCallback in ClosureEvents, line 291")
set Lb=Lb-1
endfunction
function initialize takes nothing returns nothing
local integer i_2=0
local integer temp=ao
loop
exitwhen i_2>temp
set i_2=i_2+1
endloop
endfunction
function txw takes nothing returns boolean
set Lb=0
set Xb[Lb]="StringUtils, line 1"
set Lb=Lb+1
set ao=127
call initialize()
call Tww("","when calling stringToIndex in StringUtils, line 167")
set Lb=Lb-1
return true
endfunction
function wL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988530 then
return false
endif
return true
endfunction
function uL takes nothing returns boolean
if not wL() then
return false
endif
return true
endfunction
function uP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990324,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990325,0)
endfunction
function wU takes nothing returns boolean
if GetResearched()!=1378889818 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889818,true)!=1 then
return false
endif
return true
endfunction
function uU takes nothing returns boolean
if not wU() then
return false
endif
return true
endfunction
function wW takes nothing returns boolean
if GetResearched()!=1378889801 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889801,true)!=2 then
return false
endif
return true
endfunction
function uW takes nothing returns boolean
if not wW() then
return false
endif
return true
endfunction
function uZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651841,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651831,0)
endfunction
function uv takes nothing returns nothing
local player Hx=GetOwningPlayer(GetSpellTargetUnit())
local playerstate Jx=PLAYER_STATE_RESOURCE_GOLD
local playerstate Kx
local playerstate Lx
local player Xx
local force Cx
local location Vx
local real Bx
local real Nx
local player Mx
local force wv
if Jx==PLAYER_STATE_RESOURCE_GOLD then
set Kx=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Hx,Kx,GetPlayerState(Hx,Kx)+500)
elseif Jx==PLAYER_STATE_RESOURCE_LUMBER then
set Lx=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Hx,Lx,GetPlayerState(Hx,Lx)+500)
endif
call SetPlayerState(Hx,Jx,GetPlayerState(Hx,Jx)+500)
call RemoveUnit(GetSpellAbilityUnit())
set Xx=GetOwningPlayer(GetSpellTargetUnit())
set Cx=CreateForce()
call ForceAddPlayer(Cx,Xx)
if IsPlayerInForce(GetLocalPlayer(),Cx) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1234")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set Mx=GetOwningPlayer(GetSpellTargetUnit())
set wv=CreateForce()
call ForceAddPlayer(wv,Mx)
set Vx=y
set Bx=GetLocationX(Vx)
set Nx=GetLocationY(Vx)
if IsPlayerInForce(GetLocalPlayer(),wv) then
call PingMinimap(Bx,Nx,2.00)
endif
call RemoveLocation(y)
set Hx=null
set Jx=null
set Kx=null
set Lx=null
set Xx=null
set Cx=null
set Vx=null
set Mx=null
set wv=null
endfunction
function uuw takes string Mww returns nothing
local unit wuw
set Xb[Lb]=Mww
set Lb=Lb+1
set wuw=Nc[Mc-1]
set Xb[Lb]="when calling toUnitIndex in UnitIndexer, line 196"
set Lb=Lb+1
if GetUnitUserData(wuw)==0 then
call Uqw(wuw,"when calling new_UnitIndex in UnitIndexer, line 135")
endif
set Lb=Lb-1-1
set wuw=null
endfunction
function uvw takes nothing returns nothing
set Lb=0
call uuw("UnitIndexer, line 196")
endfunction
function uxw takes nothing returns boolean
set Lb=0
set Xb[Lb]="TimerUtils, line 1"
set Lb=Lb+1
set Io=Yqw("when calling new_Table in TimerUtils, line 12")
call CreateTimer()
call CreateTrigger()
set Lb=Lb-1
return true
endfunction
function v1 takes nothing returns boolean
set cc=CreateForce()
set oc=CreateForce()
set Oc=CreateForce()
set lc=CreateForce()
set bc[0]=cc
set bc[1]=oc
set bc[2]=Oc
set bc[3]=lc
set yc[0]=62
set pc[0]=194
set ec[0]=255
set yc[1]=255
set pc[1]=238
set ec[1]=0
set yc[2]=0
set pc[2]=201
set ec[2]=10
set yc[3]=219
set pc[3]=0
set ec[3]=201
return true
endfunction
function xE takes nothing returns boolean
if GetResearched()!=1378889807 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889807,true)!=2 then
return false
endif
return true
endfunction
function vE takes nothing returns boolean
if not xE() then
return false
endif
return true
endfunction
function jF takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function xF takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988792 then
return false
endif
if not jF() then
return false
endif
return true
endfunction
function vF takes nothing returns boolean
if not xF() then
return false
endif
return true
endfunction
function vL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function vU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989815,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989838,0)
endfunction
function vW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651843,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651842,0)
endfunction
function vX takes nothing returns boolean
return true
endfunction
function u4 takes string X1 returns boolean
local playerunitevent C1
local playerunitevent V1
local integer B1
local integer N1
local integer M1
local integer w4
set Xb[Lb]=X1
set Lb=Lb+1
set C1=EVENT_PLAYER_UNIT_DEATH
set Xb[Lb]="when calling alloc_LimitEncampments_EventListener_line8 in LimitEncampments, line 8"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set B1=iO
set SO[B1]=669
else
call x1("Out of memory: Could not create LimitEncampments_EventListener_line8.","when calling error in LimitEncampments, line 8")
set B1=0
endif
else
set tO=tO-1
set B1=sO[tO]
set SO[B1]=669
endif
set Lb=Lb-1
set ub[B1]=0
set rb[B1]=0
set sb[B1]=0
set Xb[Lb]="when calling add in LimitEncampments, line 8"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set N1=mS[GetHandleId(C1)]
if N1==0 then
set N1=QV(C1,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[B1]=N1
if ZS[ub[B1]]!=0 then
set sb[ZS[ub[B1]]]=B1
set rb[B1]=ZS[ub[B1]]
endif
set ZS[ub[B1]]=B1
set Lb=Lb-1
set V1=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Xb[Lb]="when calling alloc_LimitEncampments_EventListener_line12 in LimitEncampments, line 12"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set M1=iO
set SO[M1]=668
else
call x1("Out of memory: Could not create LimitEncampments_EventListener_line12.","when calling error in LimitEncampments, line 12")
set M1=0
endif
else
set tO=tO-1
set M1=sO[tO]
set SO[M1]=668
endif
set Lb=Lb-1
set ub[M1]=0
set rb[M1]=0
set sb[M1]=0
set Xb[Lb]="when calling add in LimitEncampments, line 12"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set w4=mS[GetHandleId(V1)]
if w4==0 then
set w4=QV(V1,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[M1]=w4
if ZS[ub[M1]]!=0 then
set sb[ZS[ub[M1]]]=M1
set rb[M1]=ZS[ub[M1]]
endif
set ZS[ub[M1]]=M1
set Lb=Lb-1-1
set C1=null
set V1=null
return true
endfunction
function vxw takes nothing returns boolean
set Lb=0
return u4("LimitEncampments, line 1")
endfunction
function wI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989826,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989828,0)
endfunction
function MI takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function wP takes nothing returns boolean
if not MI() then
return false
endif
return true
endfunction
function wX takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function ME takes nothing returns boolean
if GetResearched()!=1378889809 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889809,true)!=1 then
return false
endif
return true
endfunction
function wZ takes nothing returns boolean
if not ME() then
return false
endif
return true
endfunction
function Zww_2 takes integer xww_2,string vww returns trigger
local integer mww
local fogstate Qww
local integer Www_2
local trigger Eww_2
set Xb[Lb]=vww
set Lb=Lb+1
set mww=Po
set Qww=ConvertFogState(xww_2)
set Xb[Lb]="when calling saveFogState in TypeCasting, line 94"
set Lb=Lb+1
if AO[mww]==0 then
if mww==0 then
call x1("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call x1("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call SaveFogStateHandle(Eo,mww,0,Qww)
set Lb=Lb-1
set Www_2=Po
set Xb[Lb]="when calling loadTrigger in TypeCasting, line 95"
set Lb=Lb+1
if AO[Www_2]==0 then
if Www_2==0 then
call x1("Nullpointer exception when calling Table.loadTrigger","when calling error in Table, line 111")
else
call x1("Called Table.loadTrigger on invalid object.","when calling error in Table, line 111")
endif
endif
set Eww_2=LoadTriggerHandle(Eo,Www_2,0)
set Lb=Lb-1-1
set lR=Eww_2
set Qww=null
set Eww_2=null
return lR
endfunction
function P0w takes string U0w returns boolean
local boolean I0w
set Xb[Lb]=U0w
set Lb=Lb+1
set I0w=TriggerEvaluate(Zww_2(ldw(eo,GetSpellAbilityId(),"when calling get in RegisterEvents, line 58"),"when calling triggerFromIndex in RegisterEvents, line 58"))
set Lb=Lb-1
return I0w
endfunction
function wvw takes nothing returns boolean
set Lb=0
return P0w("RegisterEvents, line 58")
endfunction
function wxw takes nothing returns boolean
set Lb=0
set Xb[Lb]="RegisterEvents, line 1"
set Lb=Lb+1
set eo=wlw("when calling new_HashMap in RegisterEvents, line 55")
call Z0w(EVENT_PLAYER_UNIT_SPELL_EFFECT,null,iR,null)
set Lb=Lb-1
return true
endfunction
function x9 takes nothing returns nothing
call h9(GetEnumUnit())
endfunction
function xG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989047 then
return false
endif
return true
endfunction
function xH takes nothing returns nothing
local integer YH=1
local integer GH=1752461175
local player gH=GetOwningPlayer(GetTriggerUnit())
local rect jH=bj_mapInitialPlayableArea
local location kH=Location(GetRectCenterX(jH),GetRectCenterY(jH))
local location hH=Location(GetLocationX(kH)+100000000.00,GetLocationY(kH)+100000000.00)
local real FH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set YH=YH-1
exitwhen YH<0
call CreateUnitAtLocSaveLast(gH,GH,hH,FH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set gH=null
set hH=null
set kH=null
set jH=null
endfunction
function jL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989592 then
return false
endif
return true
endfunction
function xL takes nothing returns boolean
if not jL() then
return false
endif
return true
endfunction
function xP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990584,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990593,0)
endfunction
function jU takes nothing returns boolean
if GetResearched()!=1378890034 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890034,true)!=1 then
return false
endif
return true
endfunction
function xU takes nothing returns boolean
if not jU() then
return false
endif
return true
endfunction
function jW takes nothing returns boolean
if GetResearched()!=1378889812 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889812,true)!=1 then
return false
endif
return true
endfunction
function xW takes nothing returns boolean
if not jW() then
return false
endif
return true
endfunction
function xX takes nothing returns boolean
set iS=uo[PLAYER_NEUTRAL_PASSIVE]
return true
endfunction
function xZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989574,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989573,0)
endfunction
function xg takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990089 then
return false
endif
return true
endfunction
function xh takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989078 then
return false
endif
return true
endfunction
function xk takes nothing returns nothing
local player dk=GetOwningPlayer(GetSpellTargetUnit())
local playerstate fk=PLAYER_STATE_RESOURCE_GOLD
local playerstate Rk
local playerstate Tk
local player Yk
local force Gk
local location gk
local real hk
local real Fk
local player kk
local force jk
if fk==PLAYER_STATE_RESOURCE_GOLD then
set Rk=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(dk,Rk,GetPlayerState(dk,Rk)+250)
elseif fk==PLAYER_STATE_RESOURCE_LUMBER then
set Tk=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(dk,Tk,GetPlayerState(dk,Tk)+250)
endif
call SetPlayerState(dk,fk,GetPlayerState(dk,fk)+250)
call RemoveUnit(GetSpellAbilityUnit())
set Yk=GetOwningPlayer(GetSpellTargetUnit())
set Gk=CreateForce()
call ForceAddPlayer(Gk,Yk)
if IsPlayerInForce(GetLocalPlayer(),Gk) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1230")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set kk=GetOwningPlayer(GetSpellTargetUnit())
set jk=CreateForce()
call ForceAddPlayer(jk,kk)
set gk=y
set hk=GetLocationX(gk)
set Fk=GetLocationY(gk)
if IsPlayerInForce(GetLocalPlayer(),jk) then
call PingMinimap(hk,Fk,2.00)
endif
call RemoveLocation(y)
set dk=null
set fk=null
set Rk=null
set Tk=null
set Yk=null
set Gk=null
set gk=null
set kk=null
set jk=null
endfunction
function I1 takes string W1 returns boolean
local playerunitevent E1
local integer Z1
local integer U1
set Xb[Lb]=W1
set Lb=Lb+1
set E1=EVENT_PLAYER_UNIT_ATTACKED
set Xb[Lb]="when calling alloc_Garissons_EventListener_line7 in Garissons, line 7"
set Lb=Lb+1
if tO==0 then
if iO<32768 then
set iO=iO+1
set Z1=iO
set SO[Z1]=667
else
call x1("Out of memory: Could not create Garissons_EventListener_line7.","when calling error in Garissons, line 7")
set Z1=0
endif
else
set tO=tO-1
set Z1=sO[tO]
set SO[Z1]=667
endif
set Lb=Lb-1
set ub[Z1]=0
set rb[Z1]=0
set sb[Z1]=0
set Xb[Lb]="when calling add in Garissons, line 7"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set U1=mS[GetHandleId(E1)]
if U1==0 then
set U1=QV(E1,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set ub[Z1]=U1
if ZS[ub[Z1]]!=0 then
set sb[ZS[ub[Z1]]]=Z1
set rb[Z1]=ZS[ub[Z1]]
endif
set ZS[ub[Z1]]=Z1
set Lb=Lb-1-1
set E1=null
return true
endfunction
function xxw takes nothing returns boolean
set Lb=0
return I1("Garissons, line 1")
endfunction
function y4 takes nothing returns boolean
set gc=false
set hc=false
set Fc=CreateTimer()
call TimerStart(Fc,0.01,true,Jf)
return true
endfunction
function y9 takes nothing returns boolean
return true
endfunction
function bA takes nothing returns boolean
if GetResearched()!=1378890053 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890053,true)!=2 then
return false
endif
return true
endfunction
function yA takes nothing returns boolean
if not bA() then
return false
endif
return true
endfunction
function bJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989325 then
return false
endif
return true
endfunction
function yJ takes nothing returns boolean
if not bJ() then
return false
endif
return true
endfunction
function yX takes nothing returns boolean
return true
endfunction
function yg takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989046 then
return false
endif
return true
endfunction
function yh takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990073 then
return false
endif
return true
endfunction
function bm takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function ym takes nothing returns boolean
if not bm() then
return false
endif
return true
endfunction
function yR takes nothing returns nothing
set w=null
set u=null
set s=null
set t=null
set i=null
set S=null
set c=null
set o=null
set O=null
set l=null
set b=null
set y=null
set q=null
set a=null
set n=null
set d=null
set f=null
set R=null
set T=null
set Y=null
set G=null
set g=null
set h=null
set F=null
set k=null
set j=null
set x=null
set v=null
set m=null
set Q=null
set W=null
set E=null
set Z=null
set U=null
set I=null
set P=null
set A=null
set D=null
set H=null
set J=null
set K=null
set L=null
set X=null
set C=null
set V=null
set B=null
set N=null
set M=null
set ww=null
set uw=null
set rw=null
set sw=null
set tw=null
set iw=null
set Sw=null
set cw=null
set ow=null
set Ow=null
set lw=null
set bw=null
set yw=null
set pw=null
set ew=null
set qw=null
set aw=null
set nw=null
set dw=null
set fw=null
set Rw=null
set Tw=null
set Yw=null
set Gw=null
set gw=null
set hw=null
set Fw=null
set kw=null
set jw=null
set xw=null
set vw=null
set mw=null
set Qw=null
set Ww=null
set Ew=null
set Zw=null
set Uw=null
set Iw=null
set Pw=null
set Aw=null
set Dw=null
set Hw=null
set Jw=null
set Kw=null
set Lw=null
set Xw=null
set Cw=null
set Vw=null
set Bw=null
set Nw=null
set Mw=null
set wu=null
set uu=null
set ru=null
set su=null
set tu=null
set iu=null
set Su=null
set cu=null
set ou=null
set Ou=null
set lu=null
set bu=null
set yu=null
set pu=null
set eu=null
set qu=null
set au=null
set nu=null
set du=null
set fu=null
set Ru=null
set Tu=null
set Yu=null
set Gu=null
set gu=null
set hu=null
set Fu=null
set ku=null
set ju=null
set xu=null
set vu=null
set mu=null
set Qu=null
set Wu=null
set Eu=null
set Zu=null
set Uu=null
set Iu=null
set Pu=null
set Au=null
set Du=null
set Hu=null
set Ju=null
set Ku=null
set Lu=null
set Xu=null
set Cu=null
set Vu=null
set Bu=null
set Nu=null
set Mu=null
set wr=null
set ur=null
set rr=null
set sr=null
set tr=null
set ir=null
set Sr=null
set cr=null
set lr=null
set br=null
set yr=null
set pr=null
set er=null
set qr=null
set ar=null
set nr=null
set dr=null
set fr=null
set Rr=null
set Tr=null
set Yr=null
set Gr=null
set gr=null
set hr=null
set Fr=null
set kr=null
set jr=null
set xr=null
set vr=null
set mr=null
set Qr=null
set Wr=null
set Er=null
set Zr=null
set Ur=null
set Ir=null
set Pr=null
set Ar=null
set Dr=null
set Hr=null
set Jr=null
set Kr=null
set Lr=null
set Xr=null
set Cr=null
set Vr=null
set Br=null
set Nr=null
set Mr=null
set ws=null
set us=null
set rs=null
set ss=null
set ts=null
set is=null
set Ss=null
set cs=null
set os=null
set Os=null
set ls=null
set bs=null
set ys=null
set ps=null
set es=null
set qs=null
set as=null
set ns=null
set ds=null
set fs=null
set Rs=null
set Ts=null
set Ys=null
set Gs=null
set gs=null
set hs=null
set Fs=null
set ks=null
set js=null
set xs=null
set vs=null
set ms=null
set Qs=null
set Ws=null
set Es=null
set Zs=null
set Us=null
set Is=null
set Ps=null
set As=null
set Ds=null
set Hs=null
set Js=null
set Ks=null
set Ls=null
set Xs=null
set Cs=null
set Vs=null
set Bs=null
set Ns=null
set Ms=null
set wt=null
set ut=null
set rt=null
set st=null
set tt=null
set St=null
set ct=null
set ot=null
set Ot=null
set lt=null
set bt=null
set yt=null
set pt=null
set et=null
set qt=null
set at=null
set nt=null
set dt=null
set ft=null
set Rt=null
set Tt=null
set Yt=null
set Gt=null
set gt=null
set ht=null
set Ft=null
set kt=null
set jt=null
set xt=null
set vt=null
set mt=null
set Qt=null
set Wt=null
set Et=null
set Zt=null
set Ut=null
set It=null
set Pt=null
set At=null
set Dt=null
set Ht=null
set Jt=null
set Kt=null
set Lt=null
set Xt=null
set Ct=null
set Vt=null
set Bt=null
set Nt=null
set Mt=null
set wi=null
set ui=null
set ri=null
set si=null
set ti=null
set ii=null
set Si=null
set ci=null
set oi=null
set Oi=null
set li=null
set bi=null
set yi=null
set pi=null
set ei=null
set qi=null
set ai=null
set ni=null
set di=null
set fi=null
set Ri=null
set Ti=null
set Yi=null
set Gi=null
set gi=null
set hi=null
set Fi=null
set ki=null
set ji=null
set xi=null
set vi=null
set mi=null
set Qi=null
set Wi=null
set Ei=null
set Zi=null
set Ui=null
set Ii=null
set Pi=null
set Ai=null
set Di=null
set Hi=null
set Ji=null
set Ki=null
set Li=null
set Xi=null
set Ci=null
set Vi=null
set Bi=null
set Ni=null
set Mi=null
set wS=null
set uS=null
set rS=null
set Yy=function WT
set Gy=function IT
set gy=function DT
set hy=function KT
set Fy=function NT
set ky=function tY
set jy=function lY
set xy=function aY
set vy=function YY
set my=function jY
set Qy=function EY
set Wy=function DY
set Ey=function KY
set Zy=function BY
set Uy=function NY
set Iy=function bG
set Py=function gG
set Ay=function mG
set Dy=function xG
set Hy=function HG
set Jy=function BG
set Ky=function CG
set Ly=function cg
set Xy=function eg
set Cy=function yg
set Vy=function gg
set By=function mg
set Ny=function xg
set My=function Hg
set wp=function Bg
set up=function Cg
set rp=function ch
set sp=function eh
set tp=function yh
set ip=function gh
set Sp=function mh
set cp=function xh
set op=function Hh
set Op=function Bh
set lp=function Ch
set bp=function cF
set yp=function eF
set pp=function dF
set ep=function YF
set qp=function FF
set ap=function vF
set np=function JF
set dp=function NF
set fp=function lk
set Rp=function nk
set Tp=function xk
set Yp=function Uk
set Gp=function Bk
set gp=function rj
set hp=function ej
set Fp=function fj
set kp=function mj
set jp=function Uj
set xp=function Bj
set vp=function rx
set mp=function ex
set Qp=function Tx
set Wp=function Wx
set Ep=function Dx
set Zp=function uv
set Up=function cv
set Ip=function fv
set Pp=function gv
set Ap=function Uv
set Dp=function Jv
set Hp=function Kv
set Jp=function Nv
set Kp=function Mv
set Lp=function im
set Xp=function Sm
set Cp=function ym
set Vp=function pm
set Bp=function fm
set Np=function Rm
set Mp=function Fm
set we=function km
set ue=function Wm
set re=function Em
set se=function Dm
set te=function Hm
set ie=function Vm
set Se=function Bm
set ce=function sQ
set oe=function tQ
set Oe=function lQ
set le=function bQ
set be=function nQ
set ye=function dQ
set pe=function gQ
set ee=function hQ
set qe=function mQ
set ae=function QQ
set ne=function PQ
set de=function AQ
set fe=function XQ
set Re=function CQ
set Te=function uW
set Ye=function rW
set Ge=function oW
set ge=function OW
set he=function qW
set Fe=function aW
set ke=function YW
set je=function GW
set xe=function xW
set ve=function vW
set me=function UW
set Qe=function IW
set We=function JW
set Ee=function KW
set Ze=function CW
set Ue=function VW
set Ie=function rE
set Pe=function sE
set Ae=function OE
set De=function lE
set He=function aE
set Je=function nE
set Ke=function GE
set Le=function gE
set Xe=function vE
set Ce=function mE
set Ve=function IE
set Be=function PE
set Ne=function LE
set Me=function XE
set wq=function wZ
set uq=function uZ
set rq=function cZ
set sq=function oZ
set tq=function eZ
set iq=function qZ
set Sq=function TZ
set cq=function YZ
set oq=function jZ
set Oq=function xZ
set lq=function ZZ
set bq=function UZ
set yq=function JZ
set pq=function KZ
set eq=function BZ
set qq=function NZ
set aq=function uU
set nq=function rU
set dq=function oU
set fq=function OU
set Rq=function qU
set Tq=function aU
set Yq=function YU
set Gq=function GU
set gq=function xU
set hq=function vU
set Fq=function UU
set kq=function IU
set jq=function KU
set xq=function LU
set vq=function MU
set mq=function wI
set Qq=function SI
set Wq=function cI
set Eq=function pI
set Zq=function eI
set Uq=function RI
set Iq=function TI
set Pq=function kI
set Aq=function jI
set Dq=function EI
set Hq=function ZI
set Jq=function HI
set Kq=function JI
set Lq=function VI
set Xq=function BI
set Cq=function wP
set Vq=function uP
set Bq=function cP
set Nq=function oP
set Mq=function eP
set wa=function qP
set ua=function TP
set ra=function YP
set sa=function jP
set ta=function xP
set ia=function ZP
set Sa=function UP
set ca=function JP
set oa=function KP
set Oa=function NP
set la=function MP
set ba=function iA
set ya=function SA
set pa=function yA
set ea=function pA
set qa=function fA
set aa=function RA
set na=function FA
set da=function kA
set fa=function WA
set Ra=function EA
set Ta=function DA
set Ya=function HA
set Ga=function VA
set ga=function BA
set ha=function sD
set Fa=function tD
set ka=function lD
set ja=function bD
set xa=function nD
set va=function dD
set ma=function GD
set Qa=function gD
set Wa=function kD
set Ea=function jD
set Za=function FD
set Ua=function ED
set Ia=function AD
set Pa=function XD
set Aa=function rH
set Da=function oH
set Ha=function aH
set Ja=function TH
set Ka=function xH
set La=function ZH
set Xa=function KH
set Ca=function NH
set Va=function SJ
set Ba=function yJ
set Na=function pJ
set Ma=function fJ
set wn=function RJ
set un=function FJ
set rn=function kJ
set sn=function WJ
set tn=function EJ
set Sn=function DJ
set cn=function HJ
set on=function VJ
set On=function BJ
set ln=function sK
set bn=function tK
set yn=function lK
set pn=function bK
set en=function nK
set qn=function dK
set an=function gK
set nn=function hK
set dn=function mK
set fn=function QK
set Rn=function PK
set Tn=function AK
set Yn=function XK
set Gn=function CK
set gn=function uL
set hn=function rL
set Fn=function oL
set kn=function OL
set jn=function qL
set xn=function aL
set vn=function YL
set mn=function GL
set Qn=function xL
set Wn=function vL
set En=function UL
set Zn=function IL
set Un=function KL
set In=function LL
set Pn=function ML
set An=function wX
set Dn=function AT
set Hn=function Sv
set Jn=function d0w
set Kn=function K1
set Ln=function Fww
set Xn=function pX
set Cn=function brw
set Vn=function D2
set Bn=function K9
set Nn=function S0w
set Mn=function xX
set wd=function m1
set ud=function b4
set rd=function d1
set sd=function H2
set td=function b0w
set id=function Zww
set Sd=function X9
set cd=function Xjw
set od=function P1
set Od=function L1
set ld=function Vrw
set bd=function Cjw
set yd=function lB
set pd=function Vjw
set ed=function Njw
set qd=function yX
set ad=function E8
set nd=function D1
set dd=function Mjw
set fd=function wxw
set Rd=function uxw
set Td=function GB
set Yd=function Uww
set Gd=function mX
set gd=function Z3
set hd=function J1
set Fd=function y9
set kd=function gww
set jd=function hww
set xd=function Jww
set vd=function Kww
set md=function rxw
set Qd=function Lww
set Wd=function n2
set Ed=function sxw
set Zd=function txw
set Ud=function b9
set Id=function ixw
set Pd=function Sxw
set Ad=function cxw
set Dd=function Xww
set Hd=function oxw
set Jd=function m2
set Kd=function v1
set Ld=function Eww
set Xd=function Oxw
set Cd=function A0w
set Vd=function qxw
set Bd=function axw
set Nd=function L9
set Md=function y4
set wf=function nxw
set uf=function aX
set rf=function vX
set sf=function dxw
set tf=function fxw
set Sf=function Rxw
set cf=function Txw
set of=function Yxw
set Of=function H1
set lf=function hxw
set bf=function iN
set yf=function Fxw
set pf=function kxw
set ef=function jxw
set qf=function dM
set af=function xxw
set nf=function vxw
set df=function l4
set ff=function mxw
set Rf=function Qxw
set Tf=function Wxw
set Yf=function Exw
set Gf=function Zxw
set gf=function Uxw
set hf=function Ixw
set Ff=function Pxw
set kf=function Axw
set jf=function Dxw
set xf=function Hxw
set vf=function pC
set mf=function Jxw
set Qf=function XV
set Wf=function Kxw
set Ef=function Lxw
set Zf=function Cxw
set Uf=function iM
set If=function Vxw
set Pf=function A1
set Af=function Bxw
set Df=function Nxw
set Hf=function Q1
set Jf=function a2
set Kf=function Mxw
set Lf=function uvw
set Xf=function rvw
set Cf=function svw
set Vf=function tvw
set Bf=function ivw
set Nf=function Svw
set Mf=function cvw
set wR=function lvw
set uR=function F9
set rR=function j9
set sR=function x9
set tR=function Ovw
set iR=function wvw
endfunction
function main takes nothing returns nothing
local trigger OX
local trigger lX
local trigger bX
call yR()
call SetCameraBounds((-30720.0)+GetCameraMargin(CAMERA_MARGIN_LEFT),(-30720.0)+GetCameraMargin(CAMERA_MARGIN_BOTTOM),30720.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),30720.0-GetCameraMargin(CAMERA_MARGIN_TOP),(-30720.0)+GetCameraMargin(CAMERA_MARGIN_LEFT),30720.0-GetCameraMargin(CAMERA_MARGIN_TOP),30720.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),(-30720.0)+GetCameraMargin(CAMERA_MARGIN_BOTTOM))
call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl","Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
call NewSoundEnvironment("Default")
call SetAmbientDaySound("LordaeronSummerDay")
call SetAmbientNightSound("LordaeronSummerNight")
call SetMapMusic("Music",true,0)
set fs=CreateSound("Sound\\Interface\\Warning.wav",false,false,false,10,10,"")
call SetSoundParamsFromLabel(fs,"Warning")
call SetSoundDuration(fs,1903)
set q=Rect(11872.0,-24096.0,13376.0,-18304.0)
set a=Rect(14080.0,-30720.0,16256.0,-25664.0)
set n=Rect(12096.0,-26240.0,14944.0,-23776.0)
set d=Rect(-17120.0,15936.0,-15520.0,17408.0)
call Rect(-29824.0,-30080.0,-29312.0,-28672.0)
call Rect(-29216.0,-30112.0,-28672.0,-28672.0)
call Rect(-25984.0,-29760.0,-24992.0,-29504.0)
call Rect(-25984.0,-30080.0,-25472.0,-29824.0)
call Rect(-25984.0,-30400.0,-25472.0,-30144.0)
call Rect(-26464.0,-30048.0,-26176.0,-29056.0)
call Rect(-25440.0,-30368.0,-25184.0,-29856.0)
call Rect(-25184.0,-30368.0,-24928.0,-29856.0)
call Rect(-24672.0,-29568.0,-24064.0,-28800.0)
call Rect(-24704.0,-30208.0,-24064.0,-29696.0)
set f=Rect(-17408.0,22016.0,-17056.0,22368.0)
set R=Rect(-19072.0,17728.0,-18688.0,18080.0)
set T=Rect(-22464.0,22208.0,-22112.0,22560.0)
set Y=Rect(-3776.0,4416.0,-3392.0,4768.0)
set G=Rect(-3872.0,1664.0,-3456.0,2016.0)
set g=Rect(-416.0,-2592.0,-128.0,-2272.0)
set h=Rect(4992.0,-2016.0,5344.0,-1696.0)
set F=Rect(2528.0,-3168.0,2848.0,-2880.0)
set k=Rect(7744.0,-2528.0,8096.0,-2208.0)
set j=Rect(-17504.0,18080.0,-17056.0,18496.0)
set x=Rect(1024.0,-1120.0,1376.0,-800.0)
set v=Rect(-3328.0,8096.0,-2848.0,8512.0)
set m=Rect(-4704.0,11488.0,-4416.0,11776.0)
set Q=Rect(-640.0,8288.0,-160.0,8704.0)
set W=Rect(-5184.0,17120.0,-4832.0,17440.0)
set E=Rect(-96.0,12448.0,224.0,12768.0)
set Z=Rect(-2272.0,13536.0,-1984.0,13856.0)
set U=Rect(7008.0,1984.0,7456.0,2432.0)
set I=Rect(4032.0,3744.0,4416.0,4064.0)
set P=Rect(4000.0,5216.0,4320.0,5536.0)
set A=Rect(-576.0,2880.0,-224.0,3232.0)
set D=Rect(-8288.0,19776.0,-7936.0,20160.0)
set H=Rect(-6464.0,21184.0,-6080.0,21568.0)
set J=Rect(-7904.0,22048.0,-7488.0,22464.0)
set K=Rect(-5344.0,14304.0,-4960.0,14720.0)
set L=Rect(2880.0,32.0,3264.0,352.0)
set X=Rect(608.0,15680.0,992.0,16096.0)
set C=Rect(-2496.0,15872.0,-2112.0,16224.0)
set V=Rect(1056.0,10848.0,1344.0,11136.0)
set B=Rect(1600.0,6784.0,1984.0,7136.0)
set N=Rect(224.0,19296.0,544.0,19648.0)
set M=Rect(2784.0,22592.0,3200.0,22944.0)
set ww=Rect(-1984.0,19008.0,-1600.0,19360.0)
set uw=Rect(3008.0,18048.0,3392.0,18400.0)
call Rect(-28544.0,-30080.0,-28064.0,-29344.0)
call Rect(-27744.0,-30080.0,-27456.0,-29760.0)
set rw=Rect(4224.0,19488.0,4608.0,19776.0)
set sw=Rect(13056.0,4960.0,13408.0,5280.0)
set tw=Rect(5696.0,24768.0,6048.0,25088.0)
set iw=Rect(3328.0,26816.0,3680.0,27168.0)
set Sw=Rect(8608.0,26144.0,9024.0,26528.0)
set cw=Rect(6656.0,21248.0,7008.0,21600.0)
set ow=Rect(-16640.0,10368.0,-13504.0,13056.0)
set Ow=Rect(-18944.0,5312.0,-16864.0,7328.0)
set lw=Rect(-28032.0,-1120.0,-22464.0,640.0)
set bw=Rect(-27264.0,2784.0,-26208.0,3328.0)
set yw=Rect(-26912.0,-4320.0,-23872.0,-2976.0)
set pw=Rect(-19328.0,-288.0,-18592.0,1568.0)
set ew=Rect(-11936.0,7616.0,-448.0,11424.0)
set qw=Rect(-1664.0,1216.0,6848.0,7776.0)
set aw=Rect(-5472.0,24704.0,-3232.0,27616.0)
set nw=Rect(3744.0,10880.0,4064.0,11232.0)
set dw=Rect(-12064.0,11392.0,-8832.0,16576.0)
set fw=Rect(-8832.0,10176.0,23520.0,17760.0)
set Rw=Rect(4384.0,17728.0,23424.0,27040.0)
set Tw=Rect(-10688.0,17536.0,-10304.0,17888.0)
set Yw=Rect(-10688.0,-9312.0,-10336.0,-9024.0)
set Gw=Rect(17280.0,9280.0,17632.0,9632.0)
set gw=Rect(8352.0,12192.0,8672.0,12512.0)
set hw=Rect(5952.0,18400.0,6304.0,18688.0)
set Fw=Rect(9120.0,19872.0,9408.0,20192.0)
set kw=Rect(23328.0,-14080.0,30688.0,17792.0)
set jw=Rect(13984.0,-288.0,14336.0,0.0)
set xw=Rect(10624.0,-7552.0,11008.0,-7200.0)
set vw=Rect(15168.0,-5792.0,15552.0,-5408.0)
set mw=Rect(15328.0,-7712.0,15648.0,-7424.0)
set Qw=Rect(12640.0,-7104.0,12992.0,-6752.0)
set Ww=Rect(17056.0,-8800.0,17376.0,-8512.0)
set Ew=Rect(18432.0,-608.0,18784.0,-320.0)
set Zw=Rect(13760.0,-11168.0,14112.0,-10752.0)
set Uw=Rect(16768.0,-16416.0,17120.0,-16032.0)
set Iw=Rect(18880.0,-7616.0,19232.0,-7296.0)
set Pw=Rect(6816.0,-6752.0,7136.0,-6464.0)
set Aw=Rect(12512.0,-4064.0,12832.0,-3712.0)
set Dw=Rect(9056.0,-4576.0,9344.0,-4288.0)
set Hw=Rect(-26464.0,-8896.0,-26144.0,-8544.0)
set Jw=Rect(-21632.0,-8544.0,-21248.0,-8224.0)
set Kw=Rect(-16928.0,-8224.0,-16608.0,-7904.0)
set Lw=Rect(-10112.0,-11424.0,-9760.0,-11136.0)
set Xw=Rect(-7680.0,-16416.0,-7328.0,-16128.0)
set Cw=Rect(288.0,-17760.0,608.0,-17472.0)
set Vw=Rect(9248.0,-21376.0,9984.0,-20640.0)
set Bw=Rect(24704.0,-27648.0,25088.0,-27264.0)
set Nw=Rect(10816.0,-18688.0,11168.0,-18304.0)
set Mw=Rect(13056.0,-18016.0,13408.0,-17760.0)
set wu=Rect(12096.0,-21024.0,12448.0,-20704.0)
set uu=Rect(15680.0,5600.0,16032.0,5920.0)
set ru=Rect(6944.0,7648.0,7264.0,7968.0)
set su=Rect(5824.0,12256.0,6176.0,12576.0)
set tu=Rect(11200.0,7712.0,11552.0,8064.0)
set iu=Rect(12480.0,11136.0,12832.0,11456.0)
set Su=Rect(14880.0,22944.0,15200.0,23232.0)
set cu=Rect(11392.0,16768.0,11744.0,17088.0)
set ou=Rect(23840.0,96.0,24128.0,384.0)
set Ou=Rect(19488.0,11168.0,19808.0,11488.0)
set lu=Rect(20672.0,2528.0,21056.0,2848.0)
set bu=Rect(23776.0,2368.0,24160.0,2720.0)
set yu=Rect(18336.0,-13408.0,18624.0,-13120.0)
set pu=Rect(17056.0,-11648.0,17376.0,-11264.0)
set eu=Rect(15488.0,-17696.0,15840.0,-17376.0)
set qu=Rect(24896.0,-8480.0,25248.0,-8128.0)
set au=Rect(16480.0,-14368.0,16768.0,-14048.0)
set nu=Rect(17088.0,-19744.0,17440.0,-19456.0)
set du=Rect(22720.0,-10432.0,23072.0,-10048.0)
set fu=Rect(20672.0,-23232.0,21056.0,-22848.0)
set Ru=Rect(19904.0,-5920.0,20256.0,-5632.0)
set Tu=Rect(18624.0,-3936.0,18976.0,-3616.0)
set Yu=Rect(-13632.0,-14816.0,-12192.0,-13376.0)
set Gu=Rect(17760.0,-10400.0,23360.0,-1344.0)
set gu=Rect(12384.0,-5984.0,13824.0,-4352.0)
set hu=Rect(-10944.0,3968.0,-7680.0,5120.0)
set Fu=Rect(-6528.0,7808.0,-6176.0,8160.0)
set ku=Rect(-8864.0,6912.0,-8448.0,7264.0)
set ju=Rect(-11680.0,14304.0,-11264.0,14752.0)
set xu=Rect(-9760.0,12928.0,-9472.0,13280.0)
set vu=Rect(-7552.0,16928.0,-7232.0,17248.0)
set mu=Rect(-17472.0,-3328.0,-17120.0,-2976.0)
call Rect(-24576.0,-1376.0,-24224.0,-1024.0)
set Qu=Rect(23392.0,10912.0,23712.0,11232.0)
set Wu=Rect(17280.0,19456.0,17632.0,19808.0)
set Eu=Rect(-16896.0,24032.0,-16544.0,24352.0)
set Zu=Rect(-15904.0,25952.0,-15520.0,26304.0)
set Uu=Rect(-17312.0,26624.0,-16896.0,27008.0)
set Iu=Rect(-16096.0,20352.0,-15712.0,20768.0)
set Pu=Rect(-20448.0,21440.0,-20064.0,21792.0)
set Au=Rect(-22560.0,19808.0,-22272.0,20128.0)
set Du=Rect(-18752.0,19520.0,-18400.0,19872.0)
set Hu=Rect(-16128.0,16896.0,-15808.0,17248.0)
set Ju=Rect(-17952.0,15904.0,-17632.0,16224.0)
set Ku=Rect(-19936.0,16352.0,-19648.0,16672.0)
set Lu=Rect(-17248.0,12448.0,-16928.0,12832.0)
set Xu=Rect(-13728.0,11968.0,-13408.0,12352.0)
set Cu=Rect(-15232.0,10624.0,-14880.0,10976.0)
set Vu=Rect(-13856.0,7872.0,-13568.0,8256.0)
set Bu=Rect(-16192.0,5824.0,-15840.0,6208.0)
set Nu=Rect(-16864.0,3392.0,-16576.0,3776.0)
set Mu=Rect(-18880.0,5568.0,-18528.0,5920.0)
set wr=Rect(-20288.0,1216.0,-19936.0,1600.0)
set ur=Rect(-17216.0,352.0,-16896.0,736.0)
set rr=Rect(-24512.0,3744.0,-24128.0,4064.0)
set sr=Rect(-22720.0,2368.0,-22432.0,2752.0)
set tr=Rect(-23552.0,-256.0,-23200.0,128.0)
set ir=Rect(-25376.0,1312.0,-25056.0,1632.0)
set Sr=Rect(-28736.0,-192.0,-28352.0,160.0)
set cr=Rect(-21024.0,2944.0,-20704.0,3360.0)
set lr=Rect(-13792.0,2144.0,-13440.0,2592.0)
set br=Rect(-13568.0,14912.0,-13216.0,15296.0)
set yr=Rect(-12736.0,16128.0,-12352.0,16512.0)
set pr=Rect(-10880.0,3360.0,-10528.0,3712.0)
set er=Rect(-10048.0,5280.0,-9696.0,5600.0)
set qr=Rect(-6880.0,3936.0,-6560.0,4256.0)
set ar=Rect(-8224.0,3040.0,-7904.0,3392.0)
set nr=Rect(-8960.0,1760.0,-8608.0,2176.0)
set dr=Rect(-6624.0,1088.0,-6304.0,1472.0)
set fr=Rect(-7296.0,-960.0,-6944.0,-544.0)
set Rr=Rect(-23712.0,-4704.0,-23392.0,-4416.0)
set Tr=Rect(-25184.0,-3168.0,-24864.0,-2848.0)
set Yr=Rect(-21888.0,-4416.0,-21536.0,-4032.0)
set Gr=Rect(-20928.0,-2304.0,-20576.0,-1888.0)
set gr=Rect(-7776.0,11040.0,-7456.0,11392.0)
set hr=Rect(-11648.0,7072.0,-11296.0,7360.0)
set Fr=Rect(-13728.0,4992.0,-13408.0,5376.0)
set kr=Rect(-5152.0,21696.0,-4832.0,22080.0)
set jr=Rect(-5248.0,24416.0,-4960.0,24768.0)
set xr=Rect(-6688.0,28096.0,-6368.0,28480.0)
set vr=Rect(-9024.0,26496.0,-8736.0,26880.0)
set mr=Rect(-10048.0,28224.0,-9696.0,28576.0)
set Qr=Rect(-1408.0,23776.0,-1152.0,24096.0)
set Wr=Rect(-2720.0,26176.0,-2432.0,26560.0)
set Er=Rect(-28032.0,-2944.0,-27680.0,-2560.0)
set Zr=Rect(-29760.0,-10016.0,-29408.0,-9632.0)
set Ur=Rect(15296.0,-26976.0,15648.0,-26624.0)
set Ir=Rect(-20544.0,12032.0,-20160.0,12416.0)
set Pr=Rect(-18368.0,10624.0,-18016.0,11008.0)
set Ar=Rect(-10880.0,-576.0,-10528.0,-224.0)
set Dr=Rect(-11104.0,-4768.0,-10816.0,-4448.0)
set Hr=Rect(-5728.0,-2912.0,-5440.0,-2560.0)
set Jr=Rect(-3904.0,-6720.0,-3552.0,-6336.0)
set Kr=Rect(-3616.0,-3040.0,-3328.0,-2688.0)
set Lr=Rect(-7200.0,-8000.0,-6880.0,-7616.0)
set Xr=Rect(-5504.0,-9344.0,-5248.0,-9056.0)
set Cr=Rect(-11616.0,10848.0,-11296.0,11168.0)
set Vr=Rect(-1792.0,-320.0,-1440.0,64.0)
set Br=Rect(3232.0,-7488.0,3552.0,-7136.0)
set Nr=Rect(8224.0,-10496.0,8512.0,-10208.0)
set Mr=Rect(1344.0,29280.0,1696.0,29632.0)
set ws=Rect(10848.0,-2144.0,11136.0,-1824.0)
set us=Rect(-26496.0,-1568.0,-26144.0,-1248.0)
set rs=Rect(-27168.0,2528.0,-26880.0,2816.0)
set ss=Rect(-2016.0,27552.0,-1696.0,27936.0)
set ts=Rect(-3488.0,23040.0,-3200.0,23392.0)
set is=Rect(2016.0,-7904.0,2336.0,-7584.0)
set Ss=Rect(640.0,-5760.0,992.0,-5376.0)
set cs=Rect(5216.0,-12384.0,5504.0,-12064.0)
set os=Rect(18272.0,-17504.0,18656.0,-17056.0)
set Os=Rect(26848.0,-11680.0,27168.0,-11360.0)
set ls=Rect(6464.0,-4672.0,6816.0,-4288.0)
set bs=Rect(20672.0,21312.0,21024.0,21696.0)
set ys=Rect(-1824.0,5792.0,-1440.0,6144.0)
set ps=Rect(-23264.0,-8992.0,-22944.0,-8704.0)
set es=Rect(-13504.0,-8640.0,-13184.0,-8384.0)
set qs=Rect(26048.0,-2848.0,26400.0,-2528.0)
set as=Rect(28864.0,-3360.0,29152.0,-3040.0)
set ns=Rect(28064.0,2592.0,28352.0,2880.0)
set ds=Rect(27488.0,-5984.0,27808.0,-5664.0)
call Rect(-30720.0,-10592.0,-29536.0,-9376.0)
call mT()
call QT()
call InitBlizzard()
call eR()
call iX()
set lX=Ts
if TriggerEvaluate(lX) then
call TriggerExecute(lX)
endif
set bX=wt
if TriggerEvaluate(bX) then
call TriggerExecute(bX)
endif
set OX=CreateTrigger()
call TriggerAddCondition(OX,Condition(Jn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Real.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Kn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Integer.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ln))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package String.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Xn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Angle.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Cn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Vectors.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Vn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Maths.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Bn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Player.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Nn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Printing.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Mn))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Basics.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(wd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package GameTimer.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ud))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MagicFunctions.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(rd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ErrorHandling.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(sd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Matrices.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(td))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Quaternion.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(id))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Table.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Sd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Playercolor.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(cd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Colors.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(od))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Group.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Od))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Lightning.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ld))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package WeatherEffects.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(bd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TypeCasting.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(yd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureForGroups.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(pd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LinkedList.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ed))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Abilities.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(qd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package AbilityIds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ad))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MutliboardTools.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(nd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package HashList.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(dd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package EventHelper.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(fd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package RegisterEvents.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Rd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TimerUtils.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Td))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureTimers.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Yd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TargetsAllowed.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Gd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Buildings.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(gd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Doodads.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(hd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Icons.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Fd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Objects.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(kd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Sounds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(jd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Soundsets.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(xd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Textures.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(vd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UI.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(md))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Units.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Qd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UnitIds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Wd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MapBounds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ed))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DummyRecycler.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Zd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package StringUtils.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ud))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ObjectIds.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Id))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Preloader.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Pd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ObjectIdGenerator.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ad))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OnUnitEnterLeave.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Dd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UnitIndexer.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Hd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureEvents.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Jd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MathTools.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Kd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Forces.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ld))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Strings.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Xd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityBaseTaxes.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Cd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Revolts.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Vd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package City.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Bd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Multiboards.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Nd))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package PlayerStats.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Md))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Main.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(wf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CommandTools.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(uf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package BNetName.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(rf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Bootleg.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(sf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CastleCapture.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(tf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityBuilded.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Sf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityManage.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(cf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityModifiers.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(of))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Clerics.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Of))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package HashSet.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(lf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package VoteKick.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(bf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Commands.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(yf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Credits.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(pf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Economy.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ef))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DateTime.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(qf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Diplomacy.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(af))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Garissons.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(nf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LimitEncampments.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(df))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Logarithm.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(ff))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MainInit.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Rf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MassControl.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Tf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MultiboardCityUpdate.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Yf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package NoShipsNearRivers.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Gf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package NoStarvationOnBoat.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(gf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OnPlayerLeave.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(hf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OreCapture.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(Ff))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package RangeChecks.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(kf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Religion.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(jf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Taxation.")
endif
call TriggerClearConditions(OX)
call TriggerAddCondition(OX,Condition(xf))
if not TriggerEvaluate(OX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Upkeep.")
endif
call TriggerClearConditions(OX)
call DestroyTrigger(OX)
set OX=null
set lX=null
set bX=null
endfunction
function SX takes nothing returns nothing
call SetPlayerStartLocation(Player(0),0)
call ForcePlayerStartLocation(Player(0),0)
call SetPlayerColor(Player(0),ConvertPlayerColor(0))
call SetPlayerRacePreference(Player(0),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(0),false)
call SetPlayerController(Player(0),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(1),1)
call ForcePlayerStartLocation(Player(1),1)
call SetPlayerColor(Player(1),ConvertPlayerColor(1))
call SetPlayerRacePreference(Player(1),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(1),false)
call SetPlayerController(Player(1),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(2),2)
call ForcePlayerStartLocation(Player(2),2)
call SetPlayerColor(Player(2),ConvertPlayerColor(2))
call SetPlayerRacePreference(Player(2),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(2),false)
call SetPlayerController(Player(2),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(3),3)
call ForcePlayerStartLocation(Player(3),3)
call SetPlayerColor(Player(3),ConvertPlayerColor(3))
call SetPlayerRacePreference(Player(3),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(3),false)
call SetPlayerController(Player(3),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(4),4)
call ForcePlayerStartLocation(Player(4),4)
call SetPlayerColor(Player(4),ConvertPlayerColor(4))
call SetPlayerRacePreference(Player(4),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(4),false)
call SetPlayerController(Player(4),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(5),5)
call ForcePlayerStartLocation(Player(5),5)
call SetPlayerColor(Player(5),ConvertPlayerColor(5))
call SetPlayerRacePreference(Player(5),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(5),false)
call SetPlayerController(Player(5),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(6),6)
call ForcePlayerStartLocation(Player(6),6)
call SetPlayerColor(Player(6),ConvertPlayerColor(6))
call SetPlayerRacePreference(Player(6),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(6),false)
call SetPlayerController(Player(6),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(7),7)
call ForcePlayerStartLocation(Player(7),7)
call SetPlayerColor(Player(7),ConvertPlayerColor(7))
call SetPlayerRacePreference(Player(7),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(7),false)
call SetPlayerController(Player(7),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(8),8)
call ForcePlayerStartLocation(Player(8),8)
call SetPlayerColor(Player(8),ConvertPlayerColor(8))
call SetPlayerRacePreference(Player(8),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(8),false)
call SetPlayerController(Player(8),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(9),9)
call ForcePlayerStartLocation(Player(9),9)
call SetPlayerColor(Player(9),ConvertPlayerColor(9))
call SetPlayerRacePreference(Player(9),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(9),false)
call SetPlayerController(Player(9),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(10),10)
call ForcePlayerStartLocation(Player(10),10)
call SetPlayerColor(Player(10),ConvertPlayerColor(10))
call SetPlayerRacePreference(Player(10),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(10),false)
call SetPlayerController(Player(10),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(11),11)
call ForcePlayerStartLocation(Player(11),11)
call SetPlayerColor(Player(11),ConvertPlayerColor(11))
call SetPlayerRacePreference(Player(11),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(11),false)
call SetPlayerController(Player(11),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(12),12)
call ForcePlayerStartLocation(Player(12),12)
call SetPlayerColor(Player(12),ConvertPlayerColor(12))
call SetPlayerRacePreference(Player(12),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(12),false)
call SetPlayerController(Player(12),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(13),13)
call ForcePlayerStartLocation(Player(13),13)
call SetPlayerColor(Player(13),ConvertPlayerColor(13))
call SetPlayerRacePreference(Player(13),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(13),false)
call SetPlayerController(Player(13),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(14),14)
call ForcePlayerStartLocation(Player(14),14)
call SetPlayerColor(Player(14),ConvertPlayerColor(14))
call SetPlayerRacePreference(Player(14),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(14),false)
call SetPlayerController(Player(14),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(15),15)
call ForcePlayerStartLocation(Player(15),15)
call SetPlayerColor(Player(15),ConvertPlayerColor(15))
call SetPlayerRacePreference(Player(15),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(15),false)
call SetPlayerController(Player(15),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(16),16)
call ForcePlayerStartLocation(Player(16),16)
call SetPlayerColor(Player(16),ConvertPlayerColor(16))
call SetPlayerRacePreference(Player(16),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(16),false)
call SetPlayerController(Player(16),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(17),17)
call ForcePlayerStartLocation(Player(17),17)
call SetPlayerColor(Player(17),ConvertPlayerColor(17))
call SetPlayerRacePreference(Player(17),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(17),false)
call SetPlayerController(Player(17),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(18),18)
call ForcePlayerStartLocation(Player(18),18)
call SetPlayerColor(Player(18),ConvertPlayerColor(18))
call SetPlayerRacePreference(Player(18),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(18),false)
call SetPlayerController(Player(18),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(19),19)
call ForcePlayerStartLocation(Player(19),19)
call SetPlayerColor(Player(19),ConvertPlayerColor(19))
call SetPlayerRacePreference(Player(19),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(19),false)
call SetPlayerController(Player(19),MAP_CONTROL_USER)
endfunction
function cX takes nothing returns nothing
call SetPlayerTeam(Player(0),0)
call SetPlayerTeam(Player(1),0)
call SetPlayerTeam(Player(2),0)
call SetPlayerTeam(Player(3),0)
call SetPlayerTeam(Player(4),0)
call SetPlayerTeam(Player(5),0)
call SetPlayerTeam(Player(6),0)
call SetPlayerTeam(Player(7),0)
call SetPlayerTeam(Player(8),0)
call SetPlayerTeam(Player(9),0)
call SetPlayerTeam(Player(10),0)
call SetPlayerTeam(Player(11),0)
call SetPlayerTeam(Player(12),1)
call SetPlayerTeam(Player(13),1)
call SetPlayerTeam(Player(14),1)
call SetPlayerTeam(Player(15),1)
call SetPlayerTeam(Player(16),1)
call SetPlayerTeam(Player(17),1)
call SetPlayerTeam(Player(18),1)
call SetPlayerTeam(Player(19),1)
endfunction
function oX takes nothing returns nothing
call SetStartLocPrioCount(0,19)
call SetStartLocPrio(0,0,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,9,10,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,10,11,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,11,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,12,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,13,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,14,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,15,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(1,9)
call SetStartLocPrio(1,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(2,9)
call SetStartLocPrio(2,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(3,9)
call SetStartLocPrio(3,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(4,9)
call SetStartLocPrio(4,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(5,9)
call SetStartLocPrio(5,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(6,9)
call SetStartLocPrio(6,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(7,9)
call SetStartLocPrio(7,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(8,9)
call SetStartLocPrio(8,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(9,9)
call SetStartLocPrio(9,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(10,16)
call SetStartLocPrio(10,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,10,12,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,11,13,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,12,14,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,13,15,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,14,16,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,15,17,MAP_LOC_PRIO_LOW)
call SetStartLocPrioCount(11,19)
call SetStartLocPrio(11,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,10,10,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,11,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,12,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,13,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,14,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,15,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(12,5)
call SetStartLocPrio(12,0,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,1,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,2,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(13,5)
call SetStartLocPrio(13,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,1,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,2,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(14,5)
call SetStartLocPrio(14,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,2,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(15,5)
call SetStartLocPrio(15,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,2,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(16,5)
call SetStartLocPrio(16,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,2,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,3,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(17,5)
call SetStartLocPrio(17,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,2,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,3,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,4,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(18,1)
call SetStartLocPrio(18,0,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(19,1)
call SetStartLocPrio(19,0,18,MAP_LOC_PRIO_HIGH)
endfunction
function config takes nothing returns nothing
call SetMapName("TRIGSTR_001")
call SetMapDescription("TRIGSTR_003")
call SetPlayers(20)
call SetTeams(20)
call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
call DefineStartLocation(0,320.0,5184.0)
call DefineStartLocation(1,320.0,5184.0)
call DefineStartLocation(2,320.0,5184.0)
call DefineStartLocation(3,320.0,5184.0)
call DefineStartLocation(4,320.0,5184.0)
call DefineStartLocation(5,320.0,5184.0)
call DefineStartLocation(6,320.0,5184.0)
call DefineStartLocation(7,320.0,5184.0)
call DefineStartLocation(8,320.0,5184.0)
call DefineStartLocation(9,320.0,5184.0)
call DefineStartLocation(10,320.0,5184.0)
call DefineStartLocation(11,320.0,5184.0)
call DefineStartLocation(12,320.0,5184.0)
call DefineStartLocation(13,320.0,5184.0)
call DefineStartLocation(14,320.0,5184.0)
call DefineStartLocation(15,320.0,5184.0)
call DefineStartLocation(16,320.0,5184.0)
call DefineStartLocation(17,320.0,5184.0)
call DefineStartLocation(18,320.0,5184.0)
call DefineStartLocation(19,320.0,5184.0)
call SX()
call cX()
call oX()
endfunction
