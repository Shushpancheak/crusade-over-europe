// this script was compiled with wurst 1.8.0.0-jenkins-Wurst-1091
globals
group w=null
location u=null
integer array r
force s=null
location t=null
location i=null
location S=null
location c=null
rect o=null
rect O=null
group l=null
group b=null
location y=null
boolean array p
boolean array e
rect q=null
rect a=null
rect n=null
rect d=null
rect f=null
rect R=null
rect T=null
rect Y=null
rect G=null
rect g=null
rect h=null
rect F=null
rect k=null
rect j=null
rect x=null
rect v=null
rect m=null
rect Q=null
rect W=null
rect E=null
rect Z=null
rect U=null
rect I=null
rect P=null
rect A=null
rect D=null
rect H=null
rect J=null
rect K=null
rect L=null
rect X=null
rect C=null
rect V=null
rect B=null
rect N=null
rect M=null
rect ww=null
rect uw=null
rect rw=null
rect sw=null
rect tw=null
rect iw=null
rect Sw=null
rect cw=null
rect ow=null
rect Ow=null
rect lw=null
rect bw=null
rect yw=null
rect pw=null
rect ew=null
rect qw=null
rect aw=null
rect nw=null
rect dw=null
rect fw=null
rect Rw=null
rect Tw=null
rect Yw=null
rect Gw=null
rect gw=null
rect hw=null
rect Fw=null
rect kw=null
rect jw=null
rect xw=null
rect vw=null
rect mw=null
rect Qw=null
rect Ww=null
rect Ew=null
rect Zw=null
rect Uw=null
rect Iw=null
rect Pw=null
rect Aw=null
rect Dw=null
rect Hw=null
rect Jw=null
rect Kw=null
rect Lw=null
rect Xw=null
rect Cw=null
rect Vw=null
rect Bw=null
rect Nw=null
rect Mw=null
rect wu=null
rect uu=null
rect ru=null
rect su=null
rect tu=null
rect iu=null
rect Su=null
rect cu=null
rect ou=null
rect Ou=null
rect lu=null
rect bu=null
rect yu=null
rect pu=null
rect eu=null
rect qu=null
rect au=null
rect nu=null
rect du=null
rect fu=null
rect Ru=null
rect Tu=null
rect Yu=null
rect Gu=null
rect gu=null
rect hu=null
rect Fu=null
rect ku=null
rect ju=null
rect xu=null
rect vu=null
rect mu=null
rect Qu=null
rect Wu=null
rect Eu=null
rect Zu=null
rect Uu=null
rect Iu=null
rect Pu=null
rect Au=null
rect Du=null
rect Hu=null
rect Ju=null
rect Ku=null
rect Lu=null
rect Xu=null
rect Cu=null
rect Vu=null
rect Bu=null
rect Nu=null
rect Mu=null
rect wr=null
rect ur=null
rect rr=null
rect sr=null
rect tr=null
rect ir=null
rect Sr=null
rect cr=null
rect lr=null
rect br=null
rect yr=null
rect pr=null
rect er=null
rect qr=null
rect ar=null
rect nr=null
rect dr=null
rect fr=null
rect Rr=null
rect Tr=null
rect Yr=null
rect Gr=null
rect gr=null
rect hr=null
rect Fr=null
rect kr=null
rect jr=null
rect xr=null
rect vr=null
rect mr=null
rect Qr=null
rect Wr=null
rect Er=null
rect Zr=null
rect Ur=null
rect Ir=null
rect Pr=null
rect Ar=null
rect Dr=null
rect Hr=null
rect Jr=null
rect Kr=null
rect Lr=null
rect Xr=null
rect Cr=null
rect Vr=null
rect Br=null
rect Nr=null
rect Mr=null
rect ws=null
rect us=null
rect rs=null
rect ss=null
rect ts=null
rect is=null
rect Ss=null
rect cs=null
rect os=null
rect Os=null
rect ls=null
rect bs=null
rect ys=null
rect ps=null
rect es=null
rect qs=null
rect as=null
rect ns=null
rect ds=null
sound fs=null
trigger Rs=null
trigger Ts=null
trigger Ys=null
trigger Gs=null
trigger gs=null
trigger hs=null
trigger Fs=null
trigger ks=null
trigger js=null
trigger xs=null
trigger vs=null
trigger ms=null
trigger Qs=null
trigger Ws=null
trigger Es=null
trigger Zs=null
trigger Us=null
trigger Is=null
trigger Ps=null
trigger As=null
trigger Ds=null
trigger Hs=null
trigger Js=null
trigger Ks=null
trigger Ls=null
trigger Xs=null
trigger Cs=null
trigger Vs=null
trigger Bs=null
trigger Ns=null
trigger Ms=null
trigger wt=null
trigger ut=null
trigger rt=null
trigger st=null
trigger tt=null
trigger St=null
trigger ct=null
trigger ot=null
trigger Ot=null
trigger lt=null
trigger bt=null
trigger yt=null
trigger pt=null
trigger et=null
trigger qt=null
trigger at=null
trigger nt=null
trigger dt=null
trigger ft=null
trigger Rt=null
trigger Tt=null
trigger Yt=null
trigger Gt=null
trigger gt=null
trigger ht=null
trigger Ft=null
trigger kt=null
trigger jt=null
trigger xt=null
trigger vt=null
trigger mt=null
trigger Qt=null
trigger Wt=null
trigger Et=null
trigger Zt=null
trigger Ut=null
trigger It=null
trigger Pt=null
trigger At=null
trigger Dt=null
trigger Ht=null
trigger Jt=null
trigger Kt=null
trigger Lt=null
trigger Xt=null
trigger Ct=null
trigger Vt=null
trigger Bt=null
trigger Nt=null
trigger Mt=null
trigger wi=null
trigger ui=null
trigger ri=null
trigger si=null
trigger ti=null
trigger ii=null
trigger Si=null
trigger ci=null
trigger oi=null
trigger Oi=null
trigger li=null
trigger bi=null
trigger yi=null
trigger pi=null
trigger ei=null
trigger qi=null
trigger ai=null
trigger ni=null
trigger di=null
trigger fi=null
trigger Ri=null
trigger Ti=null
trigger Yi=null
trigger Gi=null
trigger gi=null
trigger hi=null
trigger Fi=null
trigger ki=null
trigger ji=null
trigger xi=null
trigger vi=null
trigger mi=null
trigger Qi=null
trigger Wi=null
trigger Ei=null
trigger Zi=null
trigger Ui=null
trigger Ii=null
trigger Pi=null
trigger Ai=null
trigger Di=null
trigger Hi=null
trigger Ji=null
trigger Ki=null
trigger Li=null
trigger Xi=null
trigger Ci=null
trigger Vi=null
trigger Bi=null
trigger Ni=null
trigger Mi=null
trigger wS=null
trigger uS=null
trigger rS=null
rect sS=null
integer tS=0
string array iS
player SS=null
integer cS=0
integer array oS
integer OS=0
integer lS=0
integer bS=0
integer yS=0
integer pS=0
integer eS=0
integer qS=0
integer aS=0
integer nS=0
integer dS=0
integer fS=0
real RS=0.
real array TS
integer array YS
real array GS
real array gS
real array hS
real array FS
integer array kS
playerevent jS=null
trigger xS=null
trigger vS=null
trigger mS=null
integer array QS
integer WS=0
integer ES=0
integer ZS=0
integer array US
integer array IS
boolean PS=false
group AS=null
integer array DS
integer HS=0
integer JS=0
integer KS=0
filterfunc LS=null
integer XS=0
integer array CS
integer array VS
integer array BS
string array NS
integer MS=0
integer wc=0
real uc=0.
integer array rc
integer array sc
integer array tc
integer array ic
integer Sc=0
hashtable cc=null
force oc=null
force Oc=null
force lc=null
force bc=null
force array yc
integer array pc
integer array ec
integer array qc
timer ac=null
real nc=0.
group dc=null
hashtable fc=null
hashtable Rc=null
hashtable Tc=null
integer array Yc
integer Gc=0
boolean gc=false
boolean hc=false
boolean Fc=false
timer kc=null
real jc=0.
rect xc=null
rect vc=null
region mc=null
real Qc=0.
real Wc=0.
integer Ec=0
integer Zc=0
integer Uc=0
integer array Ic
integer array Pc
integer array Ac
integer array Dc
integer array Hc
integer array Jc
integer array Kc
integer array Lc
integer array Xc
multiboard array Cc
integer Vc=0
trigger Bc=null
group Nc=null
unit array Mc
integer wo=0
integer array uo
player array ro
player so=null
playercolor io=null
playercolor So=null
playercolor co=null
playercolor oo=null
playercolor array Oo
group lo=null
unit bo=null
integer yo=0
real po=0.
trigger array eo
integer qo=0
real array ao
integer no=0
string array do
string array fo
string array Ro
string array To
string array Yo
string array Go
string array go
string array ho
string array Fo
string array ko
string array jo
string array xo
string array vo
string array mo
string array Qo
string array Wo
string array Eo
hashtable Zo=null
timer array Uo
integer Io=0
integer Po=0
integer Ao=0
trigger Do=null
trigger Ho=null
unit array Jo
integer Ko=0
integer Lo=0
integer Xo=0
integer Co=0
integer array Vo
integer Bo=0
integer No=0
integer Mo=0
integer wO=0
integer array uO
integer rO=0
integer array sO
integer array tO
integer array iO
integer SO=0
integer cO=0
integer array oO
integer array OO
integer lO=0
integer bO=0
integer array yO
integer pO=0
integer eO=0
integer array qO
integer array aO
integer nO=0
integer dO=0
integer array fO
integer array RO
integer TO=0
integer YO=0
integer array GO
integer array gO
integer hO=0
integer FO=0
integer array kO
integer jO=0
integer array xO
integer array vO
integer mO=0
integer QO=0
integer array WO
integer array EO
integer ZO=0
integer UO=0
integer array IO
integer array PO
integer AO=0
integer DO=0
integer array HO
integer JO=0
integer KO=0
integer array LO
integer XO=0
integer CO=0
integer array VO
integer array BO
integer NO=0
integer MO=0
integer array wl
integer array ul
integer rl=0
integer sl=0
integer array tl
integer il=0
integer Sl=0
integer array cl
integer ol=0
integer Ol=0
integer array ll
integer array bl
integer yl=0
integer pl=0
integer array el
integer ql=0
integer al=0
integer array nl
real array dl
real array fl
boolean array Rl
real array Tl
integer array Yl
real array Gl
real array gl
string array hl
string array Fl
unit array kl
string array jl
integer array xl
integer array vl
integer array ml
real array Ql
real array Wl
integer array El
integer array Zl
real array Ul
real array Il
real array Pl
real array Al
integer array Dl
real array Hl
integer array Jl
integer array Kl
integer array Ll
integer array Xl
integer array Cl
integer array Vl
integer array Bl
integer array Nl
integer array Ml
integer array wb
integer array ub
integer array rb
integer array sb
integer array tb
unit array ib
timer array Sb
real array cb
integer array ob
integer array Ob
integer array lb
integer array bb
unit array yb
unit array pb
integer array eb
integer array qb
integer array ab
unit array nb
integer array db
integer array fb
integer array Rb
integer array Tb
integer array Yb
integer array Gb
integer array gb
boolean array hb
integer array Fb
integer array kb
player array jb
unit array xb
integer array vb
unit array mb
integer array Qb
real array Wb
real array Eb
unit array Zb
integer array Ub
player array Ib
boolean array Pb
integer array Ab
integer array Db
boolean array Hb
unit array Jb
unit array Kb
integer Lb=0
string array Xb
integer Cb=0
integer Vb=0
integer Bb=0
integer array Nb
integer array Mb
integer array wy
integer array uy
integer array ry
integer array sy
integer array ty
integer array iy
integer array Sy
integer array cy
integer array oy
integer array Oy
integer array ly
integer array by
integer array yy
integer array py
integer array ey
integer array qy
integer array ay
integer array ny
integer array dy
integer array fy
integer array Ry
integer array Ty
code Yy=null
code Gy=null
code gy=null
code hy=null
code Fy=null
code ky=null
code jy=null
code xy=null
code vy=null
code my=null
code Qy=null
code Wy=null
code Ey=null
code Zy=null
code Uy=null
code Iy=null
code Py=null
code Ay=null
code Dy=null
code Hy=null
code Jy=null
code Ky=null
code Ly=null
code Xy=null
code Cy=null
code Vy=null
code By=null
code Ny=null
code My=null
code wp=null
code up=null
code rp=null
code sp=null
code tp=null
code ip=null
code Sp=null
code cp=null
code op=null
code Op=null
code lp=null
code bp=null
code yp=null
code pp=null
code ep=null
code qp=null
code ap=null
code np=null
code dp=null
code fp=null
code Rp=null
code Tp=null
code Yp=null
code Gp=null
code gp=null
code hp=null
code Fp=null
code kp=null
code jp=null
code xp=null
code vp=null
code mp=null
code Qp=null
code Wp=null
code Ep=null
code Zp=null
code Up=null
code Ip=null
code Pp=null
code Ap=null
code Dp=null
code Hp=null
code Jp=null
code Kp=null
code Lp=null
code Xp=null
code Cp=null
code Vp=null
code Bp=null
code Np=null
code Mp=null
code we=null
code ue=null
code re=null
code se=null
code te=null
code ie=null
code Se=null
code ce=null
code oe=null
code Oe=null
code le=null
code be=null
code ye=null
code pe=null
code ee=null
code qe=null
code ae=null
code ne=null
code de=null
code fe=null
code Re=null
code Te=null
code Ye=null
code Ge=null
code ge=null
code he=null
code Fe=null
code ke=null
code je=null
code xe=null
code ve=null
code me=null
code Qe=null
code We=null
code Ee=null
code Ze=null
code Ue=null
code Ie=null
code Pe=null
code Ae=null
code De=null
code He=null
code Je=null
code Ke=null
code Le=null
code Xe=null
code Ce=null
code Ve=null
code Be=null
code Ne=null
code Me=null
code wq=null
code uq=null
code rq=null
code sq=null
code tq=null
code iq=null
code Sq=null
code cq=null
code oq=null
code Oq=null
code lq=null
code bq=null
code yq=null
code pq=null
code eq=null
code qq=null
code aq=null
code nq=null
code dq=null
code fq=null
code Rq=null
code Tq=null
code Yq=null
code Gq=null
code gq=null
code hq=null
code Fq=null
code kq=null
code jq=null
code xq=null
code vq=null
code mq=null
code Qq=null
code Wq=null
code Eq=null
code Zq=null
code Uq=null
code Iq=null
code Pq=null
code Aq=null
code Dq=null
code Hq=null
code Jq=null
code Kq=null
code Lq=null
code Xq=null
code Cq=null
code Vq=null
code Bq=null
code Nq=null
code Mq=null
code wa=null
code ua=null
code ra=null
code sa=null
code ta=null
code ia=null
code Sa=null
code ca=null
code oa=null
code Oa=null
code la=null
code ba=null
code ya=null
code pa=null
code ea=null
code qa=null
code aa=null
code na=null
code da=null
code fa=null
code Ra=null
code Ta=null
code Ya=null
code Ga=null
code ga=null
code ha=null
code Fa=null
code ka=null
code ja=null
code xa=null
code va=null
code ma=null
code Qa=null
code Wa=null
code Ea=null
code Za=null
code Ua=null
code Ia=null
code Pa=null
code Aa=null
code Da=null
code Ha=null
code Ja=null
code Ka=null
code La=null
code Xa=null
code Ca=null
code Va=null
code Ba=null
code Na=null
code Ma=null
code wn=null
code un=null
code rn=null
code sn=null
code tn=null
code Sn=null
code cn=null
code on=null
code On=null
code ln=null
code bn=null
code yn=null
code pn=null
code en=null
code qn=null
code an=null
code nn=null
code dn=null
code fn=null
code Rn=null
code Tn=null
code Yn=null
code Gn=null
code gn=null
code hn=null
code Fn=null
code kn=null
code jn=null
code xn=null
code vn=null
code mn=null
code Qn=null
code Wn=null
code En=null
code Zn=null
code Un=null
code In=null
code Pn=null
code An=null
code Dn=null
code Hn=null
code Jn=null
code Kn=null
code Ln=null
code Xn=null
code Cn=null
code Vn=null
code Bn=null
code Nn=null
code Mn=null
code wd=null
code ud=null
code rd=null
code sd=null
code td=null
code id=null
code Sd=null
code cd=null
code od=null
code Od=null
code ld=null
code bd=null
code yd=null
code pd=null
code ed=null
code qd=null
code ad=null
code nd=null
code dd=null
code fd=null
code Rd=null
code Td=null
code Yd=null
code Gd=null
code gd=null
code hd=null
code Fd=null
code kd=null
code jd=null
code xd=null
code vd=null
code md=null
code Qd=null
code Wd=null
code Ed=null
code Zd=null
code Ud=null
code Id=null
code Pd=null
code Ad=null
code Dd=null
code Hd=null
code Jd=null
code Kd=null
code Ld=null
code Xd=null
code Cd=null
code Vd=null
code Bd=null
code Nd=null
code Md=null
code wf=null
code uf=null
code rf=null
code sf=null
code tf=null
code Sf=null
code cf=null
code of=null
code Of=null
code lf=null
code bf=null
code yf=null
code pf=null
code ef=null
code qf=null
code af=null
code nf=null
code df=null
code ff=null
code Rf=null
code Tf=null
code Yf=null
code Gf=null
code gf=null
code hf=null
code Ff=null
code kf=null
code jf=null
code xf=null
code vf=null
code mf=null
code Qf=null
code Wf=null
code Ef=null
code Zf=null
code Uf=null
code If=null
code Pf=null
code Af=null
code Df=null
code Hf=null
code Jf=null
code Kf=null
code Lf=null
code Xf=null
code Cf=null
code Vf=null
code Bf=null
code Nf=null
code Mf=null
code wR=null
code uR=null
code rR=null
code sR=null
code tR=null
code iR=null
code SR=null
unit cR=null
multiboard oR=null
timer OR=null
unit lR=null
trigger bR=null
rect yR=null
endglobals
function QT takes nothing returns nothing
local player mT=Player(PLAYER_NEUTRAL_AGGRESSIVE)
call CreateUnit(mT,1747989297,-1600.0,-128.0,270.000)
call CreateUnit(mT,1747989297,-15040.0,10816.0,270.000)
call CreateUnit(mT,1747989297,-256.0,-2432.0,270.000)
call CreateUnit(mT,1747989297,-24320.0,3904.0,270.000)
call CreateUnit(mT,1747989297,-23552.0,-4544.0,270.000)
call CreateUnit(mT,1747989297,-23360.0,-64.0,270.000)
call CreateUnit(mT,1747989297,2176.0,-7744.0,270.000)
call CreateUnit(mT,1747989297,-6336.0,8000.0,270.000)
call CreateUnit(mT,1747989297,832.0,-5568.0,270.000)
call CreateUnit(mT,1747989297,-3648.0,1856.0,270.000)
call CreateUnit(mT,1747989042,-768.0,24384.0,270.000)
call CreateUnit(mT,1747989297,-26304.0,-8704.0,270.000)
call CreateUnit(mT,1747989297,2688.0,-3008.0,270.000)
call CreateUnit(mT,1747989297,-5568.0,-2752.0,270.000)
call CreateUnit(mT,1747989297,-3456.0,-2880.0,270.000)
call CreateUnit(mT,1747989297,-6464.0,1280.0,270.000)
call CreateUnit(mT,1747989297,-8064.0,3200.0,270.000)
call CreateUnit(mT,1747989297,-8768.0,1984.0,270.000)
call CreateUnit(mT,1747989297,-7104.0,-768.0,270.000)
call CreateUnit(mT,1747989297,-28544.0,0.0,270.000)
call CreateUnit(mT,1747989297,-27840.0,-2752.0,270.000)
call CreateUnit(mT,1747989297,-27008.0,2688.0,270.000)
call CreateUnit(mT,1747989297,-17024.0,512.0,270.000)
call CreateUnit(mT,1747989297,-21696.0,-4224.0,270.000)
call CreateUnit(mT,1747989042,17536.0,-9024.0,270.000)
call CreateUnit(mT,1747989297,10816.0,-7360.0,270.000)
call CreateUnit(mT,1747989297,12800.0,-6912.0,270.000)
call CreateUnit(mT,1747989297,15488.0,-7552.0,270.000)
call CreateUnit(mT,1747989297,19072.0,-7424.0,270.000)
call CreateUnit(mT,1747989297,15360.0,-5568.0,270.000)
call CreateUnit(mT,1747989297,17216.0,-8640.0,270.000)
call CreateUnit(mT,1747989297,16960.0,-16192.0,270.000)
call CreateUnit(mT,1747989297,6976.0,-6592.0,270.000)
call CreateUnit(mT,1747989297,24000.0,256.0,270.000)
call CreateUnit(mT,1747989297,-10688.0,-384.0,270.000)
call CreateUnit(mT,1747989297,13952.0,-11008.0,270.000)
call CreateUnit(mT,1747989297,-10944.0,-4608.0,270.000)
call CreateUnit(mT,1747989297,-21440.0,-8384.0,270.000)
call CreateUnit(mT,1747989297,17472.0,9472.0,270.000)
call CreateUnit(mT,1747989297,-16768.0,-8064.0,270.000)
call CreateUnit(mT,1747989297,-9920.0,-11264.0,270.000)
call CreateUnit(mT,1747989297,-7488.0,-16256.0,270.000)
call CreateUnit(mT,1747989297,448.0,-17600.0,270.000)
call CreateUnit(mT,1747989297,11008.0,-18496.0,270.000)
call CreateUnit(mT,1747989297,13248.0,-17856.0,270.000)
call CreateUnit(mT,1747989297,12288.0,-20864.0,270.000)
call CreateUnit(mT,1747989297,-11456.0,11008.0,270.000)
call CreateUnit(mT,1747989297,-8640.0,7104.0,270.000)
call CreateUnit(mT,1747989297,-7360.0,17088.0,270.000)
call CreateUnit(mT,1747989297,-5120.0,14528.0,270.000)
call CreateUnit(mT,1747989297,15488.0,-26816.0,270.000)
call CreateUnit(mT,1747989297,-9600.0,13120.0,270.000)
call CreateUnit(mT,1747989297,-11456.0,14528.0,270.000)
call CreateUnit(mT,1747989297,-12544.0,16320.0,270.000)
call CreateUnit(mT,1747989297,-7680.0,22272.0,270.000)
call CreateUnit(mT,1747989297,-6272.0,21376.0,270.000)
call CreateUnit(mT,1747989297,-4992.0,21888.0,270.000)
call CreateUnit(mT,1747989297,-1280.0,23936.0,270.000)
call CreateUnit(mT,1747989297,-3328.0,23232.0,270.000)
call CreateUnit(mT,1747989297,-2560.0,26368.0,270.000)
call CreateUnit(mT,1747989297,-6528.0,28288.0,270.000)
call CreateUnit(mT,1747989297,-9856.0,28416.0,270.000)
call CreateUnit(mT,1747989297,-13376.0,15104.0,270.000)
call CreateUnit(mT,1747989297,-10688.0,3520.0,270.000)
call CreateUnit(mT,1747989297,-9856.0,5440.0,270.000)
call CreateUnit(mT,1747989297,-6720.0,4096.0,270.000)
call CreateUnit(mT,1747989297,-13632.0,2368.0,270.000)
call CreateUnit(mT,1747989297,-10496.0,17728.0,270.000)
call CreateUnit(mT,1747989297,-7616.0,11200.0,270.000)
call CreateUnit(mT,1747989297,-18688.0,5760.0,270.000)
call CreateUnit(mT,1747989297,-25024.0,-3008.0,270.000)
call CreateUnit(mT,1747989297,-20096.0,1408.0,270.000)
call CreateUnit(mT,1747989297,-7040.0,-7808.0,270.000)
call CreateUnit(mT,1747989297,-5376.0,-9216.0,270.000)
call CreateUnit(mT,1747989297,24896.0,-27456.0,270.000)
call CreateUnit(mT,1747989297,-20352.0,12224.0,270.000)
call CreateUnit(mT,1747989297,-13568.0,5184.0,270.000)
call CreateUnit(mT,1747989297,-5120.0,24576.0,270.000)
call CreateUnit(mT,1747989297,-1856.0,27776.0,270.000)
call CreateUnit(mT,1747989297,-16704.0,24192.0,270.000)
call CreateUnit(mT,1747989297,-15936.0,17088.0,270.000)
call CreateUnit(mT,1747989297,-17792.0,16064.0,270.000)
call CreateUnit(mT,1747989297,-20224.0,21632.0,270.000)
call CreateUnit(mT,1747989297,-22400.0,19968.0,270.000)
call CreateUnit(mT,1747989297,-15872.0,20544.0,270.000)
call CreateUnit(mT,1747989297,-19776.0,16512.0,270.000)
call CreateUnit(mT,1747989297,-17088.0,12672.0,270.000)
call CreateUnit(mT,1747989297,-18560.0,19712.0,270.000)
call CreateUnit(mT,1747989297,-15680.0,26112.0,270.000)
call CreateUnit(mT,1747989297,-17088.0,26816.0,270.000)
call CreateUnit(mT,1747989297,-16704.0,3584.0,270.000)
call CreateUnit(mT,1747989297,-11456.0,7232.0,270.000)
call CreateUnit(mT,1747989297,-18176.0,10816.0,270.000)
call CreateUnit(mT,1747989297,-16000.0,6016.0,270.000)
call CreateUnit(mT,1747989297,-8896.0,26688.0,270.000)
call CreateUnit(mT,1747989297,9216.0,-4416.0,270.000)
call CreateUnit(mT,1747989297,6656.0,-4480.0,270.000)
call CreateUnit(mT,1747989297,5184.0,-1856.0,270.000)
call CreateUnit(mT,1747989297,18624.0,-448.0,270.000)
call CreateUnit(mT,1747989297,11008.0,-1984.0,270.000)
call CreateUnit(mT,1747989297,14144.0,-128.0,270.000)
call CreateUnit(mT,1747989297,8384.0,-10368.0,270.000)
call CreateUnit(mT,1747989297,5376.0,-12224.0,270.000)
call CreateUnit(mT,1747989297,3392.0,-7296.0,270.000)
call CreateUnit(mT,1747989297,12672.0,-3904.0,270.000)
call CreateUnit(mT,1747989297,27008.0,-11520.0,270.000)
call CreateUnit(mT,1747989297,-25216.0,1472.0,270.000)
call CreateUnit(mT,1747989297,23552.0,11072.0,270.000)
call CreateUnit(mT,1747989297,-20736.0,-2112.0,270.000)
call CreateUnit(mT,1747989297,-22592.0,2560.0,270.000)
call CreateUnit(mT,1747989297,-20864.0,3136.0,270.000)
call CreateUnit(mT,1747989297,-17280.0,-3136.0,270.000)
call CreateUnit(mT,1747989297,-3584.0,4608.0,270.000)
call CreateUnit(mT,1747989297,1536.0,29440.0,270.000)
call CreateUnit(mT,1747989297,-23104.0,-8832.0,270.000)
call CreateUnit(mT,1747989297,1216.0,-960.0,270.000)
call CreateUnit(mT,1747989297,-13312.0,-8512.0,270.000)
call CreateUnit(mT,1747989297,26240.0,-2688.0,270.000)
call CreateUnit(mT,1747989043,-7872.0,17536.0,270.000)
call CreateUnit(mT,1747989297,-13568.0,12160.0,270.000)
call CreateUnit(mT,1747989297,-13696.0,8064.0,270.000)
call CreateUnit(mT,1747989297,27648.0,-5824.0,270.000)
call CreateUnit(mT,1747989297,-4544.0,11648.0,270.000)
call CreateUnit(mT,1747989297,28992.0,-3200.0,270.000)
call CreateUnit(mT,1747989297,-3072.0,8320.0,270.000)
call CreateUnit(mT,1747989297,-384.0,8512.0,270.000)
call CreateUnit(mT,1747989297,28224.0,2752.0,270.000)
call CreateUnit(mT,1747989297,-4992.0,17280.0,270.000)
call CreateUnit(mT,1747989297,64.0,12608.0,270.000)
call CreateUnit(mT,1747989297,-2112.0,13696.0,270.000)
call CreateUnit(mT,1747989297,4160.0,5376.0,270.000)
call CreateUnit(mT,1747989297,4224.0,3904.0,270.000)
call CreateUnit(mT,1747989297,7232.0,2240.0,270.000)
call CreateUnit(mT,1747989297,-384.0,3072.0,270.000)
call CreateUnit(mT,1747989297,-8128.0,19968.0,270.000)
call CreateUnit(mT,1747989297,3072.0,192.0,270.000)
call CreateUnit(mT,1747989297,832.0,15872.0,270.000)
call CreateUnit(mT,1747989297,-2304.0,16064.0,270.000)
call CreateUnit(mT,1747989297,4416.0,19648.0,270.000)
call CreateUnit(mT,1747989297,1792.0,6976.0,270.000)
call CreateUnit(mT,1747989297,5888.0,24960.0,270.000)
call CreateUnit(mT,1747989297,-1792.0,19200.0,270.000)
call CreateUnit(mT,1747989297,3008.0,22784.0,270.000)
call CreateUnit(mT,1747989297,3200.0,18240.0,270.000)
call CreateUnit(mT,1747989297,-3712.0,-6528.0,270.000)
call CreateUnit(mT,1747989297,-17216.0,22208.0,270.000)
call CreateUnit(mT,1747989297,-18880.0,17920.0,270.000)
call CreateUnit(mT,1747989297,-17280.0,18304.0,270.000)
call CreateUnit(mT,1747989297,-22272.0,22400.0,270.000)
call CreateUnit(mT,1747989297,-10496.0,-9152.0,270.000)
call CreateUnit(mT,1747989297,13248.0,5120.0,270.000)
call CreateUnit(mT,1747989297,7936.0,-2368.0,270.000)
call CreateUnit(mT,1747989297,3520.0,27008.0,270.000)
call CreateUnit(mT,1747989297,8832.0,26368.0,270.000)
call CreateUnit(mT,1747989297,6848.0,21440.0,270.000)
call CreateUnit(mT,1747989297,6144.0,18560.0,270.000)
call CreateUnit(mT,1747989297,3904.0,11072.0,270.000)
call CreateUnit(mT,1747989297,8512.0,12352.0,270.000)
call CreateUnit(mT,1747989297,9280.0,20032.0,270.000)
call CreateUnit(mT,1747989297,1216.0,11008.0,270.000)
call CreateUnit(mT,1747989044,-15680.0,11200.0,270.000)
call CreateUnit(mT,1747989044,-15104.0,17408.0,270.000)
call CreateUnit(mT,1747989045,-1728.0,28608.0,270.000)
call CreateUnit(mT,1747989043,-18304.0,18112.0,270.000)
call CreateUnit(mT,1747989044,-9600.0,13888.0,270.000)
call CreateUnit(mT,1747989297,384.0,19456.0,270.000)
call CreateUnit(mT,1747989044,4864.0,5952.0,270.000)
call CreateUnit(mT,1747989044,8000.0,-1664.0,270.000)
call CreateUnit(mT,1747989044,9280.0,-3008.0,270.000)
call CreateUnit(mT,1747989045,-21056.0,21056.0,270.000)
call CreateUnit(mT,1747989045,-19648.0,12224.0,270.000)
call CreateUnit(mT,1747989045,17984.0,-13120.0,270.000)
call CreateUnit(mT,1747989042,-28544.0,704.0,270.000)
call CreateUnit(mT,1747989045,-9344.0,7168.0,270.000)
call CreateUnit(mT,1747989043,-6336.0,8576.0,270.000)
call CreateUnit(mT,1747989045,-15616.0,21248.0,270.000)
call CreateUnit(mT,1747989045,-16640.0,1024.0,270.000)
call CreateUnit(mT,1747989045,13760.0,-11584.0,270.000)
call CreateUnit(mT,1747989042,-11328.0,3712.0,270.000)
call CreateUnit(mT,1747989042,-16768.0,25920.0,270.000)
call CreateUnit(mT,1747989045,-19200.0,28352.0,270.000)
call CreateUnit(mT,1747989043,3456.0,11584.0,270.000)
call CreateUnit(mT,1747989044,-24640.0,4352.0,270.000)
call CreateUnit(mT,1747989044,-23232.0,-5120.0,270.000)
call CreateUnit(mT,1747989042,-23424.0,768.0,270.000)
call CreateUnit(mT,1747989045,-15936.0,-2688.0,270.000)
call CreateUnit(mT,1747989045,-10752.0,-3456.0,270.000)
call CreateUnit(mT,1747989044,-7552.0,4416.0,270.000)
call CreateUnit(mT,1747989045,-20160.0,-1600.0,270.000)
call CreateUnit(mT,1747989045,-21824.0,2560.0,270.000)
call CreateUnit(mT,1747989045,11392.0,-7104.0,270.000)
call CreateUnit(mT,1747989042,4352.0,20224.0,270.000)
call CreateUnit(mT,1747989044,-15360.0,4992.0,270.000)
call CreateUnit(mT,1747989042,-896.0,3392.0,270.000)
call CreateUnit(mT,1747989045,-6528.0,-832.0,270.000)
call CreateUnit(mT,1747989043,-4928.0,-3264.0,270.000)
call CreateUnit(mT,1747989042,-6144.0,-8192.0,270.000)
call CreateUnit(mT,1747989043,23424.0,640.0,270.000)
call CreateUnit(mT,1747989043,-6976.0,1344.0,270.000)
call CreateUnit(mT,1747989043,4352.0,128.0,270.000)
call CreateUnit(mT,1747989297,17472.0,19648.0,270.000)
call CreateUnit(mT,1747989044,-7872.0,22784.0,270.000)
call CreateUnit(mT,1747989297,20864.0,21504.0,270.000)
call CreateUnit(mT,1747989044,-9152.0,28480.0,270.000)
call CreateUnit(mT,1747989042,-27712.0,-9536.0,270.000)
call CreateUnit(mT,1747989042,4800.0,-12480.0,270.000)
call CreateUnit(mT,1747989045,7232.0,-11328.0,270.000)
call CreateUnit(mT,1747989045,1792.0,-8064.0,270.000)
call CreateUnit(mT,1747989297,-1600.0,5952.0,270.000)
call CreateUnit(mT,1747989043,-128.0,-1792.0,270.000)
call CreateUnit(mT,1747989042,-3392.0,8640.0,270.000)
call CreateUnit(mT,1747989044,-1856.0,16576.0,270.000)
call CreateUnit(mT,1747989043,-13888.0,14784.0,270.000)
call CreateUnit(mT,1747989297,-29568.0,-9792.0,270.000)
call CreateUnit(mT,1747989043,-9088.0,26240.0,270.000)
call CreateUnit(mT,1747989045,-5440.0,23808.0,270.000)
call CreateUnit(mT,1747989045,2176.0,30080.0,270.000)
call CreateUnit(mT,1747989043,1984.0,6464.0,270.000)
call CreateUnit(mT,1747989297,-26304.0,-1408.0,270.000)
call CreateUnit(mT,1747989043,448.0,13056.0,270.000)
call CreateUnit(mT,1747989045,3072.0,26752.0,270.000)
call CreateUnit(mT,1747989043,6656.0,18880.0,270.000)
call CreateUnit(mT,1747989043,3264.0,-3712.0,270.000)
call CreateUnit(mT,1747989297,15872.0,5760.0,270.000)
call CreateUnit(mT,1747989043,6528.0,22080.0,270.000)
call CreateUnit(mT,1747989044,8896.0,27008.0,270.000)
call CreateUnit(mT,1747989297,18496.0,-17280.0,270.000)
call CreateUnit(mT,1747989297,11392.0,7872.0,270.000)
call CreateUnit(mT,1747989297,12672.0,11328.0,270.000)
call CreateUnit(mT,1747989297,6016.0,12416.0,270.000)
call CreateUnit(mT,1747989297,7104.0,7808.0,270.000)
call CreateUnit(mT,1747989297,20864.0,2688.0,270.000)
call CreateUnit(mT,1747989297,24000.0,2560.0,270.000)
call CreateUnit(mT,1747989297,19648.0,11328.0,270.000)
call CreateUnit(mT,1747989297,11584.0,16960.0,270.000)
call CreateUnit(mT,1747989297,18496.0,-13248.0,270.000)
call CreateUnit(mT,1747989297,17216.0,-11456.0,270.000)
call CreateUnit(mT,1747989297,25088.0,-8320.0,270.000)
call CreateUnit(mT,1747989297,15680.0,-17536.0,270.000)
call CreateUnit(mT,1747989297,16640.0,-14208.0,270.000)
call CreateUnit(mT,1747989297,17280.0,-19584.0,270.000)
call CreateUnit(mT,1747989297,22912.0,-10240.0,270.000)
call CreateUnit(mT,1747989297,20864.0,-23040.0,270.000)
call CreateUnit(mT,1747989044,13120.0,-21696.0,270.000)
call CreateUnit(mT,1747989297,20096.0,-5760.0,270.000)
call CreateUnit(mT,1747989297,18816.0,-3776.0,270.000)
call CreateUnit(mT,1747989042,14464.0,-26432.0,270.000)
call CreateUnit(mT,1747989044,23808.0,-27776.0,270.000)
call CreateUnit(mT,1747989042,11776.0,-18688.0,270.000)
call CreateUnit(mT,1747989043,256.0,-18048.0,270.000)
call CreateUnit(mT,1747989045,-16192.0,-8192.0,270.000)
call CreateUnit(mT,1747989045,-11520.0,-10944.0,270.000)
call CreateUnit(mT,1747989045,16512.0,-19968.0,270.000)
call CreateUnit(mT,1747989045,20416.0,-22272.0,270.000)
call CreateUnit(mT,1747989044,28800.0,-11904.0,270.000)
call CreateUnit(mT,1747989297,15040.0,23104.0,270.000)
call CreateUnit(mT,1747989044,8128.0,12928.0,270.000)
call CreateUnit(mT,1747989044,16896.0,-15744.0,270.000)
call CreateUnit(mT,1747989042,17984.0,-640.0,270.000)
call CreateUnit(mT,1747989045,20608.0,3136.0,270.000)
call CreateUnit(mT,1747989045,7232.0,-5120.0,270.000)
call CreateUnit(mT,1747989045,25984.0,-8128.0,270.000)
call CreateUnit(mT,1747989045,20544.0,-5440.0,270.000)
call CreateUnit(mT,1747989045,11968.0,17856.0,270.000)
call CreateUnit(mT,1747989045,10048.0,20032.0,270.000)
call CreateUnit(mT,1747989043,15296.0,-7232.0,270.000)
call CreateUnit(mT,1747989043,13056.0,11776.0,270.000)
call CreateUnit(mT,1747989043,15744.0,23488.0,270.000)
call CreateUnit(mT,1747989043,17984.0,9280.0,270.000)
set mT=null
endfunction
function AA takes nothing returns nothing
local trigger UA
local playerunitevent IA
local integer PA
set fi=CreateTrigger()
set UA=fi
set IA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set PA=0
loop
call TriggerRegisterPlayerUnitEvent(UA,Player(PA),IA,null)
set PA=PA+1
exitwhen PA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(fi,Condition(fa))
call TriggerAddAction(fi,Ra)
set UA=null
set IA=null
endfunction
function AD takes nothing returns nothing
local trigger UD
local playerunitevent ID
local integer PD
set Fi=CreateTrigger()
set UD=Fi
set ID=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set PD=0
loop
call TriggerRegisterPlayerUnitEvent(UD,Player(PD),ID,null)
set PD=PD+1
exitwhen PD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Fi,Condition(Za))
call TriggerAddAction(Fi,Ua)
set UD=null
set ID=null
endfunction
function AJ takes nothing returns nothing
local trigger UJ
local playerunitevent IJ
local integer PJ
set Ui=CreateTrigger()
set UJ=Ui
set IJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set PJ=0
loop
call TriggerRegisterPlayerUnitEvent(UJ,Player(PJ),IJ,null)
set PJ=PJ+1
exitwhen PJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ui,Condition(sn))
call TriggerAddAction(Ui,tn)
set UJ=null
set IJ=null
endfunction
function AT takes nothing returns nothing
set Rs=CreateTrigger()
call TriggerRegisterTimerEvent(Rs,70.00,false)
call TriggerAddAction(Rs,Gy)
endfunction
function AY takes nothing returns nothing
local trigger UY
local playerunitevent IY
local integer PY
set Fs=CreateTrigger()
set UY=Fs
set IY=EVENT_PLAYER_UNIT_ATTACKED
set PY=0
loop
call TriggerRegisterPlayerUnitEvent(UY,Player(PY),IY,null)
set PY=PY+1
exitwhen PY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Fs,Condition(my))
call TriggerAddAction(Fs,Qy)
set UY=null
set IY=null
endfunction
function Am takes nothing returns nothing
local trigger Um
local playerunitevent Im
local integer Pm
set lt=CreateTrigger()
set Um=lt
set Im=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Pm=0
loop
call TriggerRegisterPlayerUnitEvent(Um,Player(Pm),Im,null)
set Pm=Pm+1
exitwhen Pm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(lt,Condition(ue))
call TriggerAddAction(lt,re)
set Um=null
set Im=null
endfunction
function BH takes nothing returns nothing
local trigger XH
local playerunitevent CH
local integer VH
set mi=CreateTrigger()
set XH=mi
set CH=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set VH=0
loop
call TriggerRegisterPlayerUnitEvent(XH,Player(VH),CH,null)
set VH=VH+1
exitwhen VH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(mi,Condition(La))
call TriggerAddAction(mi,Xa)
set XH=null
set CH=null
endfunction
function BP takes nothing returns nothing
local trigger XP
local playerunitevent CP
local integer VP
set pi=CreateTrigger()
set XP=pi
set CP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set VP=0
loop
call TriggerRegisterPlayerUnitEvent(XP,Player(VP),CP,null)
set VP=VP+1
exitwhen VP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(pi,Condition(ca))
call TriggerAddAction(pi,oa)
set XP=null
set CP=null
endfunction
function BY takes nothing returns nothing
local trigger XY
local playerunitevent CY
local integer VY
set ks=CreateTrigger()
set XY=ks
set CY=EVENT_PLAYER_UNIT_SPELL_CAST
set VY=0
loop
call TriggerRegisterPlayerUnitEvent(XY,Player(VY),CY,null)
set VY=VY+1
exitwhen VY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ks,Condition(Wy))
call TriggerAddAction(ks,Ey)
set XY=null
set CY=null
endfunction
function BZ takes nothing returns nothing
local trigger XZ
local playerunitevent CZ
local integer VZ
set Ht=CreateTrigger()
set XZ=Ht
set CZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set VZ=0
loop
call TriggerRegisterPlayerUnitEvent(XZ,Player(VZ),CZ,null)
set VZ=VZ+1
exitwhen VZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ht,Condition(yq))
call TriggerAddAction(Ht,pq)
set XZ=null
set CZ=null
endfunction
function Bv takes nothing returns nothing
local trigger Xv
local playerunitevent Cv
local integer Vv
set st=CreateTrigger()
set Xv=st
set Cv=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Vv=0
loop
call TriggerRegisterPlayerUnitEvent(Xv,Player(Vv),Cv,null)
set Vv=Vv+1
exitwhen Vv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(st,Condition(Dp))
call TriggerAddAction(st,Hp)
set Xv=null
set Cv=null
endfunction
function CA takes nothing returns nothing
local trigger KA
local playerunitevent LA
local integer XA
set Ri=CreateTrigger()
set KA=Ri
set LA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set XA=0
loop
call TriggerRegisterPlayerUnitEvent(KA,Player(XA),LA,null)
set XA=XA+1
exitwhen XA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ri,Condition(Ta))
call TriggerAddAction(Ri,Ya)
set KA=null
set LA=null
endfunction
function CG takes nothing returns nothing
local trigger KG
local playerunitevent LG
local integer XG
set ms=CreateTrigger()
set KG=ms
set LG=EVENT_PLAYER_UNIT_SPELL_CAST
set XG=0
loop
call TriggerRegisterPlayerUnitEvent(KG,Player(XG),LG,null)
set XG=XG+1
exitwhen XG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ms,Condition(Dy))
call TriggerAddAction(ms,Hy)
set KG=null
set LG=null
endfunction
function CJ takes nothing returns nothing
local trigger KJ
local playerunitevent LJ
local integer XJ
set Ii=CreateTrigger()
set KJ=Ii
set LJ=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set XJ=0
loop
call TriggerRegisterPlayerUnitEvent(KJ,Player(XJ),LJ,null)
set XJ=XJ+1
exitwhen XJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ii,Condition(Sn))
call TriggerAddAction(Ii,cn)
set KJ=null
set LJ=null
endfunction
function Cg takes nothing returns nothing
local trigger Kg
local playerunitevent Lg
local integer Xg
set Es=CreateTrigger()
set Kg=Es
set Lg=EVENT_PLAYER_UNIT_SPELL_CAST
set Xg=0
loop
call TriggerRegisterPlayerUnitEvent(Kg,Player(Xg),Lg,null)
set Xg=Xg+1
exitwhen Xg==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Es,Condition(Ny))
call TriggerAddAction(Es,My)
set Kg=null
set Lg=null
endfunction
function Ch takes nothing returns nothing
local trigger Kh
local playerunitevent Lh
local integer Xh
set Is=CreateTrigger()
set Kh=Is
set Lh=EVENT_PLAYER_UNIT_SPELL_CAST
set Xh=0
loop
call TriggerRegisterPlayerUnitEvent(Kh,Player(Xh),Lh,null)
set Xh=Xh+1
exitwhen Xh==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Is,Condition(cp))
call TriggerAddAction(Is,op)
set Kh=null
set Lh=null
endfunction
function Cm takes nothing returns nothing
local trigger Km
local playerunitevent Lm
local integer Xm
set bt=CreateTrigger()
set Km=bt
set Lm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set Xm=0
loop
call TriggerRegisterPlayerUnitEvent(Km,Player(Xm),Lm,null)
set Xm=Xm+1
exitwhen Xm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(bt,Condition(se))
call TriggerAddAction(bt,te)
set Km=null
set Lm=null
endfunction
function DI takes nothing returns nothing
local trigger II
local playerunitevent PI
local integer AI
set ti=CreateTrigger()
set II=ti
set PI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set AI=0
loop
call TriggerRegisterPlayerUnitEvent(II,Player(AI),PI,null)
set AI=AI+1
exitwhen AI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ti,Condition(Dq))
call TriggerAddAction(ti,Hq)
set II=null
set PI=null
endfunction
function EH takes nothing returns nothing
local trigger mH
local playerunitevent QH
local integer WH
set vi=CreateTrigger()
set mH=vi
set QH=EVENT_PLAYER_UNIT_SPELL_CAST
set WH=0
loop
call TriggerRegisterPlayerUnitEvent(mH,Player(WH),QH,null)
set WH=WH+1
exitwhen WH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(vi,Condition(Ja))
call TriggerAddAction(vi,Ka)
set mH=null
set QH=null
endfunction
function EP takes nothing returns nothing
local trigger mP
local playerunitevent QP
local integer WP
set bi=CreateTrigger()
set mP=bi
set QP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set WP=0
loop
call TriggerRegisterPlayerUnitEvent(mP,Player(WP),QP,null)
set WP=WP+1
exitwhen WP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(bi,Condition(sa))
call TriggerAddAction(bi,ta)
set mP=null
set QP=null
endfunction
function EZ takes nothing returns nothing
local trigger mZ
local playerunitevent QZ
local integer WZ
set At=CreateTrigger()
set mZ=At
set QZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set WZ=0
loop
call TriggerRegisterPlayerUnitEvent(mZ,Player(WZ),QZ,null)
set WZ=WZ+1
exitwhen WZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(At,Condition(oq))
call TriggerAddAction(At,Oq)
set mZ=null
set QZ=null
endfunction
function Ek takes nothing returns nothing
local trigger mk
local playerunitevent Qk
local integer Wk
set Ks=CreateTrigger()
set mk=Ks
set Qk=EVENT_PLAYER_UNIT_SPELL_CAST
set Wk=0
loop
call TriggerRegisterPlayerUnitEvent(mk,Player(Wk),Qk,null)
set Wk=Wk+1
exitwhen Wk==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ks,Condition(Rp))
call TriggerAddAction(Ks,Tp)
set mk=null
set Qk=null
endfunction
function FD takes nothing returns nothing
set hi=CreateTrigger()
call TriggerRegisterTimerEvent(hi,0.10,false)
call TriggerAddAction(hi,Qa)
endfunction
function FI takes nothing returns nothing
local trigger GI
local playerunitevent gI
local integer hI
set ri=CreateTrigger()
set GI=ri
set gI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set hI=0
loop
call TriggerRegisterPlayerUnitEvent(GI,Player(hI),gI,null)
set hI=hI+1
exitwhen hI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ri,Condition(Uq))
call TriggerAddAction(ri,Iq)
set GI=null
set gI=null
endfunction
function GD takes nothing returns nothing
local trigger RD
local playerunitevent TD
local integer YD
set gi=CreateTrigger()
set RD=gi
set TD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set YD=0
loop
call TriggerRegisterPlayerUnitEvent(RD,Player(YD),TD,null)
set YD=YD+1
exitwhen YD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gi,Condition(xa))
call TriggerAddAction(gi,va)
set RD=null
set TD=null
endfunction
function GK takes nothing returns nothing
local trigger RK
local playerunitevent TK
local integer YK
set Hi=CreateTrigger()
set RK=Hi
set TK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set YK=0
loop
call TriggerRegisterPlayerUnitEvent(RK,Player(YK),TK,null)
set YK=YK+1
exitwhen YK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Hi,Condition(en))
call TriggerAddAction(Hi,qn)
set RK=null
set TK=null
endfunction
function GQ takes nothing returns nothing
local trigger RQ
local playerunitevent TQ
local integer YQ
set qt=CreateTrigger()
set RQ=qt
set TQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set YQ=0
loop
call TriggerRegisterPlayerUnitEvent(RQ,Player(YQ),TQ,null)
set YQ=YQ+1
exitwhen YQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(qt,Condition(be))
call TriggerAddAction(qt,ye)
set RQ=null
set TQ=null
endfunction
function HP takes nothing returns nothing
local trigger PP
local playerunitevent AP
local integer DP
set yi=CreateTrigger()
set PP=yi
set AP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set DP=0
loop
call TriggerRegisterPlayerUnitEvent(PP,Player(DP),AP,null)
set DP=DP+1
exitwhen DP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(yi,Condition(ia))
call TriggerAddAction(yi,Sa)
set PP=null
set AP=null
endfunction
function HZ takes nothing returns nothing
local trigger PZ
local playerunitevent AZ
local integer DZ
set Dt=CreateTrigger()
set PZ=Dt
set AZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set DZ=0
loop
call TriggerRegisterPlayerUnitEvent(PZ,Player(DZ),AZ,null)
set DZ=DZ+1
exitwhen DZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Dt,Condition(lq))
call TriggerAddAction(Dt,bq)
set PZ=null
set AZ=null
endfunction
function Hv takes nothing returns nothing
local trigger Pv
local playerunitevent Av
local integer Dv
set rt=CreateTrigger()
set Pv=rt
set Av=EVENT_PLAYER_UNIT_DEATH
set Dv=0
loop
call TriggerRegisterPlayerUnitEvent(Pv,Player(Dv),Av,null)
set Dv=Dv+1
exitwhen Dv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(rt,Condition(Pp))
call TriggerAddAction(rt,Ap)
set Pv=null
set Av=null
endfunction
function IK takes nothing returns nothing
local trigger EK
local playerunitevent ZK
local integer UK
set Ki=CreateTrigger()
set EK=Ki
set ZK=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set UK=0
loop
call TriggerRegisterPlayerUnitEvent(EK,Player(UK),ZK,null)
set UK=UK+1
exitwhen UK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ki,Condition(dn))
call TriggerAddAction(Ki,fn)
set EK=null
set ZK=null
endfunction
function IQ takes nothing returns nothing
local trigger EQ
local playerunitevent ZQ
local integer UQ
set nt=CreateTrigger()
set EQ=nt
set ZQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set UQ=0
loop
call TriggerRegisterPlayerUnitEvent(EQ,Player(UQ),ZQ,null)
set UQ=UQ+1
exitwhen UQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(nt,Condition(qe))
call TriggerAddAction(nt,ae)
set EQ=null
set ZQ=null
endfunction
function JL takes nothing returns nothing
local trigger AL
local playerunitevent DL
local integer HL
set wS=CreateTrigger()
set AL=wS
set DL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set HL=0
loop
call TriggerRegisterPlayerUnitEvent(AL,Player(HL),DL,null)
set HL=HL+1
exitwhen HL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(wS,Condition(En))
call TriggerAddAction(wS,Zn)
set AL=null
set DL=null
endfunction
function JT takes nothing returns nothing
set Ys=CreateTrigger()
call TriggerRegisterTimerEvent(Ys,1.00,false)
call TriggerAddAction(Ys,gy)
endfunction
function JU takes nothing returns nothing
local trigger AU
local playerunitevent DU
local integer HU
set Bt=CreateTrigger()
set AU=Bt
set DU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set HU=0
loop
call TriggerRegisterPlayerUnitEvent(AU,Player(HU),DU,null)
set HU=HU+1
exitwhen HU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Bt,Condition(Fq))
call TriggerAddAction(Bt,kq)
set AU=null
set DU=null
endfunction
function JW takes nothing returns nothing
local trigger AW
local playerunitevent DW
local integer HW
set ht=CreateTrigger()
set AW=ht
set DW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set HW=0
loop
call TriggerRegisterPlayerUnitEvent(AW,Player(HW),DW,null)
set HW=HW+1
exitwhen HW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ht,Condition(me))
call TriggerAddAction(ht,Qe)
set AW=null
set DW=null
endfunction
function KE takes nothing returns nothing
local trigger DE
local playerunitevent HE
local integer JE
set Wt=CreateTrigger()
set DE=Wt
set HE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set JE=0
loop
call TriggerRegisterPlayerUnitEvent(DE,Player(JE),HE,null)
set JE=JE+1
exitwhen JE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Wt,Condition(Ve))
call TriggerAddAction(Wt,Be)
set DE=null
set HE=null
endfunction
function LD takes nothing returns nothing
local trigger HD
local playerunitevent JD
local integer KD
set ki=CreateTrigger()
set HD=ki
set JD=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set KD=0
loop
call TriggerRegisterPlayerUnitEvent(HD,Player(KD),JD,null)
set KD=KD+1
exitwhen KD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(ki,Ia)
set HD=null
set JD=null
endfunction
function LK takes nothing returns nothing
local trigger HK
local playerunitevent JK
local integer KK
set Li=CreateTrigger()
set HK=Li
set JK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set KK=0
loop
call TriggerRegisterPlayerUnitEvent(HK,Player(KK),JK,null)
set KK=KK+1
exitwhen KK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Li,Condition(Rn))
call TriggerAddAction(Li,Tn)
set HK=null
set JK=null
endfunction
function LQ takes nothing returns nothing
local trigger HQ
local playerunitevent JQ
local integer KQ
set dt=CreateTrigger()
set HQ=dt
set JQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set KQ=0
loop
call TriggerRegisterPlayerUnitEvent(HQ,Player(KQ),JQ,null)
set KQ=KQ+1
exitwhen KQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(dt,Condition(ne))
call TriggerAddAction(dt,de)
set HQ=null
set JQ=null
endfunction
function ME takes nothing returns nothing
local trigger VE
local playerunitevent BE
local integer NE
set Et=CreateTrigger()
set VE=Et
set BE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set NE=0
loop
call TriggerRegisterPlayerUnitEvent(VE,Player(NE),BE,null)
set NE=NE+1
exitwhen NE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Et,Condition(Ne))
call TriggerAddAction(Et,Me)
set VE=null
set BE=null
endfunction
function MI takes nothing returns nothing
set Si=CreateTrigger()
call TriggerRegisterTimerEvent(Si,0.10,false)
call TriggerAddAction(Si,Xq)
endfunction
function NL takes nothing returns nothing
local trigger CL
local playerunitevent VL
local integer BL
set uS=CreateTrigger()
set CL=uS
set VL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set BL=0
loop
call TriggerRegisterPlayerUnitEvent(CL,Player(BL),VL,null)
set BL=BL+1
exitwhen BL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(uS,Condition(Un))
call TriggerAddAction(uS,In)
set CL=null
set VL=null
endfunction
function NU takes nothing returns nothing
local trigger CU
local playerunitevent VU
local integer BU
set Nt=CreateTrigger()
set CU=Nt
set VU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set BU=0
loop
call TriggerRegisterPlayerUnitEvent(CU,Player(BU),VU,null)
set BU=BU+1
exitwhen BU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Nt,Condition(jq))
call TriggerAddAction(Nt,xq)
set CU=null
set VU=null
endfunction
function OD takes nothing returns nothing
local trigger SD
local playerunitevent cD
local integer oD
set Yi=CreateTrigger()
set SD=Yi
set cD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set oD=0
loop
call TriggerRegisterPlayerUnitEvent(SD,Player(oD),cD,null)
set oD=oD+1
exitwhen oD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Yi,Condition(ha))
call TriggerAddAction(Yi,Fa)
set SD=null
set cD=null
endfunction
function OK takes nothing returns nothing
local trigger SK
local playerunitevent cK
local integer oK
set Ai=CreateTrigger()
set SK=Ai
set cK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set oK=0
loop
call TriggerRegisterPlayerUnitEvent(SK,Player(oK),cK,null)
set oK=oK+1
exitwhen oK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ai,Condition(ln))
call TriggerAddAction(Ai,bn)
set SK=null
set cK=null
endfunction
function OQ takes nothing returns nothing
local trigger SQ
local playerunitevent cQ
local integer oQ
set pt=CreateTrigger()
set SQ=pt
set cQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set oQ=0
loop
call TriggerRegisterPlayerUnitEvent(SQ,Player(oQ),cQ,null)
set oQ=oQ+1
exitwhen oQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(pt,Condition(ce))
call TriggerAddAction(pt,oe)
set SQ=null
set cQ=null
endfunction
function Px takes nothing returns nothing
local trigger Zx
local playerunitevent Ux
local integer Ix
set Ns=CreateTrigger()
set Zx=Ns
set Ux=EVENT_PLAYER_UNIT_SPELL_CAST
set Ix=0
loop
call TriggerRegisterPlayerUnitEvent(Zx,Player(Ix),Ux,null)
set Ix=Ix+1
exitwhen Ix==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ns,Condition(Qp))
call TriggerAddAction(Ns,Wp)
set Zx=null
set Ux=null
endfunction
function QA takes nothing returns nothing
local trigger xA
local playerunitevent vA
local integer mA
set di=CreateTrigger()
set xA=di
set vA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set mA=0
loop
call TriggerRegisterPlayerUnitEvent(xA,Player(mA),vA,null)
set mA=mA+1
exitwhen mA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(di,Condition(na))
call TriggerAddAction(di,da)
set xA=null
set vA=null
endfunction
function QJ takes nothing returns nothing
local trigger xJ
local playerunitevent vJ
local integer mJ
set Zi=CreateTrigger()
set xJ=Zi
set vJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set mJ=0
loop
call TriggerRegisterPlayerUnitEvent(xJ,Player(mJ),vJ,null)
set mJ=mJ+1
exitwhen mJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Zi,Condition(un))
call TriggerAddAction(Zi,rn)
set xJ=null
set vJ=null
endfunction
function Qm takes nothing returns nothing
local trigger xm
local playerunitevent vm
local integer mm
set Ot=CreateTrigger()
set xm=Ot
set vm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set mm=0
loop
call TriggerRegisterPlayerUnitEvent(xm,Player(mm),vm,null)
set mm=mm+1
exitwhen mm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ot,Condition(Mp))
call TriggerAddAction(Ot,we)
set xm=null
set vm=null
endfunction
function RF takes nothing returns nothing
set As=CreateTrigger()
call TriggerRegisterTimerEvent(As,5.00,true)
call TriggerAddAction(As,pp)
endfunction
function RP takes nothing returns nothing
local trigger nP
local playerunitevent dP
local integer fP
set Oi=CreateTrigger()
set nP=Oi
set dP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set fP=0
loop
call TriggerRegisterPlayerUnitEvent(nP,Player(fP),dP,null)
set fP=fP+1
exitwhen fP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Oi,Condition(Mq))
call TriggerAddAction(Oi,wa)
set nP=null
set dP=null
endfunction
function RZ takes nothing returns nothing
local trigger nZ
local playerunitevent dZ
local integer fZ
set It=CreateTrigger()
set nZ=It
set dZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set fZ=0
loop
call TriggerRegisterPlayerUnitEvent(nZ,Player(fZ),dZ,null)
set fZ=fZ+1
exitwhen fZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(It,Condition(tq))
call TriggerAddAction(It,iq)
set nZ=null
set dZ=null
endfunction
function SP takes nothing returns nothing
local trigger sP
local playerunitevent tP
local integer iP
set ci=CreateTrigger()
set sP=ci
set tP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set iP=0
loop
call TriggerRegisterPlayerUnitEvent(sP,Player(iP),tP,null)
set iP=iP+1
exitwhen iP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ci,Condition(Cq))
call TriggerAddAction(ci,Vq)
set sP=null
set tP=null
endfunction
function SZ takes nothing returns nothing
local trigger sZ
local playerunitevent tZ
local integer iZ
set Zt=CreateTrigger()
set sZ=Zt
set tZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set iZ=0
loop
call TriggerRegisterPlayerUnitEvent(sZ,Player(iZ),tZ,null)
set iZ=iZ+1
exitwhen iZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Zt,Condition(wq))
call TriggerAddAction(Zt,uq)
set sZ=null
set tZ=null
endfunction
function Sv takes nothing returns nothing
local trigger sv
local playerunitevent tv
local integer iv
set Ms=CreateTrigger()
set sv=Ms
set tv=EVENT_PLAYER_UNIT_SPELL_CAST
set iv=0
loop
call TriggerRegisterPlayerUnitEvent(sv,Player(iv),tv,null)
set iv=iv+1
exitwhen iv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ms,Condition(Ep))
call TriggerAddAction(Ms,Zp)
set sv=null
set tv=null
endfunction
function TH takes nothing returns nothing
local trigger dH
local playerunitevent fH
local integer RH
set xi=CreateTrigger()
set dH=xi
set fH=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set RH=0
loop
call TriggerRegisterPlayerUnitEvent(dH,Player(RH),fH,null)
set RH=RH+1
exitwhen RH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(xi,Condition(Da))
call TriggerAddAction(xi,Ha)
set dH=null
set fH=null
endfunction
function TL takes nothing returns nothing
local trigger dL
local playerunitevent fL
local integer RL
set Bi=CreateTrigger()
set dL=Bi
set fL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set RL=0
loop
call TriggerRegisterPlayerUnitEvent(dL,Player(RL),fL,null)
set RL=RL+1
exitwhen RL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Bi,Condition(jn))
call TriggerAddAction(Bi,xn)
set dL=null
set fL=null
endfunction
function TU takes nothing returns nothing
local trigger dU
local playerunitevent fU
local integer RU
set Xt=CreateTrigger()
set dU=Xt
set fU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set RU=0
loop
call TriggerRegisterPlayerUnitEvent(dU,Player(RU),fU,null)
set RU=RU+1
exitwhen RU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Xt,Condition(Rq))
call TriggerAddAction(Xt,Tq)
set dU=null
set fU=null
endfunction
function TW takes nothing returns nothing
local trigger dW
local playerunitevent fW
local integer RW
set Yt=CreateTrigger()
set dW=Yt
set fW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set RW=0
loop
call TriggerRegisterPlayerUnitEvent(dW,Player(RW),fW,null)
set RW=RW+1
exitwhen RW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Yt,Condition(he))
call TriggerAddAction(Yt,Fe)
set dW=null
set fW=null
endfunction
function UE takes nothing returns nothing
local trigger WE
local playerunitevent EE
local integer ZE
set Qt=CreateTrigger()
set WE=Qt
set EE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set ZE=0
loop
call TriggerRegisterPlayerUnitEvent(WE,Player(ZE),EE,null)
set ZE=ZE+1
exitwhen ZE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Qt,Condition(Xe))
call TriggerAddAction(Qt,Ce)
set WE=null
set EE=null
endfunction
function Uj takes nothing returns nothing
local trigger Wj
local playerunitevent Ej
local integer Zj
set Cs=CreateTrigger()
set Wj=Cs
set Ej=EVENT_PLAYER_UNIT_DEATH
set Zj=0
loop
call TriggerRegisterPlayerUnitEvent(Wj,Player(Zj),Ej,null)
set Zj=Zj+1
exitwhen Zj==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Cs,Condition(Fp))
call TriggerAddAction(Cs,kp)
set Wj=null
set Ej=null
endfunction
function VF takes nothing returns nothing
local trigger LF
local playerunitevent XF
local integer CF
set Hs=CreateTrigger()
set LF=Hs
set XF=EVENT_PLAYER_UNIT_SPELL_CAST
set CF=0
loop
call TriggerRegisterPlayerUnitEvent(LF,Player(CF),XF,null)
set CF=CF+1
exitwhen CF==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Hs,Condition(ap))
call TriggerAddAction(Hs,np)
set LF=null
set XF=null
endfunction
function VI takes nothing returns nothing
local trigger LI
local playerunitevent XI
local integer CI
set ii=CreateTrigger()
set LI=ii
set XI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set CI=0
loop
call TriggerRegisterPlayerUnitEvent(LI,Player(CI),XI,null)
set CI=CI+1
exitwhen CI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ii,Condition(Jq))
call TriggerAddAction(ii,Kq)
set LI=null
set XI=null
endfunction
function WI takes nothing returns nothing
local trigger vI
local playerunitevent mI
local integer QI
set si=CreateTrigger()
set vI=si
set mI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set QI=0
loop
call TriggerRegisterPlayerUnitEvent(vI,Player(QI),mI,null)
set QI=QI+1
exitwhen QI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(si,Condition(Pq))
call TriggerAddAction(si,Aq)
set vI=null
set mI=null
endfunction
function XW takes nothing returns nothing
set Ft=CreateTrigger()
call TriggerRegisterTimerEvent(Ft,0.10,false)
call TriggerAddAction(Ft,Ee)
endfunction
function YE takes nothing returns nothing
local trigger fE
local playerunitevent RE
local integer TE
set vt=CreateTrigger()
set fE=vt
set RE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set TE=0
loop
call TriggerRegisterPlayerUnitEvent(fE,Player(TE),RE,null)
set TE=TE+1
exitwhen TE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(vt,Condition(He))
call TriggerAddAction(vt,Je)
set fE=null
set RE=null
endfunction
function ZL takes nothing returns nothing
local trigger QL
local playerunitevent WL
local integer EL
set Mi=CreateTrigger()
set QL=Mi
set WL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set EL=0
loop
call TriggerRegisterPlayerUnitEvent(QL,Player(EL),WL,null)
set EL=EL+1
exitwhen EL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Mi,Condition(Qn))
call TriggerAddAction(Mi,Wn)
set QL=null
set WL=null
endfunction
function ZU takes nothing returns nothing
local trigger QU
local playerunitevent WU
local integer EU
set Vt=CreateTrigger()
set QU=Vt
set WU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set EU=0
loop
call TriggerRegisterPlayerUnitEvent(QU,Player(EU),WU,null)
set EU=EU+1
exitwhen EU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Vt,Condition(gq))
call TriggerAddAction(Vt,hq)
set QU=null
set WU=null
endfunction
function ZW takes nothing returns nothing
local trigger QW
local playerunitevent WW
local integer EW
set gt=CreateTrigger()
set QW=gt
set WW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set EW=0
loop
call TriggerRegisterPlayerUnitEvent(QW,Player(EW),WW,null)
set EW=EW+1
exitwhen EW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gt,Condition(xe))
call TriggerAddAction(gt,ve)
set QW=null
set WW=null
endfunction
function aD takes nothing returns nothing
local trigger pD
local playerunitevent eD
local integer qD
set Gi=CreateTrigger()
set pD=Gi
set eD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set qD=0
loop
call TriggerRegisterPlayerUnitEvent(pD,Player(qD),eD,null)
set qD=qD+1
exitwhen qD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Gi,Condition(ka))
call TriggerAddAction(Gi,ja)
set pD=null
set eD=null
endfunction
function aG takes nothing returns nothing
local trigger pG
local playerunitevent eG
local integer qG
set xs=CreateTrigger()
set pG=xs
set eG=EVENT_PLAYER_UNIT_SPELL_CAST
set qG=0
loop
call TriggerRegisterPlayerUnitEvent(pG,Player(qG),eG,null)
set qG=qG+1
exitwhen qG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(xs,Iy)
set pG=null
set eG=null
endfunction
function aK takes nothing returns nothing
local trigger pK
local playerunitevent eK
local integer qK
set Di=CreateTrigger()
set pK=Di
set eK=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set qK=0
loop
call TriggerRegisterPlayerUnitEvent(pK,Player(qK),eK,null)
set qK=qK+1
exitwhen qK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Di,Condition(yn))
call TriggerAddAction(Di,pn)
set pK=null
set eK=null
endfunction
function aQ takes nothing returns nothing
local trigger pQ
local playerunitevent eQ
local integer qQ
set et=CreateTrigger()
set pQ=et
set eQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set qQ=0
loop
call TriggerRegisterPlayerUnitEvent(pQ,Player(qQ),eQ,null)
set qQ=qQ+1
exitwhen qQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(et,Condition(Oe))
call TriggerAddAction(et,le)
set pQ=null
set eQ=null
endfunction
function bA takes nothing returns nothing
local trigger oA
local playerunitevent OA
local integer lA
set qi=CreateTrigger()
set oA=qi
set OA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set lA=0
loop
call TriggerRegisterPlayerUnitEvent(oA,Player(lA),OA,null)
set lA=lA+1
exitwhen lA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(qi,Condition(ba))
call TriggerAddAction(qi,ya)
set oA=null
set OA=null
endfunction
function bJ takes nothing returns nothing
local trigger oJ
local playerunitevent OJ
local integer lJ
set Qi=CreateTrigger()
set oJ=Qi
set OJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set lJ=0
loop
call TriggerRegisterPlayerUnitEvent(oJ,Player(lJ),OJ,null)
set lJ=lJ+1
exitwhen lJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Qi,Condition(Ca))
call TriggerAddAction(Qi,Va)
set oJ=null
set OJ=null
endfunction
function bm takes nothing returns nothing
local trigger om
local playerunitevent Om
local integer lm
set St=CreateTrigger()
set om=St
set Om=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set lm=0
loop
call TriggerRegisterPlayerUnitEvent(om,Player(lm),Om,null)
set lm=lm+1
exitwhen lm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(St,Condition(Lp))
call TriggerAddAction(St,Xp)
set om=null
set Om=null
endfunction
function cH takes nothing returns nothing
local trigger tH
local playerunitevent iH
local integer SH
set ji=CreateTrigger()
set tH=ji
set iH=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set SH=0
loop
call TriggerRegisterPlayerUnitEvent(tH,Player(SH),iH,null)
set SH=SH+1
exitwhen SH==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ji,Condition(Pa))
call TriggerAddAction(ji,Aa)
set tH=null
set iH=null
endfunction
function cL takes nothing returns nothing
local trigger tL
local playerunitevent iL
local integer SL
set Ci=CreateTrigger()
set tL=Ci
set iL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set SL=0
loop
call TriggerRegisterPlayerUnitEvent(tL,Player(SL),iL,null)
set SL=SL+1
exitwhen SL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ci,Condition(gn))
call TriggerAddAction(Ci,hn)
set tL=null
set iL=null
endfunction
function cU takes nothing returns nothing
local trigger tU
local playerunitevent iU
local integer SU
set Kt=CreateTrigger()
set tU=Kt
set iU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set SU=0
loop
call TriggerRegisterPlayerUnitEvent(tU,Player(SU),iU,null)
set SU=SU+1
exitwhen SU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Kt,Condition(aq))
call TriggerAddAction(Kt,nq)
set tU=null
set iU=null
endfunction
function cW takes nothing returns nothing
local trigger tW
local playerunitevent iW
local integer SW
set Rt=CreateTrigger()
set tW=Rt
set iW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set SW=0
loop
call TriggerRegisterPlayerUnitEvent(tW,Player(SW),iW,null)
set SW=SW+1
exitwhen SW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Rt,Condition(Te))
call TriggerAddAction(Rt,Ye)
set tW=null
set iW=null
endfunction
function dA takes nothing returns nothing
local trigger qA
local playerunitevent aA
local integer nA
set ai=CreateTrigger()
set qA=ai
set aA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set nA=0
loop
call TriggerRegisterPlayerUnitEvent(qA,Player(nA),aA,null)
set nA=nA+1
exitwhen nA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ai,Condition(pa))
call TriggerAddAction(ai,ea)
set qA=null
set aA=null
endfunction
function dJ takes nothing returns nothing
local trigger qJ
local playerunitevent aJ
local integer nJ
set Wi=CreateTrigger()
set qJ=Wi
set aJ=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set nJ=0
loop
call TriggerRegisterPlayerUnitEvent(qJ,Player(nJ),aJ,null)
set nJ=nJ+1
exitwhen nJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Wi,Condition(Ba))
call TriggerAddAction(Wi,Na)
set qJ=null
set aJ=null
endfunction
function dm takes nothing returns nothing
local trigger qm
local playerunitevent am
local integer nm
set ct=CreateTrigger()
set qm=ct
set am=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set nm=0
loop
call TriggerRegisterPlayerUnitEvent(qm,Player(nm),am,null)
set nm=nm+1
exitwhen nm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ct,Condition(Cp))
call TriggerAddAction(ct,Vp)
set qm=null
set am=null
endfunction
function eL takes nothing returns nothing
local trigger bL
local playerunitevent yL
local integer pL
set Vi=CreateTrigger()
set bL=Vi
set yL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set pL=0
loop
call TriggerRegisterPlayerUnitEvent(bL,Player(pL),yL,null)
set pL=pL+1
exitwhen pL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Vi,Condition(Fn))
call TriggerAddAction(Vi,kn)
set bL=null
set yL=null
endfunction
function eU takes nothing returns nothing
local trigger bU
local playerunitevent yU
local integer pU
set Lt=CreateTrigger()
set bU=Lt
set yU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set pU=0
loop
call TriggerRegisterPlayerUnitEvent(bU,Player(pU),yU,null)
set pU=pU+1
exitwhen pU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Lt,Condition(dq))
call TriggerAddAction(Lt,fq)
set bU=null
set yU=null
endfunction
function eW takes nothing returns nothing
local trigger bW
local playerunitevent yW
local integer pW
set Tt=CreateTrigger()
set bW=Tt
set yW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set pW=0
loop
call TriggerRegisterPlayerUnitEvent(bW,Player(pW),yW,null)
set pW=pW+1
exitwhen pW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Tt,Condition(Ge))
call TriggerAddAction(Tt,ge)
set bW=null
set yW=null
endfunction
function fI takes nothing returns nothing
local trigger aI
local playerunitevent nI
local integer dI
set ui=CreateTrigger()
set aI=ui
set nI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set dI=0
loop
call TriggerRegisterPlayerUnitEvent(aI,Player(dI),nI,null)
set dI=dI+1
exitwhen dI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ui,Condition(Eq))
call TriggerAddAction(ui,Zq)
set aI=null
set nI=null
endfunction
function fj takes nothing returns nothing
local trigger aj
local playerunitevent nj
local integer dj
set Xs=CreateTrigger()
set aj=Xs
set nj=EVENT_PLAYER_UNIT_DEATH
set dj=0
loop
call TriggerRegisterPlayerUnitEvent(aj,Player(dj),nj,null)
set dj=dj+1
exitwhen dj==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Xs,Condition(gp))
call TriggerAddAction(Xs,hp)
set aj=null
set nj=null
endfunction
function fx takes nothing returns nothing
local trigger ax
local playerunitevent nx
local integer dx
set Bs=CreateTrigger()
set ax=Bs
set nx=EVENT_PLAYER_UNIT_DEATH
set dx=0
loop
call TriggerRegisterPlayerUnitEvent(ax,Player(dx),nx,null)
set dx=dx+1
exitwhen dx==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Bs,Condition(vp))
call TriggerAddAction(Bs,mp)
set ax=null
set nx=null
endfunction
function gv takes nothing returns nothing
local trigger Tv
local playerunitevent Yv
local integer Gv
set ut=CreateTrigger()
set Tv=ut
set Yv=EVENT_PLAYER_UNIT_DEATH
set Gv=0
loop
call TriggerRegisterPlayerUnitEvent(Tv,Player(Gv),Yv,null)
set Gv=Gv+1
exitwhen Gv==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ut,Condition(Up))
call TriggerAddAction(ut,Ip)
set Tv=null
set Yv=null
endfunction
function hA takes nothing returns nothing
local trigger YA
local playerunitevent GA
local integer gA
set ni=CreateTrigger()
set YA=ni
set GA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set gA=0
loop
call TriggerRegisterPlayerUnitEvent(YA,Player(gA),GA,null)
set gA=gA+1
exitwhen gA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ni,Condition(qa))
call TriggerAddAction(ni,aa)
set YA=null
set GA=null
endfunction
function hJ takes nothing returns nothing
local trigger YJ
local playerunitevent GJ
local integer gJ
set Ei=CreateTrigger()
set YJ=Ei
set GJ=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set gJ=0
loop
call TriggerRegisterPlayerUnitEvent(YJ,Player(gJ),GJ,null)
set gJ=gJ+1
exitwhen gJ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ei,Condition(Ma))
call TriggerAddAction(Ei,wn)
set YJ=null
set GJ=null
endfunction
function hm takes nothing returns nothing
local trigger Ym
local playerunitevent Gm
local integer gm
set ot=CreateTrigger()
set Ym=ot
set Gm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set gm=0
loop
call TriggerRegisterPlayerUnitEvent(Ym,Player(gm),Gm,null)
set gm=gm+1
exitwhen gm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ot,Condition(Bp))
call TriggerAddAction(ot,Np)
set Ym=null
set Gm=null
endfunction
function iI takes nothing returns nothing
local trigger rI
local playerunitevent sI
local integer tI
set Mt=CreateTrigger()
set rI=Mt
set sI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set tI=0
loop
call TriggerRegisterPlayerUnitEvent(rI,Player(tI),sI,null)
set tI=tI+1
exitwhen tI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Mt,Condition(vq))
call TriggerAddAction(Mt,mq)
set rI=null
set sI=null
endfunction
function iX takes nothing returns nothing
local trigger rX
local playerunitevent sX
local integer tX
set rS=CreateTrigger()
set rX=rS
set sX=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set tX=0
loop
call TriggerRegisterPlayerUnitEvent(rX,Player(tX),sX,null)
set tX=tX+1
exitwhen tX==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(rS,Condition(Pn))
call TriggerAddAction(rS,An)
set rX=null
set sX=null
endfunction
function jF takes nothing returns nothing
set Ds=CreateTrigger()
call TriggerRegisterTimerEvent(Ds,5.00,true)
call TriggerAddAction(Ds,qp)
endfunction
function jL takes nothing returns nothing
local trigger hL
local playerunitevent FL
local integer kL
set Ni=CreateTrigger()
set hL=Ni
set FL=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set kL=0
loop
call TriggerRegisterPlayerUnitEvent(hL,Player(kL),FL,null)
set kL=kL+1
exitwhen kL==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ni,Condition(vn))
call TriggerAddAction(Ni,mn)
set hL=null
set FL=null
endfunction
function jU takes nothing returns nothing
local trigger hU
local playerunitevent FU
local integer kU
set Ct=CreateTrigger()
set hU=Ct
set FU=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set kU=0
loop
call TriggerRegisterPlayerUnitEvent(hU,Player(kU),FU,null)
set kU=kU+1
exitwhen kU==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ct,Condition(Yq))
call TriggerAddAction(Ct,Gq)
set hU=null
set FU=null
endfunction
function jW takes nothing returns nothing
local trigger hW
local playerunitevent FW
local integer kW
set Gt=CreateTrigger()
set hW=Gt
set FW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set kW=0
loop
call TriggerRegisterPlayerUnitEvent(hW,Player(kW),FW,null)
set kW=kW+1
exitwhen kW==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Gt,Condition(ke))
call TriggerAddAction(Gt,je)
set hW=null
set FW=null
endfunction
function kP takes nothing returns nothing
local trigger gP
local playerunitevent hP
local integer FP
set li=CreateTrigger()
set gP=li
set hP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set FP=0
loop
call TriggerRegisterPlayerUnitEvent(gP,Player(FP),hP,null)
set FP=FP+1
exitwhen FP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(li,Condition(ua))
call TriggerAddAction(li,ra)
set gP=null
set hP=null
endfunction
function kY takes nothing returns nothing
local trigger gY
local playerunitevent hY
local integer FY
set hs=CreateTrigger()
set gY=hs
set hY=EVENT_PLAYER_UNIT_ATTACKED
set FY=0
loop
call TriggerRegisterPlayerUnitEvent(gY,Player(FY),hY,null)
set FY=FY+1
exitwhen FY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(hs,Condition(xy))
call TriggerAddAction(hs,vy)
set gY=null
set hY=null
endfunction
function kZ takes nothing returns nothing
local trigger gZ
local playerunitevent hZ
local integer FZ
set Pt=CreateTrigger()
set gZ=Pt
set hZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set FZ=0
loop
call TriggerRegisterPlayerUnitEvent(gZ,Player(FZ),hZ,null)
set FZ=FZ+1
exitwhen FZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Pt,Condition(Sq))
call TriggerAddAction(Pt,cq)
set gZ=null
set hZ=null
endfunction
function oE takes nothing returns nothing
local trigger iE
local playerunitevent SE
local integer cE
set jt=CreateTrigger()
set iE=jt
set SE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set cE=0
loop
call TriggerRegisterPlayerUnitEvent(iE,Player(cE),SE,null)
set cE=cE+1
exitwhen cE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(jt,Condition(Ie))
call TriggerAddAction(jt,Pe)
set iE=null
set SE=null
endfunction
function pP takes nothing returns nothing
local trigger lP
local playerunitevent bP
local integer yP
set oi=CreateTrigger()
set lP=oi
set bP=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set yP=0
loop
call TriggerRegisterPlayerUnitEvent(lP,Player(yP),bP,null)
set yP=yP+1
exitwhen yP==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(oi,Condition(Bq))
call TriggerAddAction(oi,Nq)
set lP=null
set bP=null
endfunction
function pZ takes nothing returns nothing
local trigger lZ
local playerunitevent bZ
local integer yZ
set Ut=CreateTrigger()
set lZ=Ut
set bZ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set yZ=0
loop
call TriggerRegisterPlayerUnitEvent(lZ,Player(yZ),bZ,null)
set yZ=yZ+1
exitwhen yZ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ut,Condition(rq))
call TriggerAddAction(Ut,sq)
set lZ=null
set bZ=null
endfunction
function qE takes nothing returns nothing
local trigger yE
local playerunitevent pE
local integer eE
set xt=CreateTrigger()
set yE=xt
set pE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set eE=0
loop
call TriggerRegisterPlayerUnitEvent(yE,Player(eE),pE,null)
set eE=eE+1
exitwhen eE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(xt,Condition(Ae))
call TriggerAddAction(xt,De)
set yE=null
set pE=null
endfunction
function qY takes nothing returns nothing
local trigger yY
local playerunitevent pY
local integer eY
set gs=CreateTrigger()
set yY=gs
set pY=EVENT_PLAYER_UNIT_ATTACKED
set eY=0
loop
call TriggerRegisterPlayerUnitEvent(yY,Player(eY),pY,null)
set eY=eY+1
exitwhen eY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gs,Condition(ky))
call TriggerAddAction(gs,jy)
set yY=null
set pY=null
endfunction
function qk takes nothing returns nothing
local trigger yk
local playerunitevent pk
local integer ek
set Js=CreateTrigger()
set yk=Js
set pk=EVENT_PLAYER_UNIT_SPELL_CAST
set ek=0
loop
call TriggerRegisterPlayerUnitEvent(yk,Player(ek),pk,null)
set ek=ek+1
exitwhen ek==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Js,Condition(dp))
call TriggerAddAction(Js,fp)
set yk=null
set pk=null
endfunction
function rD takes nothing returns nothing
local trigger MA
local playerunitevent wD
local integer uD
set Ti=CreateTrigger()
set MA=Ti
set wD=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set uD=0
loop
call TriggerRegisterPlayerUnitEvent(MA,Player(uD),wD,null)
set uD=uD+1
exitwhen uD==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ti,Condition(Ga))
call TriggerAddAction(Ti,ga)
set MA=null
set wD=null
endfunction
function rK takes nothing returns nothing
local trigger MJ
local playerunitevent wK
local integer uK
set Pi=CreateTrigger()
set MJ=Pi
set wK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set uK=0
loop
call TriggerRegisterPlayerUnitEvent(MJ,Player(uK),wK,null)
set uK=uK+1
exitwhen uK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Pi,Condition(on))
call TriggerAddAction(Pi,On)
set MJ=null
set wK=null
endfunction
function rQ takes nothing returns nothing
local trigger Mm
local playerunitevent wQ
local integer uQ
set yt=CreateTrigger()
set Mm=yt
set wQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set uQ=0
loop
call TriggerRegisterPlayerUnitEvent(Mm,Player(uQ),wQ,null)
set uQ=uQ+1
exitwhen uQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(yt,Condition(ie))
call TriggerAddAction(yt,Se)
set Mm=null
set wQ=null
endfunction
function rj takes nothing returns nothing
local trigger Mk
local playerunitevent wj
local integer uj
set Ls=CreateTrigger()
set Mk=Ls
set wj=EVENT_PLAYER_UNIT_SPELL_CAST
set uj=0
loop
call TriggerRegisterPlayerUnitEvent(Mk,Player(uj),wj,null)
set uj=uj+1
exitwhen uj==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ls,Condition(Yp))
call TriggerAddAction(Ls,Gp)
set Mk=null
set wj=null
endfunction
function rx takes nothing returns nothing
local trigger Mj
local playerunitevent wx
local integer ux
set Vs=CreateTrigger()
set Mj=Vs
set wx=EVENT_PLAYER_UNIT_DEATH
set ux=0
loop
call TriggerRegisterPlayerUnitEvent(Mj,Player(ux),wx,null)
set ux=ux+1
exitwhen ux==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Vs,Condition(jp))
call TriggerAddAction(Vs,xp)
set Mj=null
set wx=null
endfunction
function sG takes nothing returns nothing
local trigger wG
local playerunitevent uG
local integer rG
set js=CreateTrigger()
set wG=js
set uG=EVENT_PLAYER_UNIT_SPELL_EFFECT
set rG=0
loop
call TriggerRegisterPlayerUnitEvent(wG,Player(rG),uG,null)
set rG=rG+1
exitwhen rG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(js,Condition(Zy))
call TriggerAddAction(js,Uy)
set wG=null
set uG=null
endfunction
function sY takes nothing returns nothing
local trigger wY
local playerunitevent uY
local integer rY
set Gs=CreateTrigger()
set wY=Gs
set uY=EVENT_PLAYER_UNIT_ATTACKED
set rY=0
loop
call TriggerRegisterPlayerUnitEvent(wY,Player(rY),uY,null)
set rY=rY+1
exitwhen rY==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Gs,Condition(hy))
call TriggerAddAction(Gs,Fy)
set wY=null
set uY=null
endfunction
function tA takes nothing returns nothing
local trigger uA
local playerunitevent rA
local integer sA
set ei=CreateTrigger()
set uA=ei
set rA=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set sA=0
loop
call TriggerRegisterPlayerUnitEvent(uA,Player(sA),rA,null)
set sA=sA+1
exitwhen sA==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ei,Condition(Oa))
call TriggerAddAction(ei,la)
set uA=null
set rA=null
endfunction
function tm takes nothing returns nothing
local trigger um
local playerunitevent rm
local integer sm
set tt=CreateTrigger()
set um=tt
set rm=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set sm=0
loop
call TriggerRegisterPlayerUnitEvent(um,Player(sm),rm,null)
set sm=sm+1
exitwhen sm==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(tt,Condition(Jp))
call TriggerAddAction(tt,Kp)
set um=null
set rm=null
endfunction
function uE takes nothing returns nothing
local trigger NW
local playerunitevent MW
local integer wE
set kt=CreateTrigger()
set NW=kt
set MW=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set wE=0
loop
call TriggerRegisterPlayerUnitEvent(NW,Player(wE),MW,null)
set wE=wE+1
exitwhen wE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(kt,Condition(Ze))
call TriggerAddAction(kt,Ue)
set NW=null
set MW=null
endfunction
function vK takes nothing returns nothing
local trigger kK
local playerunitevent jK
local integer xK
set Ji=CreateTrigger()
set kK=Ji
set jK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set xK=0
loop
call TriggerRegisterPlayerUnitEvent(kK,Player(xK),jK,null)
set xK=xK+1
exitwhen xK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ji,Condition(an))
call TriggerAddAction(Ji,nn)
set kK=null
set jK=null
endfunction
function vQ takes nothing returns nothing
local trigger kQ
local playerunitevent jQ
local integer xQ
set at=CreateTrigger()
set kQ=at
set jQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set xQ=0
loop
call TriggerRegisterPlayerUnitEvent(kQ,Player(xQ),jQ,null)
set xQ=xQ+1
exitwhen xQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(at,Condition(pe))
call TriggerAddAction(at,ee)
set kQ=null
set jQ=null
endfunction
function wL takes nothing returns nothing
local trigger BK
local playerunitevent NK
local integer MK
set Xi=CreateTrigger()
set BK=Xi
set NK=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set MK=0
loop
call TriggerRegisterPlayerUnitEvent(BK,Player(MK),NK,null)
set MK=MK+1
exitwhen MK==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Xi,Condition(Yn))
call TriggerAddAction(Xi,Gn)
set BK=null
set NK=null
endfunction
function wU takes nothing returns nothing
set Jt=CreateTrigger()
call TriggerRegisterTimerEvent(Jt,0.10,false)
call TriggerAddAction(Jt,qq)
endfunction
function wW takes nothing returns nothing
local trigger BQ
local playerunitevent NQ
local integer MQ
set ft=CreateTrigger()
set BQ=ft
set NQ=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set MQ=0
loop
call TriggerRegisterPlayerUnitEvent(BQ,Player(MQ),NQ,null)
set MQ=MQ+1
exitwhen MQ==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(ft,Condition(fe))
call TriggerAddAction(ft,Re)
set BQ=null
set NQ=null
endfunction
function xE takes nothing returns nothing
local trigger FE
local playerunitevent kE
local integer jE
set mt=CreateTrigger()
set FE=mt
set kE=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set jE=0
loop
call TriggerRegisterPlayerUnitEvent(FE,Player(jE),kE,null)
set jE=jE+1
exitwhen jE==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(mt,Condition(Ke))
call TriggerAddAction(mt,Le)
set FE=null
set kE=null
endfunction
function xG takes nothing returns nothing
local trigger FG
local playerunitevent kG
local integer jG
set vs=CreateTrigger()
set FG=vs
set kG=EVENT_PLAYER_UNIT_SPELL_CAST
set jG=0
loop
call TriggerRegisterPlayerUnitEvent(FG,Player(jG),kG,null)
set jG=jG+1
exitwhen jG==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddAction(vs,Py)
set FG=null
set kG=null
endfunction
function xg takes nothing returns nothing
local trigger Fg
local playerunitevent kg
local integer jg
set Ws=CreateTrigger()
set Fg=Ws
set kg=EVENT_PLAYER_UNIT_SPELL_CAST
set jg=0
loop
call TriggerRegisterPlayerUnitEvent(Fg,Player(jg),kg,null)
set jg=jg+1
exitwhen jg==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ws,Condition(Cy))
call TriggerAddAction(Ws,Vy)
set Fg=null
set kg=null
endfunction
function xh takes nothing returns nothing
local trigger Fh
local playerunitevent kh
local integer jh
set Us=CreateTrigger()
set Fh=Us
set kh=EVENT_PLAYER_UNIT_SPELL_CAST
set jh=0
loop
call TriggerRegisterPlayerUnitEvent(Fh,Player(jh),kh,null)
set jh=jh+1
exitwhen jh==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Us,Condition(tp))
call TriggerAddAction(Us,ip)
set Fh=null
set kh=null
endfunction
function yF takes nothing returns nothing
local trigger OF
local playerunitevent lF
local integer bF
set Ps=CreateTrigger()
set OF=Ps
set lF=EVENT_PLAYER_UNIT_SPELL_CAST
set bF=0
loop
call TriggerRegisterPlayerUnitEvent(OF,Player(bF),lF,null)
set bF=bF+1
exitwhen bF==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Ps,Condition(lp))
call TriggerAddAction(Ps,bp)
set OF=null
set lF=null
endfunction
function yI takes nothing returns nothing
local trigger OI
local playerunitevent lI
local integer bI
set wi=CreateTrigger()
set OI=wi
set lI=EVENT_PLAYER_UNIT_RESEARCH_FINISH
set bI=0
loop
call TriggerRegisterPlayerUnitEvent(OI,Player(bI),lI,null)
set bI=bI+1
exitwhen bI==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(wi,Condition(Qq))
call TriggerAddAction(wi,Wq)
set OI=null
set lI=null
endfunction
function yg takes nothing returns nothing
local trigger Og
local playerunitevent lg
local integer bg
set Qs=CreateTrigger()
set Og=Qs
set lg=EVENT_PLAYER_UNIT_SPELL_CAST
set bg=0
loop
call TriggerRegisterPlayerUnitEvent(Og,Player(bg),lg,null)
set bg=bg+1
exitwhen bg==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Qs,Condition(Ky))
call TriggerAddAction(Qs,Ly)
set Og=null
set lg=null
endfunction
function yh takes nothing returns nothing
local trigger Oh
local playerunitevent lh
local integer bh
set Zs=CreateTrigger()
set Oh=Zs
set lh=EVENT_PLAYER_UNIT_SPELL_CAST
set bh=0
loop
call TriggerRegisterPlayerUnitEvent(Oh,Player(bh),lh,null)
set bh=bh+1
exitwhen bh==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(Zs,Condition(up))
call TriggerAddAction(Zs,rp)
set Oh=null
set lh=null
endfunction
function SX takes nothing returns nothing
call AT()
set Ts=CreateTrigger()
call TriggerAddAction(Ts,Dn)
call JT()
call sY()
call qY()
call kY()
call AY()
call BY()
call sG()
call aG()
call xG()
call CG()
call yg()
call xg()
call Cg()
call yh()
call xh()
call Ch()
call yF()
call RF()
call jF()
call VF()
call qk()
call Ek()
call rj()
call fj()
call Uj()
call rx()
call fx()
call Px()
call Sv()
set wt=CreateTrigger()
call TriggerAddAction(wt,Hn)
call gv()
call Hv()
call Bv()
call tm()
call bm()
call dm()
call hm()
call Qm()
call Am()
call Cm()
call rQ()
call OQ()
call aQ()
call GQ()
call vQ()
call IQ()
call LQ()
call wW()
call cW()
call eW()
call TW()
call jW()
call ZW()
call JW()
call XW()
call uE()
call oE()
call qE()
call YE()
call xE()
call UE()
call KE()
call ME()
call SZ()
call pZ()
call RZ()
call kZ()
call EZ()
call HZ()
call BZ()
call wU()
call cU()
call eU()
call TU()
call jU()
call ZU()
call JU()
call NU()
call iI()
call yI()
call fI()
call FI()
call WI()
call DI()
call VI()
call MI()
call SP()
call pP()
call RP()
call kP()
call EP()
call HP()
call BP()
call tA()
call bA()
call dA()
call hA()
call QA()
call AA()
call CA()
call rD()
call OD()
call aD()
call GD()
call FD()
call AD()
call LD()
call cH()
call TH()
call EH()
call BH()
call bJ()
call dJ()
call hJ()
call QJ()
call AJ()
call CJ()
call rK()
call OK()
call aK()
call GK()
call vK()
call IK()
call LK()
call wL()
call cL()
call eL()
call TL()
call jL()
call ZL()
call JL()
call NL()
call iX()
endfunction
function AR takes nothing returns nothing
local player IR=Player(7)
local unit PR=CreateUnit(IR,1211118391,-29818.2,30468.8,269.903)
call SetHeroLevel(PR,15,false)
call SetUnitState(PR,UNIT_STATE_MANA,85.)
set PR=CreateUnit(IR,1211118406,-29998.9,29444.3,270.074)
call SetHeroLevel(PR,15,false)
set IR=null
set PR=null
endfunction
function BR takes nothing returns nothing
local player CR=Player(10)
local unit VR=CreateUnit(CR,1211118391,-30338.2,30210.1,270.394)
call SetHeroLevel(VR,15,false)
call SetUnitState(VR,UNIT_STATE_MANA,85.)
set VR=CreateUnit(CR,1211118406,-29904.6,29442.8,269.983)
call SetHeroLevel(VR,15,false)
set CR=null
set VR=null
endfunction
function JR takes nothing returns nothing
local player DR=Player(8)
local unit HR=CreateUnit(DR,1211118391,-29946.0,30342.9,270.023)
call SetHeroLevel(HR,15,false)
call SetUnitState(HR,UNIT_STATE_MANA,85.)
set HR=CreateUnit(DR,1211118406,-30137.9,29561.1,270.206)
call SetHeroLevel(HR,15,false)
set DR=null
set HR=null
endfunction
function OT takes nothing returns nothing
local player cT=Player(14)
local unit oT=CreateUnit(cT,1211118391,-30339.8,29950.4,270.397)
call SetHeroLevel(oT,15,false)
call SetUnitState(oT,UNIT_STATE_MANA,85.)
set oT=CreateUnit(cT,1211118406,-29968.7,29556.2,270.045)
call SetHeroLevel(oT,15,false)
set cT=null
set oT=null
endfunction
function ST takes nothing returns nothing
local player tT=Player(13)
local unit iT=CreateUnit(tT,1211118391,-30204.3,30080.3,270.268)
call SetHeroLevel(iT,15,false)
call SetUnitState(iT,UNIT_STATE_MANA,85.)
set iT=CreateUnit(tT,1211118406,-30039.0,29306.5,270.112)
call SetHeroLevel(iT,15,false)
set tT=null
set iT=null
endfunction
function TR takes nothing returns nothing
local player fR=Player(1)
local unit RR=CreateUnit(fR,1211118391,-30205.9,30601.1,270.267)
call SetHeroLevel(RR,15,false)
call SetUnitState(RR,UNIT_STATE_MANA,85.)
set RR=CreateUnit(fR,1211118406,-30199.1,29448.7,270.266)
call SetHeroLevel(RR,15,false)
set fR=null
set RR=null
endfunction
function TT takes nothing returns nothing
local player fT=Player(18)
local unit RT=CreateUnit(fT,1211118391,-29691.7,30077.9,269.782)
call SetHeroLevel(RT,15,false)
call SetUnitState(RT,UNIT_STATE_MANA,85.)
set RT=CreateUnit(fT,1211118406,-29792.0,29571.7,269.875)
call SetHeroLevel(RT,15,false)
set fT=null
set RT=null
endfunction
function UR takes nothing returns nothing
local player ER=Player(6)
local unit ZR=CreateUnit(ER,1211118391,-29693.7,30597.0,269.786)
call SetHeroLevel(ZR,15,false)
call SetUnitState(ZR,UNIT_STATE_MANA,85.)
set ZR=CreateUnit(ER,1211118406,-30199.8,29310.0,270.267)
call SetHeroLevel(ZR,15,false)
set ER=null
set ZR=null
endfunction
function WR takes nothing returns nothing
local player mR=Player(5)
local unit QR=CreateUnit(mR,1211118391,-29950.2,30589.5,270.027)
call SetHeroLevel(QR,15,false)
call SetUnitState(QR,UNIT_STATE_MANA,85.)
set QR=CreateUnit(mR,1211118406,-30283.9,29308.8,270.348)
call SetHeroLevel(QR,15,false)
set mR=null
set QR=null
endfunction
function XR takes nothing returns nothing
local player KR=Player(9)
local unit LR=CreateUnit(KR,1211118391,-29693.5,30338.3,269.785)
call SetHeroLevel(LR,15,false)
call SetUnitState(LR,UNIT_STATE_MANA,85.)
set LR=CreateUnit(KR,1211118406,-30045.2,29554.8,270.118)
call SetHeroLevel(LR,15,false)
set KR=null
set LR=null
endfunction
function dR takes nothing returns nothing
local player aR=Player(0)
local unit nR=CreateUnit(aR,1211118391,-30470.9,30602.5,270.516)
call SetHeroLevel(nR,15,false)
call SetUnitState(nR,UNIT_STATE_MANA,85.)
set nR=CreateUnit(aR,1211118406,-30360.2,29312.6,270.421)
call SetHeroLevel(nR,15,false)
set aR=null
set nR=null
endfunction
function dT takes nothing returns nothing
local player aT=Player(17)
local unit nT=CreateUnit(aT,1211118391,-29951.6,30084.7,270.028)
call SetHeroLevel(nT,15,false)
call SetUnitState(nT,UNIT_STATE_MANA,85.)
set nT=CreateUnit(aT,1211118406,-29862.1,29302.2,269.942)
call SetHeroLevel(nT,15,false)
set aT=null
set nT=null
endfunction
function gR takes nothing returns nothing
local player YR=Player(2)
local unit GR=CreateUnit(YR,1211118391,-30324.4,30466.1,270.380)
call SetHeroLevel(GR,15,false)
call SetUnitState(GR,UNIT_STATE_MANA,85.)
set GR=CreateUnit(YR,1211118406,-30346.6,29573.7,270.406)
call SetHeroLevel(GR,15,false)
set YR=null
set GR=null
endfunction
function gT takes nothing returns nothing
local player YT=Player(19)
local unit GT=CreateUnit(YT,1211118391,-29820.0,29950.4,269.903)
call SetHeroLevel(GT,15,false)
call SetUnitState(GT,UNIT_STATE_MANA,85.)
set GT=CreateUnit(YT,1211118406,-29707.1,29309.8,269.793)
call SetHeroLevel(GT,15,false)
set YT=null
set GT=null
endfunction
function kR takes nothing returns nothing
local player hR=Player(3)
local unit FR=CreateUnit(hR,1211118391,-30468.2,30345.3,270.516)
call SetHeroLevel(FR,15,false)
call SetUnitState(FR,UNIT_STATE_MANA,85.)
set FR=CreateUnit(hR,1211118406,-30252.3,29576.9,270.316)
call SetHeroLevel(FR,15,false)
set hR=null
set FR=null
endfunction
function kT takes nothing returns nothing
local player hT=Player(22)
local unit FT=CreateUnit(hT,1211118391,-29948.2,29831.1,270.025)
call SetHeroLevel(FT,15,false)
call SetUnitState(FT,UNIT_STATE_MANA,85.)
set FT=CreateUnit(hT,1211118406,-29699.3,29565.4,269.787)
call SetHeroLevel(FT,15,false)
set hT=null
set FT=null
endfunction
function qT takes nothing returns nothing
local player pT=Player(16)
local unit eT=CreateUnit(pT,1211118391,-30203.1,29826.8,270.268)
call SetHeroLevel(eT,15,false)
call SetUnitState(eT,UNIT_STATE_MANA,85.)
set eT=CreateUnit(pT,1211118406,-29780.4,29300.3,269.864)
call SetHeroLevel(eT,15,false)
set pT=null
set eT=null
endfunction
function sT takes nothing returns nothing
local player uT=Player(12)
local unit rT=CreateUnit(uT,1211118391,-30464.7,30089.7,270.515)
call SetHeroLevel(rT,15,false)
call SetUnitState(rT,UNIT_STATE_MANA,85.)
set rT=CreateUnit(uT,1211118406,-29962.2,29311.8,270.038)
call SetHeroLevel(rT,15,false)
set uT=null
set rT=null
endfunction
function vR takes nothing returns nothing
local player jR=Player(4)
local unit xR=CreateUnit(jR,1211118391,-30204.6,30339.2,270.267)
call SetHeroLevel(xR,15,false)
call SetUnitState(xR,UNIT_STATE_MANA,85.)
set xR=CreateUnit(jR,1211118406,-30106.5,29439.8,270.177)
call SetHeroLevel(xR,15,false)
set jR=null
set xR=null
endfunction
function vT takes nothing returns nothing
local player jT=Player(23)
local unit xT=CreateUnit(jT,1211118391,-29689.5,29824.6,269.779)
call SetHeroLevel(xT,15,false)
call SetUnitState(xT,UNIT_STATE_MANA,85.)
set xT=CreateUnit(jT,1211118406,-29815.4,29434.4,269.898)
call SetHeroLevel(xT,15,false)
set jT=null
set xT=null
endfunction
function wT takes nothing returns nothing
local player NR=Player(11)
local unit MR=CreateUnit(NR,1211118391,-29827.0,30210.1,269.911)
call SetHeroLevel(MR,15,false)
call SetUnitState(MR,UNIT_STATE_MANA,85.)
set MR=CreateUnit(NR,1211118406,-30125.9,29321.4,270.196)
call SetHeroLevel(MR,15,false)
set NR=null
set MR=null
endfunction
function yT takes nothing returns nothing
local player lT=Player(15)
local unit bT=CreateUnit(lT,1211118391,-30467.2,29834.7,270.519)
call SetHeroLevel(bT,15,false)
call SetUnitState(bT,UNIT_STATE_MANA,85.)
set bT=CreateUnit(lT,1211118406,-29874.4,29559.4,269.954)
call SetHeroLevel(bT,15,false)
set lT=null
set bT=null
endfunction
function WT takes nothing returns nothing
call dR()
call TR()
call gR()
call kR()
call vR()
call WR()
call UR()
call AR()
call JR()
call XR()
call BR()
call wT()
call sT()
call ST()
call OT()
call yT()
call qT()
call dT()
call TT()
call gT()
call kT()
call vT()
endfunction
function A1 takes nothing returns boolean
set ac=CreateTimer()
call TimerStart(ac,100000.,false,null)
call TimerStart(CreateTimer(),0.030,true,Jf)
return true
endfunction
function AE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989559,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989569,0)
endfunction
function PK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988809 then
return false
endif
return true
endfunction
function AK takes nothing returns boolean
if not PK() then
return false
endif
return true
endfunction
function PQ takes nothing returns boolean
if GetResearched()!=1378889799 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889799,true)!=2 then
return false
endif
return true
endfunction
function AQ takes nothing returns boolean
if not PQ() then
return false
endif
return true
endfunction
function c0w takes integer S0w returns string
if S0w==0 then
return "|cffADADADtrace|r"
elseif S0w==1 then
return "|cff2685DCdebug|r"
elseif S0w==2 then
return "|cffFFCC00info|r"
elseif S0w==3 then
return "|cffF47E3Ewarning|r"
elseif S0w==4 then
return "|cffFB2700error|r"
endif
return "?"
endfunction
function I1 takes string k1,string j1 returns nothing
local integer x1
local string v1
local integer m1
local integer Q1
local integer W1
local integer E1
local string Z1
local string U1
set Xb[Lb]=j1
set Lb=Lb+1
set x1=StringHash(k1)
if HaveSavedInteger(cc,-1,x1) then
if LoadInteger(cc,-1,x1)+60<nc then
set Z1=k1
set v1=""
set m1=Lb
set Q1=0
loop
set m1=m1-1
set Q1=Q1+1
exitwhen Q1>20 or m1<0
set v1=v1+"\n   "+Xb[m1]
endloop
call DisplayTimedTextToPlayer(so,0.,0.,45.,c0w(4)+" - "+Z1+v1)
call SaveInteger(cc,-1,x1,R2I(nc))
call SaveBoolean(cc,-1,x1,false)
elseif HaveSavedBoolean(cc,-1,x1) then
if not LoadBoolean(cc,-1,x1) then
call DisplayTimedTextToPlayer(so,0.,0.,45.,c0w(4)+" - "+"|cffFF3A29Excessive repeating errors are being omitted")
call SaveBoolean(cc,-1,x1,true)
endif
else
call DisplayTimedTextToPlayer(so,0.,0.,45.,c0w(4)+" - "+"|cffFF3A29Excessive repeating errors are being omitted")
call SaveBoolean(cc,-1,x1,true)
endif
else
call SaveInteger(cc,-1,x1,R2I(nc))
set U1="Message: "+k1
set j1=""
set W1=Lb
set E1=0
loop
set W1=W1-1
set E1=E1+1
exitwhen E1>20 or W1<0
set j1=j1+"\n   "+Xb[W1]
endloop
call DisplayTimedTextToPlayer(so,0.,0.,45.,c0w(4)+" - "+U1+j1)
endif
call I2S(1/0)
set Lb=Lb-1
endfunction
function b4 takes string l4 returns boolean
set Xb[Lb]=l4
set Lb=Lb+1
set Xb[Lb]="when calling alloc_LinkedList_Comparator_line504 in LinkedList, line 504"
set Lb=Lb+1
if JO==0 then
if KO<32768 then
set KO=KO+1
else
call I1("Out of memory: Could not create LinkedList_Comparator_line504.","when calling error in LinkedList, line 504")
endif
else
set JO=JO-1
endif
set Lb=Lb-1
set Xb[Lb]="when calling alloc_LinkedList_Comparator_line508 in LinkedList, line 508"
set Lb=Lb+1
if JO==0 then
if KO<32768 then
set KO=KO+1
else
call I1("Out of memory: Could not create LinkedList_Comparator_line508.","when calling error in LinkedList, line 508")
endif
else
set JO=JO-1
endif
set Lb=Lb-1-1
return true
endfunction
function Ajw takes nothing returns boolean
set Lb=0
return b4("LinkedList, line 1")
endfunction
function Dnw takes integer Unw,integer Inw,string Pnw returns boolean
local integer Anw
set Xb[Lb]=Pnw
set Lb=Lb+1
if IO[Unw]==0 then
if Unw==0 then
call I1("Nullpointer exception when calling HashList.has","when calling error in HashList, line 87")
else
call I1("Called HashList.has on invalid object.","when calling error in HashList, line 87")
endif
endif
set Xb[Lb]="when calling has in HashList, line 87"
set Lb=Lb+1
set Xb[Lb]="when calling count in HashList, line 88"
set Lb=Lb+1
if IO[Unw]==0 then
if Unw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Anw=LoadInteger(Rc,Unw,Inw)
set Lb=Lb-1
set Lb=Lb-1-1
return Anw>0
endfunction
function ESw takes integer vSw,unit mSw,string QSw returns nothing
local boolean WSw
set Xb[Lb]=QSw
set Lb=Lb+1
if not Dnw(Bo,GetUnitTypeId(mSw),"when calling has in City, line 314") then
set WSw=GetOwningPlayer(mSw)==ro[ml[Kl[vSw]]]
else
set WSw=false
endif
if WSw then
set Il[Kl[vSw]]=Il[Kl[vSw]]+0.5
endif
set Lb=Lb-1
endfunction
function ebw takes integer Obw,integer lbw,integer bbw,string ybw returns integer
local integer pbw
set Xb[Lb]=ybw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_LLEntry in LinkedList, line 401"
set Lb=Lb+1
if XO==0 then
if CO<32768 then
set CO=CO+1
set pbw=CO
set VO[pbw]=702
else
call I1("Out of memory: Could not create LLEntry.","when calling error in LinkedList, line 396")
set pbw=0
endif
else
set XO=XO-1
set pbw=LO[XO]
set VO[pbw]=702
endif
set Lb=Lb-1
set fb[pbw]=Obw
set Rb[pbw]=lbw
set Tb[pbw]=bbw
set Lb=Lb-1
return pbw
endfunction
function ffw takes integer qfw,integer afw,string nfw returns nothing
local integer dfw
set Xb[Lb]=nfw
set Lb=Lb+1
if tl[qfw]==0 then
if qfw==0 then
call I1("Nullpointer exception when calling LinkedList.add","when calling error in LinkedList, line 37")
else
call I1("Called LinkedList.add on invalid object.","when calling error in LinkedList, line 37")
endif
endif
set Xb[Lb]="when calling add in LinkedList, line 37"
set Lb=Lb+1
set dfw=ebw(afw,Rb[Fb[qfw]],Fb[qfw],"when calling new_LLEntry in LinkedList, line 39")
set Tb[Rb[Fb[qfw]]]=dfw
set Rb[Fb[qfw]]=dfw
set kb[qfw]=kb[qfw]+1
set Lb=Lb-1-1
endfunction
function Nbw takes integer Xbw,unit Cbw,string Vbw returns nothing
local boolean Bbw
set Xb[Lb]=Vbw
set Lb=Lb+1
if GetOwningPlayer(Cbw)==jb[Xbw]then
set Bbw=not Dnw(Bo,GetUnitTypeId(Cbw),"when calling has in MassControl, line 28")
else
set Bbw=false
endif
if Bbw and Cbw!=xb[Xbw] and(not IsUnitType(Cbw,UNIT_TYPE_STRUCTURE)) then
call ffw(vb[Xbw],GetHandleId(Cbw),"when calling add in MassControl, line 29")
endif
set Lb=Lb-1
endfunction
function O0w takes integer o0w returns real
if o0w==1747988785 then
return 10.0
elseif o0w==1747989075 then
return 10.0
elseif o0w==1747990102 then
return 10.0
elseif o0w==1747989839 then
return 10.0
elseif o0w==1747988568 then
return 5.0
elseif o0w==1747990341 then
return 5.0
elseif o0w==1747988789 then
return 15.0
elseif o0w==1747990103 then
return 15.0
elseif o0w==1747990064 then
return 15.0
elseif o0w==1747989846 then
return 15.0
else
return 0.0
endif
endfunction
function PSw takes integer ZSw,unit USw returns nothing
local boolean ISw
if IsUnitType(USw,UNIT_TYPE_STRUCTURE) then
set ISw=GetOwningPlayer(USw)==ro[ml[Ll[ZSw]]]
else
set ISw=false
endif
if ISw then
set Il[Ll[ZSw]]=Il[Ll[ZSw]]+O0w(GetUnitTypeId(USw))
endif
endfunction
function Naw takes integer Caw,unit Vaw,string Baw returns nothing
set Xb[Lb]=Baw
set Lb=Lb+1
if fO[Caw]==0 then
if Caw==0 then
call I1("Nullpointer exception when calling ForGroupCallback.callback","when calling error in ClosureForGroups, line 4")
else
call I1("Called ForGroupCallback.callback on invalid object.","when calling error in ClosureForGroups, line 4")
endif
endif
if fO[Caw]<=690 then
if fO[Caw]<=689 then
if fO[Caw]<=688 then
call ESw(Caw,Vaw,"when calling City_City_callback_line313 in ClosureForGroups, line 4")
else
call PSw(Caw,Vaw)
endif
else
set Xb[Lb]="when calling LinkedList_callback_line514 in ClosureForGroups, line 4"
set Lb=Lb+1
call ffw(db[Caw],GetHandleId(Vaw),"when calling add in LinkedList, line 515")
set Lb=Lb-1
endif
elseif fO[Caw]<=691 then
call Nbw(Caw,Vaw,"when calling MassControl_callback_line27 in ClosureForGroups, line 4")
else
call RemoveUnit(Vaw)
endif
set Lb=Lb-1
endfunction
function Axw takes nothing returns nothing
local unit Pxw
set Lb=0
set Xb[Lb]="ClosureForGroups, line 14"
set Lb=Lb+1
set Pxw=GetFilterUnit()
set Xb[Lb]="when calling filterCallback in ClosureForGroups, line 14"
set Lb=Lb+1
if KS<JS then
call Naw(DS[HS-1],Pxw,"when calling callback in ClosureForGroups, line 18")
endif
set KS=KS+1
set Lb=Lb-1-1
set Pxw=null
endfunction
function B1 takes nothing returns boolean
set fc=InitHashtable()
set Rc=InitHashtable()
return true
endfunction
function VA takes nothing returns boolean
if GetResearched()!=1378890052 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890052,true)!=1 then
return false
endif
return true
endfunction
function BA takes nothing returns boolean
if not VA() then
return false
endif
return true
endfunction
function BI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989815,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989816,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989825,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989814,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989830,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651844,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989833,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989832,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989835,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989836,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651848,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651846,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989828,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989826,0)
endfunction
function VJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990352 then
return false
endif
return true
endfunction
function BJ takes nothing returns boolean
if not VJ() then
return false
endif
return true
endfunction
function BW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990097,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989594,0)
endfunction
function Vww takes timer Jww,integer Kww,string Lww returns nothing
local integer Xww
local integer Cww
set Xb[Lb]=Lww
set Lb=Lb+1
set Xww=Po
set Cww=GetHandleId(Jww)
set Xb[Lb]="when calling saveInt in TimerUtils, line 17"
set Lb=Lb+1
if HO[Xww]==0 then
if Xww==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,Xww,Cww,Kww)
set Lb=Lb-1-1
endfunction
function iww takes string sww returns timer
local timer tww
set Xb[Lb]=sww
set Lb=Lb+1
if Io>0 then
set Io=Io-1
call Vww(Uo[Io],0,"when calling setData in TimerUtils, line 29")
set Lb=Lb-1
set tww=null
return Uo[Io]
else
set tww=CreateTimer()
call Vww(tww,0,"when calling setData in TimerUtils, line 32")
set Lb=Lb-1
set OR=tww
set tww=null
return OR
endif
endfunction
function Mcw takes integer Ccw,timer Vcw,real Bcw,string Ncw returns nothing
set Xb[Lb]=Ncw
set Lb=Lb+1
call Vww(Vcw,Ccw,"when calling setData in ClosureTimers, line 113")
call TimerStart(Vcw,Bcw,false,uR)
set Sb[Ccw]=Vcw
set Lb=Lb-1
endfunction
function fnw takes integer qnw,timer anw,real nnw,string dnw returns nothing
set Xb[Lb]=dnw
set Lb=Lb+1
if GO[qnw]==0 then
if qnw==0 then
call I1("Nullpointer exception when calling CallbackSingle.start","when calling error in ClosureTimers, line 111")
else
call I1("Called CallbackSingle.start on invalid object.","when calling error in ClosureTimers, line 111")
endif
endif
call Mcw(qnw,anw,nnw,"when calling start in ClosureTimers, line 111")
set Lb=Lb-1
endfunction
function jB takes timer gB,real hB,integer FB,string kB returns integer
set Xb[Lb]=kB
set Lb=Lb+1
call fnw(FB,gB,hB,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1
return FB
endfunction
function w0w takes string C9 returns boolean
local integer V9
local integer B9
local integer N9
local integer M9
set Xb[Lb]=C9
set Lb=Lb+1
set lo=CreateGroup()
set bo=CreateUnit(SS,2019849581,0.,0.,0)
if bo==null then
set C9=""
set V9=2019849581
set B9=0
loop
exitwhen B9>3
set N9=ModuloInteger(V9,256)
set V9=V9/256
set C9=SubString(".................................!.#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~.................................................................................................................................",N9,N9+1)+C9
set B9=B9+1
endloop
call I1("DUMMY_UNITID ("+C9+") not added correctly to the map.","when calling error in Preloader, line 52")
endif
set Xb[Lb]="when calling alloc_Preloader_CallbackSingle_line54 in Preloader, line 54"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set M9=YO
set GO[M9]=652
else
call I1("Out of memory: Could not create Preloader_CallbackSingle_line54.","when calling error in Preloader, line 54")
set M9=0
endif
else
set TO=TO-1
set M9=RO[TO]
set GO[M9]=652
endif
set Lb=Lb-1
set Xb[Lb]="when calling nullTimer in Preloader, line 54"
set Lb=Lb+1
set Xb[Lb]="when calling doAfter in ClosureTimers, line 33"
set Lb=Lb+1
call jB(iww("when calling getTimer in ClosureTimers, line 27"),0.,M9,"when calling doAfter in ClosureTimers, line 27")
set Lb=Lb-1-1-1
return true
endfunction
function Bjw takes nothing returns boolean
set Lb=0
return w0w("Preloader, line 1")
endfunction
function Vm takes nothing returns boolean
if GetResearched()!=1378889798 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889798,true)!=2 then
return false
endif
return true
endfunction
function Bm takes nothing returns boolean
if not Vm() then
return false
endif
return true
endfunction
function E0w takes playerunitevent h0w,code F0w,code k0w,code j0w returns nothing
local integer x0w=GetHandleId(h0w)
local integer v0w
local filterfunc m0w
local trigger Q0w
local player W0w
if eo[x0w]==null then
set eo[x0w]=CreateTrigger()
set v0w=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen v0w<0
set Q0w=eo[x0w]
set W0w=ro[v0w]
if F0w!=null then
set m0w=Filter(F0w)
else
set m0w=null
endif
call TriggerRegisterPlayerUnitEvent(Q0w,W0w,h0w,m0w)
set v0w=v0w-1
endloop
endif
if k0w!=null then
call TriggerAddCondition(eo[x0w],Filter(k0w))
endif
if j0w!=null then
call TriggerAddAction(eo[x0w],j0w)
endif
set m0w=null
set Q0w=null
set W0w=null
endfunction
function QV takes eventid RV,string TV returns integer
local integer YV
local integer GV
local integer gV
local trigger hV
local integer FV
local integer kV
local integer jV
local integer xV
local boolean vV
local boolean mV
set Xb[Lb]=TV
set Lb=Lb+1
set YV=GetHandleId(RV)
set WS=WS+1
set QS[YV]=WS
set FV=GetHandleId(RV)
if (FV>=18 and FV<=51)or(FV>=269 and FV<=277) then
call E0w(ConvertPlayerUnitEvent(YV),null,Zf,null)
else
if RV!=EVENT_UNIT_DAMAGED and RV!=EVENT_PLAYER_LEAVE and RV!=jS then
set kV=GetHandleId(RV)
set vV=kV<261 or kV>268 and kV!=17
else
set vV=false
endif
if vV then
set jV=GetHandleId(RV)
set mV=jV<305 or jV>307
else
set mV=false
endif
if mV then
call I1("registering handleid: "+I2S(YV)+" non-playerunitevent. Except EVENT_UNIT_DAMAGED and EVENT_PLAYER_LEAVE these are not supported right now.","when calling error in ClosureEvents, line 243")
endif
endif
set xV=GetHandleId(RV)
if xV>=305 and xV<=307 and(not PS) then
set PS=true
set GV=0
set gV=bj_MAX_PLAYERS-1
loop
exitwhen GV>gV
set hV=mS
call TriggerRegisterPlayerEvent(hV,ro[GV],EVENT_PLAYER_MOUSE_UP)
call TriggerRegisterPlayerEvent(hV,ro[GV],EVENT_PLAYER_MOUSE_DOWN)
call TriggerRegisterPlayerEvent(hV,ro[GV],EVENT_PLAYER_MOUSE_MOVE)
set GV=GV+1
endloop
endif
set Lb=Lb-1
set hV=null
return WS
endfunction
function BSw takes integer ASw returns nothing
local unit DSw=GetDyingUnit()
local real HSw
local real JSw
local player KSw
local integer LSw
local real XSw
local unit CSw
local unitstate VSw
if DSw==kl[Vl[ASw]]then
set KSw=ro[ml[Vl[ASw]]]
set LSw=GetUnitTypeId(DSw)
set kl[Vl[ASw]]=CreateUnitAtLoc(KSw,LSw,GetUnitLoc(DSw),bj_UNIT_FACING)
set CSw=kl[Vl[ASw]]
set VSw=UNIT_STATE_LIFE
set XSw=GetUnitState(kl[Vl[ASw]],UNIT_STATE_MAX_LIFE)
set HSw=po
if 0.>HSw then
set JSw=0.
else
set JSw=HSw
endif
if 50.0>JSw then
set JSw=50.0
endif
call SetUnitState(CSw,VSw,XSw*JSw*0.01)
call SetUnitState(kl[Vl[ASw]],UNIT_STATE_MANA,GetUnitState(DSw,UNIT_STATE_MANA))
endif
set DSw=null
set KSw=null
set CSw=null
set VSw=null
endfunction
function t5 takes player M2,string w5 returns string
local integer u5
local integer r5
local integer s5
set Xb[Lb]=w5
set Lb=Lb+1
set r5=uo[GetPlayerId(M2)]
set Xb[Lb]="when calling getForceId in Messages, line 21"
set Lb=Lb+1
if ll[r5]==0 then
if r5==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set s5=Ub[r5]
set Lb=Lb-1
set u5=GetRandomInt(0,2)
if s5==0 then
set w5=Yo[u5]
elseif s5==1 then
set w5=Go[u5]
elseif s5==2 then
set w5=go[u5]
elseif s5==3 then
set w5=ho[u5]
else
set w5="Note:"
endif
set Lb=Lb-1
return "|cff00ccff"+w5+"|r"
endfunction
function Ecw takes integer jcw,string xcw returns nothing
local integer vcw
local integer mcw
local integer Qcw
local player Wcw
set Xb[Lb]=xcw
set Lb=Lb+1
if GetSpellAbilityId()==1093677620 then
if GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))<24 then
set vcw=uo[GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))]
set Xb[Lb]="when calling getForceId in Clerics, line 10"
set Lb=Lb+1
if ll[vcw]==0 then
if vcw==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set mcw=Ub[vcw]
set Lb=Lb-1
set jcw=uo[GetPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]
set Xb[Lb]="when calling getForceId in Clerics, line 10"
set Lb=Lb+1
if ll[jcw]==0 then
if jcw==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set Qcw=Ub[jcw]
set Lb=Lb-1
if mcw==Qcw then
call IssueImmediateOrderById(GetSpellAbilityUnit(),851972)
set Wcw=GetOwningPlayer(GetSpellAbilityUnit())
set Xb[Lb]="when calling noteToPlayer in Clerics, line 12"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Wcw,0.,0.,10.0,t5(Wcw,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(Wcw,0.,0.,10.0,"Clerics cannot convert someone who professes same religion as you.")
set Lb=Lb-1
endif
endif
endif
set Lb=Lb-1
set Wcw=null
endfunction
function sN takes playercolor JB returns integer
local playercolor CB=JB
local integer VB=0
local integer BB=0
local integer NB=bj_MAX_PLAYER_SLOTS-1
local integer KB
local integer LB
local integer XB
local playercolor MB
local integer wN
local integer uN
local integer rN
loop
exitwhen BB>NB
if Oo[BB]==CB then
set VB=BB
exitwhen true
endif
set BB=BB+1
endloop
if VB<=23 then
set MB=JB
set wN=0
set uN=0
set rN=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen uN>rN
if Oo[uN]==MB then
set wN=uN
exitwhen true
endif
set uN=uN+1
endloop
set KB=CS[wN]
set LB=VS[wN]
set XB=BS[wN]
else
set KB=0
set LB=0
set XB=0
endif
set Cb=KB
set Vb=LB
set Bb=XB
set CB=null
set MB=null
return Cb
endfunction
function HB takes player EB returns string
local integer PB=sN(GetPlayerColor(EB))
local integer AB=Vb
local integer DB=Bb
local integer ZB=PB/16
local integer UB=AB/16
local integer IB=DB/16
return "|cff"+NS[ZB]+NS[PB-ZB*16]+NS[UB]+NS[AB-UB*16]+NS[IB]+NS[DB-IB*16]+GetPlayerName(EB)+"|r"
endfunction
function gtw takes integer Ttw,integer Ytw,string Gtw returns nothing
set Xb[Lb]=Gtw
set Lb=Lb+1
if not Dnw(wO,Ytw,"when calling has in City, line 195") then
set Lb=Lb-1
return
endif
set kl[Ttw]=ReplaceUnitBJ(kl[Ttw],Ytw,bj_UNIT_STATE_METHOD_RELATIVE)
set Lb=Lb-1
endfunction
function tV takes integer rV,integer sV returns integer
if rV==1 then
if sV==0 then
return 1747988529
elseif sV==1 then
return 1747990326
elseif sV==2 then
return 1747990084
elseif sV==3 then
return 1747989590
else
return 1747988529
endif
elseif rV==2 then
if sV==0 then
return 1747988530
elseif sV==1 then
return 1747990327
elseif sV==2 then
return 1747990085
elseif sV==3 then
return 1747989591
else
return 1747988530
endif
elseif rV==3 then
if sV==0 then
return 1747988531
elseif sV==1 then
return 1747990328
elseif sV==2 then
return 1747990086
elseif sV==3 then
return 1747989592
else
return 1747988531
endif
elseif sV==0 then
return 1747988529
elseif sV==1 then
return 1747990326
elseif sV==2 then
return 1747990084
elseif sV==3 then
return 1747989590
else
return 1747988529
endif
endfunction
function tdw takes integer wdw,integer udw,string rdw returns integer
local integer sdw
set Xb[Lb]=rdw
set Lb=Lb+1
if HO[wdw]==0 then
if wdw==0 then
call I1("Nullpointer exception when calling HashMap.get","when calling error in HashMap, line 23")
else
call I1("Called HashMap.get on invalid object.","when calling error in HashMap, line 23")
endif
endif
set Xb[Lb]="when calling get in HashMap, line 23"
set Lb=Lb+1
set Xb[Lb]="when calling loadInt in HashMap, line 24"
set Lb=Lb+1
if HO[wdw]==0 then
if wdw==0 then
call I1("Nullpointer exception when calling Table.loadInt","when calling error in Table, line 39")
else
call I1("Called Table.loadInt on invalid object.","when calling error in Table, line 39")
endif
endif
set sdw=LoadInteger(Zo,wdw,udw)
set Lb=Lb-1-1-1
return sdw
endfunction
function uV takes integer wV returns integer
if wV==1747988529 then
return 1
elseif wV==1747988530 then
return 2
elseif wV==1747988531 then
return 3
elseif wV==1747990326 then
return 1
elseif wV==1747990327 then
return 2
elseif wV==1747990328 then
return 3
elseif wV==1747990084 then
return 1
elseif wV==1747990085 then
return 2
elseif wV==1747990086 then
return 3
elseif wV==1747989590 then
return 1
elseif wV==1747989591 then
return 2
elseif wV==1747989592 then
return 3
else
return 1
endif
endfunction
function fdw takes integer qdw,string adw returns nothing
local integer ndw
local integer ddw
set Xb[Lb]=adw
set Lb=Lb+1
if wl[qdw]==0 then
if qdw==0 then
call I1("Nullpointer exception when calling LLIterator.reset","when calling error in LinkedList, line 421")
else
call I1("Called LLIterator.reset on invalid object.","when calling error in LinkedList, line 421")
endif
endif
set Xb[Lb]="when calling reset in LinkedList, line 421"
set Lb=Lb+1
set ndw=gb[qdw]
set Xb[Lb]="when calling getDummy in LinkedList, line 422"
set Lb=Lb+1
if tl[ndw]==0 then
if ndw==0 then
call I1("Nullpointer exception when calling LinkedList.getDummy","when calling error in LinkedList, line 362")
else
call I1("Called LinkedList.getDummy on invalid object.","when calling error in LinkedList, line 362")
endif
endif
set ddw=Fb[ndw]
set Lb=Lb-1
set Yb[qdw]=ddw
set Gb[qdw]=Yb[qdw]
set Lb=Lb-1-1
endfunction
function dbw takes integer qbw,string abw returns integer
local integer nbw
set Xb[Lb]=abw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_LLIterator in LinkedList, line 412"
set Lb=Lb+1
if NO==0 then
if MO<32768 then
set MO=MO+1
set nbw=MO
set wl[nbw]=703
else
call I1("Out of memory: Could not create LLIterator.","when calling error in LinkedList, line 406")
set nbw=0
endif
else
set NO=NO-1
set nbw=BO[NO]
set wl[nbw]=703
endif
set Lb=Lb-1
set Xb[Lb]="when calling construct_LLIterator in LinkedList, line 412"
set Lb=Lb+1
set hb[nbw]=true
set gb[nbw]=qbw
call fdw(nbw,"when calling reset in LinkedList, line 414")
set Lb=Lb-1-1
return nbw
endfunction
function edw takes integer ydw,string pdw returns nothing
set Xb[Lb]=pdw
set Lb=Lb+1
if wl[ydw]==0 then
if ydw==0 then
call I1("Nullpointer exception when calling LLIterator.LLIterator","when calling error in LinkedList, line 406")
else
call I1("Called LLIterator.LLIterator on invalid object.","when calling error in LinkedList, line 406")
endif
endif
set Xb[Lb]="when calling destroyLLIterator in LinkedList, line 406"
set Lb=Lb+1
set Xb[Lb]="when calling dealloc_LLIterator in LinkedList, line 406"
set Lb=Lb+1
if wl[ydw]==0 then
call I1("Double free: object of type LLIterator","when calling error in LinkedList, line 406")
else
set BO[NO]=ydw
set NO=NO+1
set wl[ydw]=0
endif
set Lb=Lb-1-1-1
endfunction
function gaw takes integer aaw,string naw returns string
local integer daw
local integer faw
local integer Raw
local integer Taw
local integer Yaw
local integer Gaw
set Xb[Lb]=naw
set Lb=Lb+1
if qO[aaw]==0 then
if aaw==0 then
call I1("Nullpointer exception when calling City.getCityNameColored","when calling error in City, line 179")
else
call I1("Called City.getCityNameColored on invalid object.","when calling error in City, line 179")
endif
endif
set Taw=pc[vl[aaw]]
set Yaw=ec[vl[aaw]]
set Gaw=qc[vl[aaw]]
set daw=Taw/16
set faw=Yaw/16
set Raw=Gaw/16
set naw="|cff"+NS[daw]+NS[Taw-daw*16]+NS[faw]+NS[Yaw-faw*16]+NS[Raw]+NS[Gaw-Raw*16]+jl[aaw]+"|r"
set Lb=Lb-1
return naw
endfunction
function Xaw takes integer Kaw,string Law returns nothing
set Xb[Lb]=Law
set Lb=Lb+1
if fO[Kaw]==0 then
if Kaw==0 then
call I1("Nullpointer exception when calling ForGroupCallback.ForGroupCallback","when calling error in ClosureForGroups, line 3")
else
call I1("Called ForGroupCallback.ForGroupCallback on invalid object.","when calling error in ClosureForGroups, line 3")
endif
endif
set Xb[Lb]="when calling destroyForGroupCallback in ClosureForGroups, line 3"
set Lb=Lb+1
set Xb[Lb]="when calling dealloc_ForGroupCallback in ClosureForGroups, line 3"
set Lb=Lb+1
if fO[Kaw]==0 then
call I1("Double free: object of type ForGroupCallback","when calling error in ClosureForGroups, line 3")
else
set aO[nO]=Kaw
set nO=nO+1
set fO[Kaw]=0
endif
set Lb=Lb-1-1-1
endfunction
function YB takes real nB,real dB,real fB,integer RB,string TB returns nothing
set Xb[Lb]=TB
set Lb=Lb+1
set DS[HS]=RB
set HS=HS+1
set KS=0
set JS=2147483647
call GroupEnumUnitsInRange(AS,nB,dB,fB,LS)
set Xb[Lb]="when calling popCallback in ClosureForGroups, line 98"
set Lb=Lb+1
call GroupClear(AS)
set HS=HS-1
call Xaw(DS[HS],"when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 30")
set Lb=Lb-1-1
endfunction
function a5 takes player b5,string y5 returns string
local integer p5
local integer e5
local integer q5
set Xb[Lb]=y5
set Lb=Lb+1
set e5=uo[GetPlayerId(b5)]
set Xb[Lb]="when calling getForceId in Messages, line 53"
set Lb=Lb+1
if ll[e5]==0 then
if e5==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set q5=Ub[e5]
set Lb=Lb-1
set p5=GetRandomInt(0,2)
if q5==0 then
set y5=vo[p5]
elseif q5==1 then
set y5=mo[p5]
elseif q5==2 then
set y5=Qo[p5]
elseif q5==3 then
set y5=Wo[p5]
else
set y5="Attention!"
endif
set Lb=Lb-1
return "|cffffa600"+y5+"|r"
endfunction
function jaw takes integer haw,integer Faw,string kaw returns nothing
set Xb[Lb]=kaw
set Lb=Lb+1
if qO[haw]==0 then
if haw==0 then
call I1("Nullpointer exception when calling City.getCityModifierOnAdd","when calling error in City, line 415")
else
call I1("Called City.getCityModifierOnAdd on invalid object.","when calling error in City, line 415")
endif
endif
set Xb[Lb]="when calling getCityModifierOnAdd in City, line 415"
set Lb=Lb+1
set Pl[haw]=Pl[haw]+fl[tdw(dS,Faw,"when calling get in City, line 416")]
set Al[haw]=Al[haw]+gl[tdw(dS,Faw,"when calling get in City, line 417")]
set Lb=Lb-1-1
endfunction
function kbw takes integer gbw,integer hbw returns boolean
local integer Fbw=Tb[Fb[gbw]]
loop
exitwhen Fbw==Fb[gbw]
if fb[Fbw]==hbw then
return true
endif
set Fbw=Tb[Fbw]
endloop
return false
endfunction
function ytw takes integer itw,integer Stw,string ctw returns boolean
local real otw
local integer Otw
local boolean ltw
local integer btw
set Xb[Lb]=ctw
set Lb=Lb+1
set Otw=Jl[itw]
set Xb[Lb]="when calling has in City, line 366"
set Lb=Lb+1
if tl[Otw]==0 then
if Otw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set ltw=kbw(Otw,Stw)
set Lb=Lb-1
if ltw then
set Lb=Lb-1
return false
endif
call ffw(Jl[itw],Stw,"when calling add in City, line 368")
call jaw(itw,Stw,"when calling getCityModifierOnAdd in City, line 369")
set otw=dl[tdw(dS,Stw,"when calling get in City, line 370")]
set Xb[Lb]="when calling alloc_City_City_CallbackSingle_line370 in City, line 370"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set btw=YO
set GO[btw]=639
else
call I1("Out of memory: Could not create City_City_CallbackSingle_line370.","when calling error in City, line 370")
set btw=0
endif
else
set TO=TO-1
set btw=RO[TO]
set GO[btw]=639
endif
set Lb=Lb-1
set Xl[btw]=itw
set Cl[btw]=Stw
set Xb[Lb]="when calling doAfter in City, line 370"
set Lb=Lb+1
call jB(iww("when calling getTimer in ClosureTimers, line 27"),otw,btw,"when calling doAfter in ClosureTimers, line 27")
set Lb=Lb-1-1
return true
endfunction
function eww takes integer A0w,string D0w returns nothing
local integer H0w
local unit J0w
local integer K0w
local integer L0w
local integer X0w
local integer C0w
local integer V0w
local integer B0w
local integer N0w
local real M0w
local integer www
local integer uww
local integer rww
local unit sww
local player tww
local integer iww_2
local player Sww
local integer cww
local integer oww
local integer Oww
local integer lww
local integer bww
local integer yww
local boolean pww
set Xb[Lb]=D0w
set Lb=Lb+1
if A0w<0 or A0w>=fS then
set Lb=Lb-1
set J0w=null
set sww=null
set tww=null
set Sww=null
return
endif
if jc-ao[A0w]<=60 then
set Lb=Lb-1
set J0w=null
set sww=null
set tww=null
set Sww=null
return
endif
set N0w=kS[A0w]
set Xb[Lb]="when calling getLastPublicOrder in Revolts, line 21"
set Lb=Lb+1
if qO[N0w]==0 then
if N0w==0 then
call I1("Nullpointer exception when calling City.getLastPublicOrder","when calling error in City, line 335")
else
call I1("Called City.getLastPublicOrder on invalid object.","when calling error in City, line 335")
endif
endif
set M0w=Il[N0w]
set Lb=Lb-1
set www=kS[A0w]
set Xb[Lb]="when calling getPopulation in Revolts, line 22"
set Lb=Lb+1
if qO[www]==0 then
if www==0 then
call I1("Nullpointer exception when calling City.getPopulation","when calling error in City, line 344")
else
call I1("Called City.getPopulation on invalid object.","when calling error in City, line 344")
endif
endif
set uww=El[www]
set Lb=Lb-1
set H0w=uww
set rww=kS[A0w]
set Xb[Lb]="when calling getCityUnit in Revolts, line 23"
set Lb=Lb+1
if qO[rww]==0 then
if rww==0 then
call I1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call I1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set sww=kl[rww]
set Lb=Lb-1
set J0w=sww
set tww=GetOwningPlayer(sww)
if GetPlayerSlotState(tww)==PLAYER_SLOT_STATE_PLAYING then
set pww=GetPlayerController(tww)==MAP_CONTROL_USER
else
set pww=false
endif
if not pww then
set Lb=Lb-1
set J0w=null
set sww=null
set tww=null
set Sww=null
return
endif
if M0w<50.0 then
set ao[A0w]=jc
set iww_2=kS[A0w]
set Xb[Lb]="when calling addModifier in Revolts, line 28"
set Lb=Lb+1
if qO[iww_2]==0 then
if iww_2==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(iww_2,1,"when calling addModifier in City, line 365")
set Lb=Lb-1
set D0w="A violent mob has appeared near the gates of "+gaw(kS[A0w],"when calling getCityNameColored in Revolts, line 29")+"!"
set Sww=GetOwningPlayer(sww)
set Xb[Lb]="when calling attentionToPlayer in Revolts, line 29"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Sww,0.,0.,10.0,a5(Sww,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Sww,0.,0.,10.0,D0w)
set Lb=Lb-1
if M0w>=30.0 then
set cww=uO[0]
set Xb[Lb]="when calling iterator in Revolts, line 32"
set Lb=Lb+1
set oww=dbw(cww,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set K0w=oww
loop
exitwhen Tb[Gb[K0w]]==Yb[K0w]
set Gb[K0w]=Tb[Gb[K0w]]
set L0w=fb[Gb[K0w]]
call CreateUnit(ro[PLAYER_NEUTRAL_AGGRESSIVE],L0w,GetUnitX(J0w),GetUnitY(J0w),0.)
if GetRandomReal(0.0,1.0)<=H0w*1./150000 then
call CreateUnit(ro[PLAYER_NEUTRAL_AGGRESSIVE],L0w,GetUnitX(J0w),GetUnitY(J0w),0.)
endif
endloop
set Xb[Lb]="when calling close in Revolts, line 32"
set Lb=Lb+1
if hb[K0w]then
call edw(K0w,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
elseif M0w>=15.0 then
set Oww=uO[1]
set Xb[Lb]="when calling iterator in Revolts, line 38"
set Lb=Lb+1
set lww=dbw(Oww,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set X0w=lww
loop
exitwhen Tb[Gb[X0w]]==Yb[X0w]
set Gb[X0w]=Tb[Gb[X0w]]
set C0w=fb[Gb[X0w]]
call CreateUnit(ro[PLAYER_NEUTRAL_AGGRESSIVE],C0w,GetUnitX(J0w),GetUnitY(J0w),0.)
if GetRandomReal(0.0,1.0)<=H0w*1./150000 then
call CreateUnit(ro[PLAYER_NEUTRAL_AGGRESSIVE],C0w,GetUnitX(J0w),GetUnitY(J0w),0.)
endif
endloop
set Xb[Lb]="when calling close in Revolts, line 38"
set Lb=Lb+1
if hb[X0w]then
call edw(X0w,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
else
set bww=uO[2]
set Xb[Lb]="when calling iterator in Revolts, line 44"
set Lb=Lb+1
set yww=dbw(bww,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set V0w=yww
loop
exitwhen Tb[Gb[V0w]]==Yb[V0w]
set Gb[V0w]=Tb[Gb[V0w]]
set B0w=fb[Gb[V0w]]
call CreateUnit(ro[PLAYER_NEUTRAL_AGGRESSIVE],B0w,GetUnitX(J0w),GetUnitY(J0w),0.)
if GetRandomReal(0.0,1.0)<=H0w*1./150000 then
call CreateUnit(ro[PLAYER_NEUTRAL_AGGRESSIVE],B0w,GetUnitX(J0w),GetUnitY(J0w),0.)
endif
endloop
set Xb[Lb]="when calling close in Revolts, line 44"
set Lb=Lb+1
if hb[V0w]then
call edw(V0w,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
endif
endif
set Lb=Lb-1
set J0w=null
set sww=null
set tww=null
set Sww=null
endfunction
function Riw takes integer biw,string yiw returns real
local integer piw
local integer eiw
local boolean qiw
local real aiw
local real niw
local real diw
local real fiw
set Xb[Lb]=yiw
set Lb=Lb+1
set Il[biw]=100.0-Ul[biw]*1000.-SquareRoot(El[biw]*1.)/17.+Pl[biw]-El[biw]*1./1000*hS[Dl[biw]]
set aiw=Ql[biw]
set niw=Wl[biw]
set Xb[Lb]="when calling alloc_City_City_ForGroupCallback_line313 in City, line 313"
set Lb=Lb+1
if nO==0 then
if dO<32768 then
set dO=dO+1
set piw=dO
set fO[piw]=688
else
call I1("Out of memory: Could not create City_City_ForGroupCallback_line313.","when calling error in City, line 313")
set piw=0
endif
else
set nO=nO-1
set piw=aO[nO]
set fO[piw]=688
endif
set Lb=Lb-1
set Kl[piw]=biw
call YB(aiw,niw,500,piw,"when calling forUnitsInRange in City, line 313")
set diw=Ql[biw]
set fiw=Wl[biw]
set Xb[Lb]="when calling alloc_City_City_ForGroupCallback_line317 in City, line 317"
set Lb=Lb+1
if nO==0 then
if dO<32768 then
set dO=dO+1
set eiw=dO
set fO[eiw]=689
else
call I1("Out of memory: Could not create City_City_ForGroupCallback_line317.","when calling error in City, line 317")
set eiw=0
endif
else
set nO=nO-1
set eiw=aO[nO]
set fO[eiw]=689
endif
set Lb=Lb-1
set Ll[eiw]=biw
call YB(diw,fiw,1500.0,eiw,"when calling forUnitsInRange in City, line 317")
if Il[biw]<0.0 then
set Il[biw]=0.0
endif
if Il[biw]>100.0 then
set Il[biw]=100.0
endif
if Il[biw]<50.0 then
set qiw=GetRandomReal(0.0,1.0)<=0.01
else
set qiw=false
endif
if qiw then
call eww(xl[biw],"when calling checkForRevolt in City, line 328")
endif
set Lb=Lb-1
return Il[biw]
endfunction
function jiw takes integer Tiw,string Yiw returns string
local real Giw
local integer giw
local integer hiw
local integer Fiw
local integer kiw
set Xb[Lb]=Yiw
set Lb=Lb+1
set Xb[Lb]="when calling countPublicOrder in City, line 339"
set Lb=Lb+1
if qO[Tiw]==0 then
if Tiw==0 then
call I1("Nullpointer exception when calling City.countPublicOrder","when calling error in City, line 308")
else
call I1("Called City.countPublicOrder on invalid object.","when calling error in City, line 308")
endif
endif
set Giw=Riw(Tiw,"when calling countPublicOrder in City, line 308")
set Lb=Lb-1
set Fiw=R2I(255.-Giw/100.*255.)
set kiw=R2I(Giw/100.*255.)
set giw=Fiw/16
set hiw=kiw/16
set Yiw=StringCase("|cff"+NS[giw]+NS[Fiw-giw*16]+NS[hiw]+NS[kiw-hiw*16]+NS[0]+NS[0],false)+I2S(R2I(Giw))+","+I2S(R2I(ModuloReal(R2I(Giw*10.),10)))+"%|r"
set Lb=Lb-1
return Yiw
endfunction
function Z2 takes real E2 returns real
if E2>0. then
return 1.
elseif E2<0. then
return -1.
else
return 0.
endif
endfunction
function jww takes integer Fww returns string
local string kww="|cff15ff00+"
if Z2(Fww*1.)==-1. then
set kww="|cffff0000"
endif
return kww+I2S(Fww)+"|r"
endfunction
function liw takes integer riw,string siw returns integer
local integer tiw
local real iiw
local real Siw
local real ciw
local real oiw
local real Oiw
set Xb[Lb]=siw
set Lb=Lb+1
set tiw=0
set tiw=0+tdw(cS,GetUnitTypeId(kl[riw]),"when calling get in City, line 283")
set Oiw=El[riw]*1.
set Xb[Lb]="when calling countPublicOrder in City, line 295"
set Lb=Lb+1
if qO[riw]==0 then
if riw==0 then
call I1("Nullpointer exception when calling City.countPublicOrder","when calling error in City, line 308")
else
call I1("Called City.countPublicOrder on invalid object.","when calling error in City, line 308")
endif
endif
set oiw=Riw(riw,"when calling countPublicOrder in City, line 308")
set Lb=Lb-1
set iiw=oiw/100.
set Siw=po
if 0.75>Siw then
set ciw=0.75
else
set ciw=Siw
endif
if iiw>ciw then
set ciw=iiw
endif
set tiw=tiw+R2I(SquareRoot(Oiw*ciw)/6.)
set tiw=R2I(tiw*Al[riw]*GS[Dl[riw]])
set Lb=Lb-1
return tiw
endfunction
function miw takes integer xiw returns string
local string viw
if El[xiw]<100000 then
set viw=I2S(R2I(El[xiw]*1./1000))+","+I2S(R2I(ModuloReal(El[xiw],1000)/100.))+"k"
else
set viw=I2S(R2I(El[xiw]*1./1000))+"k"
endif
return viw
endfunction
function u9 takes multiboard K8,integer L8,integer X8,string C8,real V8 returns nothing
local multiboarditem B8=MultiboardGetItem(K8,X8,L8)
local string N8=C8
local integer M8=R2I((R2I(V8/0.004)-StringLength(C8))*1./2)
local string w9=""
set L8=0
set X8=M8-1
loop
exitwhen L8>X8
set w9=w9+" "
set L8=L8+1
endloop
if ModuloReal(M8,2)==1. then
set N8=" "+N8
endif
set N8=w9+N8
call MultiboardSetItemValue(B8,N8)
set B8=null
endfunction
function oew takes integer mpw,string Qpw returns nothing
local integer Wpw
local multiboard Epw
local integer Zpw
local integer Upw
local integer Ipw
local multiboard Ppw
local integer Apw
local integer Dpw
local multiboard Hpw
local integer Jpw
local integer Kpw
local integer Lpw
local integer Xpw
local string Cpw
local integer Vpw
local string Bpw
local integer Npw
local string Mpw
local integer wew
local integer uew
local string rew
local integer sew
local integer tew
local integer iew
local string Sew
local string cew
set Xb[Lb]=Qpw
set Lb=Lb+1
if Ab[mpw]==-1 then
set Lb=Lb-1
set Epw=null
set Ppw=null
set Hpw=null
return
endif
set Wpw=GetPlayerId(Ib[mpw])
call u9(Cc[Wpw],Lc[0],Lc[1],gaw(kS[Ab[mpw]],"when calling getCityNameColored in PlayerStats, line 76"),0.40)
set Jpw=kS[Ab[mpw]]
set Xb[Lb]="when calling countTax in PlayerStats, line 85"
set Lb=Lb+1
if qO[Jpw]==0 then
if Jpw==0 then
call I1("Nullpointer exception when calling City.countTax","when calling error in City, line 279")
else
call I1("Called City.countTax on invalid object.","when calling error in City, line 279")
endif
endif
set Kpw=liw(Jpw,"when calling countTax in City, line 279")
set Lb=Lb-1
set Lpw=kS[Ab[mpw]]
set Xb[Lb]="when calling getTaxLevelString in PlayerStats, line 86"
set Lb=Lb+1
if qO[Lpw]==0 then
if Lpw==0 then
call I1("Nullpointer exception when calling City.getTaxLevelString","when calling error in City, line 176")
else
call I1("Called City.getTaxLevelString on invalid object.","when calling error in City, line 176")
endif
endif
set Qpw=Eo[Dl[Lpw]]
set Lb=Lb-1
set Xpw=kS[Ab[mpw]]
set Xb[Lb]="when calling getPublicOrderStr in PlayerStats, line 87"
set Lb=Lb+1
if qO[Xpw]==0 then
if Xpw==0 then
call I1("Nullpointer exception when calling City.getPublicOrderStr","when calling error in City, line 338")
else
call I1("Called City.getPublicOrderStr on invalid object.","when calling error in City, line 338")
endif
endif
set Cpw=jiw(Xpw,"when calling getPublicOrderStr in City, line 338")
set Lb=Lb-1
set Vpw=kS[Ab[mpw]]
set Xb[Lb]="when calling getPopulationStr in PlayerStats, line 88"
set Lb=Lb+1
if qO[Vpw]==0 then
if Vpw==0 then
call I1("Nullpointer exception when calling City.getPopulationStr","when calling error in City, line 356")
else
call I1("Called City.getPopulationStr on invalid object.","when calling error in City, line 356")
endif
endif
set Bpw=miw(Vpw)
set Lb=Lb-1
set Npw=kS[Ab[mpw]]
set Xb[Lb]="when calling getPopulationGrowthStr in PlayerStats, line 89"
set Lb=Lb+1
if qO[Npw]==0 then
if Npw==0 then
call I1("Nullpointer exception when calling City.getPopulationGrowthStr","when calling error in City, line 353")
else
call I1("Called City.getPopulationGrowthStr on invalid object.","when calling error in City, line 353")
endif
endif
set Mpw=jww(Zl[Npw])
set Lb=Lb-1
set Epw=Cc[Wpw]
set wew=Dc[0]
set uew=Dc[1]
set rew=I2S(Kpw)
call MultiboardSetItemValue(MultiboardGetItem(Epw,uew,wew),rew)
call MultiboardSetItemValue(MultiboardGetItem(Epw,Dc[1],Dc[0]+1),Qpw)
call MultiboardSetItemValue(MultiboardGetItem(Epw,Hc[1],Hc[0]),Cpw)
call MultiboardSetItemValue(MultiboardGetItem(Epw,Jc[1],Jc[0]),Bpw)
call MultiboardSetItemValue(MultiboardGetItem(Epw,Kc[1],Kc[0]),Mpw)
set Zpw=0
set tew=kS[Ab[mpw]]
set Xb[Lb]="when calling getModifiers in PlayerStats, line 99"
set Lb=Lb+1
if qO[tew]==0 then
if tew==0 then
call I1("Nullpointer exception when calling City.getModifiers","when calling error in City, line 386")
else
call I1("Called City.getModifiers on invalid object.","when calling error in City, line 386")
endif
endif
set iew=Jl[tew]
set Lb=Lb-1
set Xb[Lb]="when calling iterator in PlayerStats, line 99"
set Lb=Lb+1
set sew=dbw(iew,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set Upw=sew
loop
exitwhen Tb[Gb[Upw]]==Yb[Upw]
set Gb[Upw]=Tb[Gb[Upw]]
set Ipw=fb[Gb[Upw]]
set Ppw=Cc[Wpw]
set Sew=hl[tdw(dS,Ipw,"when calling get in PlayerStats, line 101")]
call MultiboardSetItemValue(MultiboardGetItem(Ppw,4+Zpw,4),Sew)
set cew="("+Fl[tdw(dS,Ipw,"when calling get in PlayerStats, line 102")]+")"
call MultiboardSetItemValue(MultiboardGetItem(Ppw,4+Zpw,5),cew)
set Zpw=Zpw+1
endloop
set Xb[Lb]="when calling close in PlayerStats, line 99"
set Lb=Lb+1
if hb[Upw]then
call edw(Upw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
set Apw=Zpw
set Dpw=9
loop
exitwhen Apw>Dpw
set Hpw=Cc[Wpw]
call MultiboardSetItemValue(MultiboardGetItem(Hpw,4+Apw,4)," ")
call MultiboardSetItemValue(MultiboardGetItem(Hpw,4+Apw,5)," ")
set Apw=Apw+1
endloop
set Lb=Lb-1
set Epw=null
set Ppw=null
set Hpw=null
endfunction
function Rtw takes integer ptw,string etw returns nothing
local integer qtw
local integer atw
local integer ntw
local integer dtw
local integer ftw
set Xb[Lb]=etw
set Lb=Lb+1
set qtw=0
set atw=23
loop
exitwhen qtw>atw
set ntw=uo[qtw]
set etw="when calling getSelectedCityId in City, line 252"
set Xb[Lb]="when calling getSelectedCityId in City, line 252"
set Lb=Lb+1
if ll[ntw]==0 then
if ntw==0 then
call I1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call I1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set dtw=Ab[ntw]
set Lb=Lb-1
if dtw==xl[ptw]then
set ftw=uo[qtw]
set Xb[Lb]="when calling refreshMultiboardCity in City, line 253"
set Lb=Lb+1
if ll[ftw]==0 then
if ftw==0 then
call I1("Nullpointer exception when calling PlayerStats.refreshMultiboardCity","when calling error in PlayerStats, line 71")
else
call I1("Called PlayerStats.refreshMultiboardCity on invalid object.","when calling error in PlayerStats, line 71")
endif
endif
call oew(ftw,"when calling refreshMultiboardCity in PlayerStats, line 71")
set Lb=Lb-1
endif
set qtw=qtw+1
endloop
set Lb=Lb-1
endfunction
function vtw takes integer htw,integer Ftw,string ktw returns nothing
local integer jtw
local integer xtw
set Xb[Lb]=ktw
set Lb=Lb+1
if Ftw==PLAYER_NEUTRAL_AGGRESSIVE then
call SetUnitOwner(kl[htw],Player(PLAYER_NEUTRAL_AGGRESSIVE),true)
set Xb[Lb]="when calling changeTaxLevelFORCED in City, line 204"
set Lb=Lb+1
if qO[htw]==0 then
if htw==0 then
call I1("Nullpointer exception when calling City.changeTaxLevelFORCED","when calling error in City, line 273")
else
call I1("Called City.changeTaxLevelFORCED on invalid object.","when calling error in City, line 273")
endif
endif
set Pl[htw]=Pl[htw]-gS[Dl[htw]]
set Pl[htw]=Pl[htw]+gS[0]
set Dl[htw]=0
set Lb=Lb-1
else
call SetUnitOwner(kl[htw],ro[Ftw],true)
endif
set ml[htw]=Ftw
if Ftw>=0 and Ftw<24 then
set jtw=uo[Ftw]
set Xb[Lb]="when calling getForceId in City, line 211"
set Lb=Lb+1
if ll[jtw]==0 then
if jtw==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set xtw=Ub[jtw]
set Lb=Lb-1
set vl[htw]=xtw
endif
set Xb[Lb]="when calling refreshMultiboardIfPossible in City, line 213"
set Lb=Lb+1
if qO[htw]==0 then
if htw==0 then
call I1("Nullpointer exception when calling City.refreshMultiboardIfPossible","when calling error in City, line 250")
else
call I1("Called City.refreshMultiboardIfPossible on invalid object.","when calling error in City, line 250")
endif
endif
call Rtw(htw,"when calling refreshMultiboardIfPossible in City, line 250")
set Lb=Lb-1-1
endfunction
function Vtw takes integer Utw,player Itw,string Ptw returns nothing
local integer Atw
local integer Dtw
local unit Htw
local unit Jtw
local real Ktw
local integer Ltw
local integer Xtw
local integer Ctw
set Xb[Lb]=Ptw
set Lb=Lb+1
set Htw=kl[Utw]
call SetUnitState(Htw,UNIT_STATE_LIFE,GetUnitState(Htw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,60.0)*0.01)
set Jtw=kl[Utw]
call SetUnitState(Jtw,UNIT_STATE_MANA,GetUnitState(Jtw,UNIT_STATE_MAX_MANA)*RMaxBJ(0.,30.0)*0.01)
set Xb[Lb]="when calling addModifier in City, line 234"
set Lb=Lb+1
if qO[Utw]==0 then
if Utw==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(Utw,0,"when calling addModifier in City, line 365")
set Lb=Lb-1
set Ktw=Tl[tdw(dS,6,"when calling get in City, line 235")]
if GetRandomReal(0.0,1.0)<=Ktw then
set Xb[Lb]="when calling addModifier in City, line 236"
set Lb=Lb+1
if qO[Utw]==0 then
if Utw==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(Utw,6,"when calling addModifier in City, line 365")
set Lb=Lb-1
endif
set Atw=vl[Utw]
set Dtw=GetPlayerId(Itw)
if Dtw>=0 and Dtw<24 then
set Ltw=uo[Dtw]
set Xb[Lb]="when calling getForceId in City, line 242"
set Lb=Lb+1
if ll[Ltw]==0 then
if Ltw==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set Xtw=Ub[Ltw]
set Lb=Lb-1
set Atw=Xtw
endif
if Dnw(No,GetUnitTypeId(kl[Utw]),"when calling has in City, line 244") then
set Ctw=tV(uV(GetUnitTypeId(kl[Utw])),Atw)
set Xb[Lb]="when calling replaceCity in City, line 245"
set Lb=Lb+1
if qO[Utw]==0 then
if Utw==0 then
call I1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call I1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call gtw(Utw,Ctw,"when calling replaceCity in City, line 194")
set Lb=Lb-1
endif
set Xb[Lb]="when calling changeOwner in City, line 247"
set Lb=Lb+1
if qO[Utw]==0 then
if Utw==0 then
call I1("Nullpointer exception when calling City.changeOwner","when calling error in City, line 199")
else
call I1("Called City.changeOwner on invalid object.","when calling error in City, line 199")
endif
endif
call vtw(Utw,Dtw,"when calling changeOwner in City, line 199")
set Lb=Lb-1
call UnitAddAbility(kl[Utw],1093677634)
set Lb=Lb-1
set Htw=null
set Jtw=null
endfunction
function bV takes unit iV,string SV returns integer
local integer cV
local integer oV
local integer OV
local unit lV
set Xb[Lb]=SV
set Lb=Lb+1
set cV=0
set oV=fS-1
loop
exitwhen cV>oV
set OV=kS[cV]
set SV="when calling getCityUnit in City, line 438"
set Xb[Lb]="when calling getCityUnit in City, line 438"
set Lb=Lb+1
if qO[OV]==0 then
if OV==0 then
call I1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call I1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set lV=kl[OV]
set Lb=Lb-1
if lV==iV then
set Lb=Lb-1
set lV=null
return cV
endif
set cV=cV+1
endloop
set Lb=Lb-1
set lV=null
return -1
endfunction
function k5 takes string f5,force R5,string T5 returns nothing
local integer Y5
local integer G5
local player g5
local player h5
local force F5
set Xb[Lb]=T5
set Lb=Lb+1
set Y5=0
set G5=23
loop
exitwhen Y5>G5
set h5=ro[Y5]
set F5=CreateForce()
call ForceAddPlayer(F5,h5)
if F5==R5 then
set g5=ro[Y5]
call DisplayTimedTextToPlayer(g5,0.,0.,10.0,a5(g5,"when calling getAttentionStringForPlayer in Messages, line 116"))
call DisplayTimedTextToPlayer(g5,0.,0.,10.0,f5)
endif
set Y5=Y5+1
endloop
set Lb=Lb-1
set g5=null
set h5=null
set F5=null
endfunction
function Ksw takes integer msw,string Qsw returns nothing
local unit Wsw
local boolean Esw
local unit Zsw
local integer Usw
local player Isw
local boolean Psw
local real Asw
local real Dsw
local real Hsw
local real Jsw
set Xb[Lb]=Qsw
set Lb=Lb+1
set Wsw=GetTriggerUnit()
set Xb[Lb]="when calling isCity in CityManage, line 37"
set Lb=Lb+1
set Xb[Lb]="when calling isCity in UnitTools, line 5"
set Lb=Lb+1
set Esw=Dnw(wO,GetUnitTypeId(Wsw),"when calling has in City, line 432")
set Lb=Lb-1-1
if Esw then
if GetUnitStatePercent(Wsw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=50.0 then
set Psw=GetOwningPlayer(Wsw)!=GetOwningPlayer(GetAttacker())
else
set Psw=false
endif
if Psw then
set Asw=GetUnitX(Wsw)
set Dsw=GetUnitY(Wsw)
set Zsw=GetAttacker()
set Hsw=Asw-GetUnitX(Zsw)
set Jsw=Dsw-GetUnitY(Zsw)
if SquareRoot(Hsw*Hsw+Jsw*Jsw)>300.0 then
call SetUnitState(Wsw,UNIT_STATE_LIFE,GetUnitState(Wsw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,50.0)*0.01)
else
set Xb[Lb]="when calling getCityId in CityManage, line 42"
set Lb=Lb+1
set msw=bV(Wsw,"when calling getCityId in UnitTools, line 9")
set Lb=Lb-1
if Dnw(No,GetUnitTypeId(Wsw),"when calling has in CityManage, line 44") then
call k5(HB(GetOwningPlayer(GetAttacker()))+" has just captured "+HB(GetOwningPlayer(GetTriggerUnit()))+" Capitol!",bj_FORCE_ALL_PLAYERS,"when calling attentionToForce in CityManage, line 45")
endif
set Usw=kS[msw]
set Isw=GetOwningPlayer(GetAttacker())
set Xb[Lb]="when calling capture in CityManage, line 46"
set Lb=Lb+1
if qO[Usw]==0 then
if Usw==0 then
call I1("Nullpointer exception when calling City.capture","when calling error in City, line 230")
else
call I1("Called City.capture on invalid object.","when calling error in City, line 230")
endif
endif
call Vtw(Usw,Isw,"when calling capture in City, line 230")
set Lb=Lb-1
endif
elseif GetUnitStatePercent(Wsw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=50.0 then
call SetUnitState(Wsw,UNIT_STATE_LIFE,GetUnitState(Wsw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,50.0)*0.01)
endif
endif
set Lb=Lb-1
set Wsw=null
set Zsw=null
set Isw=null
endfunction
function Xnw takes integer Hnw,integer Jnw,string Knw returns boolean
local boolean Lnw
set Xb[Lb]=Knw
set Lb=Lb+1
if HO[Hnw]==0 then
if Hnw==0 then
call I1("Nullpointer exception when calling HashMap.has","when calling error in HashMap, line 13")
else
call I1("Called HashMap.has on invalid object.","when calling error in HashMap, line 13")
endif
endif
set Xb[Lb]="when calling has in HashMap, line 13"
set Lb=Lb+1
set Xb[Lb]="when calling hasInt in HashMap, line 14"
set Lb=Lb+1
if HO[Hnw]==0 then
if Hnw==0 then
call I1("Nullpointer exception when calling Table.hasInt","when calling error in Table, line 9")
else
call I1("Called Table.hasInt on invalid object.","when calling error in Table, line 9")
endif
endif
set Lnw=HaveSavedInteger(Zo,Hnw,Jnw)
set Lb=Lb-1-1-1
return Lnw
endfunction
function Slw takes integer rlw,integer slw,integer tlw,string ilw returns nothing
set Xb[Lb]=ilw
set Lb=Lb+1
if not Xnw(rlw,slw,"when calling has in HashMap, line 18") then
set qb[rlw]=qb[rlw]+1
endif
set Xb[Lb]="when calling saveInt in HashMap, line 20"
set Lb=Lb+1
if HO[rlw]==0 then
if rlw==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,rlw,slw,tlw)
set Lb=Lb-1-1
endfunction
function UOw takes integer mOw,integer QOw,string WOw returns nothing
local hashtable EOw
local integer ZOw
set Xb[Lb]=WOw
set Lb=Lb+1
set EOw=Rc
set Xb[Lb]="when calling count in HashList, line 19"
set Lb=Lb+1
if IO[mOw]==0 then
if mOw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ZOw=LoadInteger(Rc,mOw,QOw)
set Lb=Lb-1
call SaveInteger(EOw,mOw,QOw,ZOw+1)
set Lb=Lb-1
set EOw=null
endfunction
function Qjw takes integer xjw,integer vjw,string mjw returns nothing
set Xb[Lb]=mjw
set Lb=Lb+1
call SaveInteger(fc,xjw,eb[xjw],vjw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[xjw]==0 then
if xjw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(xjw,vjw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[xjw]=eb[xjw]+1
set Lb=Lb-1
endfunction
function jjw takes integer Yjw,integer Gjw,string gjw returns nothing
local integer hjw
local hashtable Fjw
local integer kjw
set Xb[Lb]=gjw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Yjw]==0 then
if Yjw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set hjw=LoadInteger(Rc,Yjw,Gjw)
set Lb=Lb-1
if hjw<=0 then
set Fjw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Yjw]==0 then
if Yjw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set kjw=eb[Yjw]
set Lb=Lb-1
call SaveInteger(Fjw,Yjw,Gjw,kjw)
call Qjw(Yjw,Gjw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set Fjw=null
endfunction
function Ujw takes integer Wjw,integer Ejw,string Zjw returns nothing
set Xb[Lb]=Zjw
set Lb=Lb+1
if IO[Wjw]==0 then
if Wjw==0 then
call I1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call I1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if IO[Wjw]<=695 then
call Qjw(Wjw,Ejw,"when calling add in HashList, line 25")
else
call jjw(Wjw,Ejw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function flw takes integer elw,integer qlw,integer alw,string nlw returns nothing
local boolean dlw
set Xb[Lb]=nlw
set Lb=Lb+1
call Slw(elw,qlw,alw,"when calling put in HashMap, line 60")
set Xb[Lb]="when calling hasKey in HashMap, line 61"
set Lb=Lb+1
if HO[elw]==0 then
if elw==0 then
call I1("Nullpointer exception when calling IterableMap.hasKey","when calling error in HashMap, line 87")
else
call I1("Called IterableMap.hasKey on invalid object.","when calling error in HashMap, line 87")
endif
endif
set Xb[Lb]="when calling hasKey in HashMap, line 87"
set Lb=Lb+1
set dlw=Dnw(ab[elw],qlw,"when calling has in HashMap, line 88")
set Lb=Lb-1-1
if not dlw then
call Ujw(ab[elw],qlw,"when calling add in HashMap, line 62")
endif
set Lb=Lb-1
endfunction
function Mnw takes integer Cnw,integer Vnw,integer Bnw,string Nnw returns nothing
set Xb[Lb]=Nnw
set Lb=Lb+1
if HO[Cnw]==0 then
if Cnw==0 then
call I1("Nullpointer exception when calling HashMap.put","when calling error in HashMap, line 17")
else
call I1("Called HashMap.put on invalid object.","when calling error in HashMap, line 17")
endif
endif
if HO[Cnw]<=732 then
call Slw(Cnw,Vnw,Bnw,"when calling put in HashMap, line 17")
else
call flw(Cnw,Vnw,Bnw,"when calling put in HashMap, line 17")
endif
set Lb=Lb-1
endfunction
function Zbw takes string Wbw returns integer
local integer Ebw
set Xb[Lb]=Wbw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_LinkedList in LinkedList, line 31"
set Lb=Lb+1
if rl==0 then
if sl<32768 then
set sl=sl+1
set Ebw=sl
set tl[Ebw]=706
else
call I1("Out of memory: Could not create LinkedList.","when calling error in LinkedList, line 17")
set Ebw=0
endif
else
set rl=rl-1
set Ebw=ul[rl]
set tl[Ebw]=706
endif
set Lb=Lb-1
set Xb[Lb]="when calling construct_LinkedList2 in LinkedList, line 31"
set Lb=Lb+1
set Fb[Ebw]=ebw(0,0,0,"when calling new_LLEntry in LinkedList, line 18")
set kb[Ebw]=0
set Tb[Fb[Ebw]]=Fb[Ebw]
set Rb[Fb[Ebw]]=Fb[Ebw]
set Lb=Lb-1-1
return Ebw
endfunction
function kdw takes integer Rdw,integer Tdw,string Ydw returns integer
local integer Gdw
local integer gdw
local integer hdw
local integer Fdw
set Xb[Lb]=Ydw
set Lb=Lb+1
if tl[Rdw]==0 then
if Rdw==0 then
call I1("Nullpointer exception when calling LinkedList.get","when calling error in LinkedList, line 50")
else
call I1("Called LinkedList.get on invalid object.","when calling error in LinkedList, line 50")
endif
endif
set Xb[Lb]="when calling get in LinkedList, line 50"
set Lb=Lb+1
set Xb[Lb]="when calling getEntry in LinkedList, line 51"
set Lb=Lb+1
if tl[Rdw]==0 then
if Rdw==0 then
call I1("Nullpointer exception when calling LinkedList.getEntry","when calling error in LinkedList, line 366")
else
call I1("Called LinkedList.getEntry on invalid object.","when calling error in LinkedList, line 366")
endif
endif
set gdw=Fb[Rdw]
set hdw=0
set Fdw=Tdw
loop
exitwhen hdw>Fdw
set gdw=Tb[gdw]
set hdw=hdw+1
endloop
set Lb=Lb-1
set Gdw=fb[gdw]
set Lb=Lb-1-1
return Gdw
endfunction
function Lbw takes integer Ubw,string Ibw returns nothing
local integer Pbw
local unit Abw
local player Dbw
local real Hbw
local real Jbw
local real Kbw
set Xb[Lb]=Ibw
set Lb=Lb+1
if GetSpellAbilityId()==1093678154 then
set Pbw=Zbw("when calling new_LinkedList in MassControl, line 24")
set Abw=GetSpellAbilityUnit()
set Dbw=GetOwningPlayer(Abw)
set Jbw=GetSpellTargetX()
set Kbw=GetSpellTargetY()
set Hbw=kdw(Zc,GetLearnedSkillLevel(),"when calling get in MassControl, line 27")/1000.
set Xb[Lb]="when calling alloc_MassControl_ForGroupCallback_line27 in MassControl, line 27"
set Lb=Lb+1
if nO==0 then
if dO<32768 then
set dO=dO+1
set Ubw=dO
set fO[Ubw]=691
else
call I1("Out of memory: Could not create MassControl_ForGroupCallback_line27.","when calling error in MassControl, line 27")
set Ubw=0
endif
else
set nO=nO-1
set Ubw=aO[nO]
set fO[Ubw]=691
endif
set Lb=Lb-1
set jb[Ubw]=Dbw
set xb[Ubw]=Abw
set vb[Ubw]=Pbw
call YB(Jbw,Kbw,Hbw,Ubw,"when calling forUnitsInRange in MassControl, line 27")
call Mnw(Ec,GetHandleId(Abw),Pbw,"when calling put in MassControl, line 30")
endif
set Lb=Lb-1
set Abw=null
set Dbw=null
endfunction
function Mqw takes integer Iqw,string Pqw returns nothing
local unit Aqw
local unit Dqw
local integer Hqw
local player Jqw
local integer Kqw
local integer Lqw
local player Xqw
local integer Cqw
local integer Vqw
local boolean Bqw
local boolean Nqw
set Xb[Lb]=Pqw
set Lb=Lb+1
if GetSpellAbilityId()==1093677620 then
set Aqw=GetSpellAbilityUnit()
set Dqw=GetSpellTargetUnit()
set Hqw=GetPlayerId(GetOwningPlayer(Aqw))
set Iqw=GetPlayerId(GetOwningPlayer(Dqw))
set Jqw=ro[Hqw]
if GetPlayerSlotState(Jqw)==PLAYER_SLOT_STATE_PLAYING then
set Bqw=GetPlayerController(Jqw)==MAP_CONTROL_USER
else
set Bqw=false
endif
if Bqw then
set Kqw=uo[Hqw]
set Lqw=-GetUnitLevel(Dqw)
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 17"
set Lb=Lb+1
if ll[Kqw]==0 then
if Kqw==0 then
call I1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call I1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[Kqw]=Db[Kqw]+Lqw
set Lb=Lb-1
endif
set Xqw=ro[Iqw]
if GetPlayerSlotState(Xqw)==PLAYER_SLOT_STATE_PLAYING then
set Nqw=GetPlayerController(Xqw)==MAP_CONTROL_USER
else
set Nqw=false
endif
if Nqw then
set Cqw=uo[Iqw]
set Vqw=GetUnitLevel(Dqw)
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 19"
set Lb=Lb+1
if ll[Cqw]==0 then
if Cqw==0 then
call I1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call I1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[Cqw]=Db[Cqw]+Vqw
set Lb=Lb-1
endif
endif
set Lb=Lb-1
set Aqw=null
set Dqw=null
set Jqw=null
set Xqw=null
endfunction
function Opw takes integer tpw,string ipw returns nothing
local unit Spw
local integer cpw
local boolean opw
set Xb[Lb]=ipw
set Lb=Lb+1
set cpw=Xo
set tpw=GetUnitTypeId(GetDyingUnit())
set Xb[Lb]="when calling has in OreCapture, line 10"
set Lb=Lb+1
if tl[cpw]==0 then
if cpw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set opw=kbw(cpw,tpw)
set Lb=Lb-1
if opw then
set Spw=GetTriggerUnit()
call CreateUnitAtLoc(GetOwningPlayer(Spw),GetUnitTypeId(Spw),GetUnitLoc(Spw),bj_UNIT_FACING)
endif
set Lb=Lb-1
set Spw=null
endfunction
function Hww takes integer Zww,string Uww returns rect
local integer Iww
local fogstate Pww
local integer Aww
local rect Dww
set Xb[Lb]=Uww
set Lb=Lb+1
set Iww=Ao
set Pww=ConvertFogState(Zww)
set Xb[Lb]="when calling saveFogState in TypeCasting, line 136"
set Lb=Lb+1
if HO[Iww]==0 then
if Iww==0 then
call I1("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call I1("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call SaveFogStateHandle(Zo,Iww,0,Pww)
set Lb=Lb-1
set Aww=Ao
set Xb[Lb]="when calling loadRect in TypeCasting, line 137"
set Lb=Lb+1
if HO[Aww]==0 then
if Aww==0 then
call I1("Nullpointer exception when calling Table.loadRect","when calling error in Table, line 147")
else
call I1("Called Table.loadRect on invalid object.","when calling error in Table, line 147")
endif
endif
set Dww=LoadRectHandle(Zo,Aww,0)
set Lb=Lb-1-1
set yR=Dww
set Pww=null
set Dww=null
return yR
endfunction
function g0w takes rect d0w,real f0w,real R0w returns boolean
local boolean T0w
local boolean Y0w
local boolean G0w
if f0w>GetRectMinX(d0w) then
set T0w=f0w<GetRectMaxX(d0w)
else
set T0w=false
endif
if T0w then
set Y0w=R0w>GetRectMinY(d0w)
else
set Y0w=false
endif
if Y0w then
set G0w=R0w<GetRectMaxY(d0w)
else
set G0w=false
endif
return G0w
endfunction
function Pyw takes integer jyw,string xyw returns nothing
local unit vyw
local real myw
local real Qyw
local integer Wyw
local integer Eyw
local integer Zyw
local timer Uyw
local player Iyw
set Xb[Lb]=xyw
set Lb=Lb+1
set vyw=GetTriggerUnit()
if GetUnitTypeId(vyw)==1747988569 then
set myw=GetUnitX(vyw)
set Qyw=GetUnitY(vyw)
set Eyw=rO
set Xb[Lb]="when calling iterator in NoShipsNearRivers, line 11"
set Lb=Lb+1
set Zyw=dbw(Eyw,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set Wyw=Zyw
loop
exitwhen Tb[Gb[Wyw]]==Yb[Wyw]
set Gb[Wyw]=Tb[Gb[Wyw]]
if g0w(Hww(fb[Gb[Wyw]],"when calling rectFromIndex in NoShipsNearRivers, line 11"),myw,Qyw) then
set xyw="when calling alloc_NoShipsNearRivers_CallbackSingle_line14 in NoShipsNearRivers, line 14"
set Xb[Lb]="when calling alloc_NoShipsNearRivers_CallbackSingle_line14 in NoShipsNearRivers, line 14"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set jyw=YO
set GO[jyw]=650
else
call I1("Out of memory: Could not create NoShipsNearRivers_CallbackSingle_line14.","when calling error in NoShipsNearRivers, line 14")
set jyw=0
endif
else
set TO=TO-1
set jyw=RO[TO]
set GO[jyw]=650
endif
set Lb=Lb-1
set Zb[jyw]=vyw
set Xb[Lb]="when calling doAfter in NoShipsNearRivers, line 14"
set Lb=Lb+1
set Uyw=iww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call fnw(jyw,Uyw,0.01,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1
set Iyw=GetOwningPlayer(vyw)
set Xb[Lb]="when calling attentionToPlayer in NoShipsNearRivers, line 16"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Iyw,0.,0.,10.0,a5(Iyw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Iyw,0.,0.,10.0,"You cannot build shipyards near rivers")
set Lb=Lb-1
endif
endloop
set Xb[Lb]="when calling close in NoShipsNearRivers, line 11"
set Lb=Lb+1
if hb[Wyw]then
call edw(Wyw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
endif
set Lb=Lb-1
set vyw=null
set Uyw=null
set Iyw=null
endfunction
function JOw takes integer IOw,integer POw,string AOw returns nothing
local hashtable DOw
local integer HOw
set Xb[Lb]=AOw
set Lb=Lb+1
set DOw=Rc
set Xb[Lb]="when calling count in HashList, line 22"
set Lb=Lb+1
if IO[IOw]==0 then
if IOw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set HOw=LoadInteger(Rc,IOw,POw)
set Lb=Lb-1
call SaveInteger(DOw,IOw,POw,HOw-1)
set Lb=Lb-1
set DOw=null
endfunction
function NOw takes integer KOw,integer LOw,string XOw returns nothing
local integer COw
local integer VOw
local integer BOw
set Xb[Lb]=XOw
set Lb=Lb+1
set BOw=LoadInteger(fc,KOw,LOw)
set Xb[Lb]="when calling decrOccurences in HashList, line 54"
set Lb=Lb+1
if IO[KOw]==0 then
if KOw==0 then
call I1("Nullpointer exception when calling HashList.decrOccurences","when calling error in HashList, line 21")
else
call I1("Called HashList.decrOccurences on invalid object.","when calling error in HashList, line 21")
endif
endif
call JOw(KOw,BOw,"when calling decrOccurences in HashList, line 21")
set Lb=Lb-1
set COw=LOw
set VOw=eb[KOw]
loop
exitwhen COw>VOw
call SaveInteger(fc,KOw,COw,LoadInteger(fc,KOw,COw+1))
set COw=COw+1
endloop
set eb[KOw]=eb[KOw]-1
set Lb=Lb-1
endfunction
function Ilw takes integer hlw,integer Flw,string klw returns nothing
local integer jlw
local integer xlw
local hashtable vlw
local integer mlw
local integer Qlw
local hashtable Wlw
local integer Elw
local hashtable Zlw
local integer Ulw
set Xb[Lb]=klw
set Lb=Lb+1
set vlw=Tc
set Xb[Lb]="when calling get in HashSet, line 22"
set Lb=Lb+1
if IO[hlw]==0 then
if hlw==0 then
call I1("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call I1("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set mlw=LoadInteger(fc,hlw,Flw)
set Lb=Lb-1
call RemoveSavedInteger(vlw,hlw,mlw)
set jlw=Flw+1
set Xb[Lb]="when calling size in HashSet, line 23"
set Lb=Lb+1
if IO[hlw]==0 then
if hlw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Qlw=eb[hlw]
set Lb=Lb-1
set xlw=Qlw
loop
exitwhen jlw>xlw
set Wlw=Tc
set Xb[Lb]="when calling get in HashSet, line 24"
set Lb=Lb+1
if IO[hlw]==0 then
if hlw==0 then
call I1("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call I1("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set Elw=LoadInteger(fc,hlw,jlw)
set Lb=Lb-1
set Zlw=Tc
set klw="when calling get in HashSet, line 24"
set Xb[Lb]="when calling get in HashSet, line 24"
set Lb=Lb+1
if IO[hlw]==0 then
if hlw==0 then
call I1("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call I1("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set Ulw=LoadInteger(fc,hlw,jlw)
set Lb=Lb-1
call SaveInteger(Wlw,hlw,Elw,LoadInteger(Zlw,hlw,Ulw)-1)
set jlw=jlw+1
endloop
call NOw(hlw,Flw,"when calling removeAt in HashSet, line 25")
set Lb=Lb-1
set vlw=null
set Wlw=null
set Zlw=null
endfunction
function Klw takes integer Plw,integer Alw,string Dlw returns nothing
local integer Hlw
local integer Jlw
set Xb[Lb]=Dlw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 17"
set Lb=Lb+1
if IO[Plw]==0 then
if Plw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Hlw=LoadInteger(Rc,Plw,Alw)
set Lb=Lb-1
if Hlw>0 then
set Jlw=LoadInteger(Tc,Plw,Alw)
set Xb[Lb]="when calling removeAt in HashSet, line 18"
set Lb=Lb+1
if IO[Plw]==0 then
if Plw==0 then
call I1("Nullpointer exception when calling HashSet.removeAt","when calling error in HashSet, line 21")
else
call I1("Called HashSet.removeAt on invalid object.","when calling error in HashSet, line 21")
endif
endif
call Ilw(Plw,Jlw,"when calling removeAt in HashSet, line 21")
set Lb=Lb-1
endif
set Lb=Lb-1
endfunction
function Vyw takes integer Ayw,string Dyw returns nothing
local unit Hyw
local integer Jyw
local integer Kyw
local integer Lyw
local boolean Xyw
local boolean Cyw
set Xb[Lb]=Dyw
set Lb=Lb+1
set Hyw=GetOrderedUnit()
if GetIssuedOrderId()==852056 then
set Xyw=GetUnitAbilityLevel(Hyw,1093677904)>0
else
set Xyw=false
endif
if Xyw then
call UnitRemoveAbility(Hyw,1093677904)
set Ayw=Vc
set Jyw=GetHandleId(Hyw)
set Xb[Lb]="when calling add in NoStarvationOnBoat, line 14"
set Lb=Lb+1
if IO[Ayw]==0 then
if Ayw==0 then
call I1("Nullpointer exception when calling HashSet.add","when calling error in HashSet, line 9")
else
call I1("Called HashSet.add on invalid object.","when calling error in HashSet, line 9")
endif
endif
call jjw(Ayw,Jyw,"when calling add in HashSet, line 9")
set Lb=Lb-1
endif
if GetIssuedOrderId()==851972 then
set Cyw=Dnw(Vc,GetHandleId(Hyw),"when calling has in NoStarvationOnBoat, line 16")
else
set Cyw=false
endif
if Cyw then
call UnitAddAbility(GetOrderedUnit(),1093677904)
set Kyw=Vc
set Lyw=GetHandleId(Hyw)
set Xb[Lb]="when calling remove in NoStarvationOnBoat, line 18"
set Lb=Lb+1
if IO[Kyw]==0 then
if Kyw==0 then
call I1("Nullpointer exception when calling HashSet.remove","when calling error in HashSet, line 16")
else
call I1("Called HashSet.remove on invalid object.","when calling error in HashSet, line 16")
endif
endif
call Klw(Kyw,Lyw,"when calling remove in HashSet, line 16")
set Lb=Lb-1
endif
set Lb=Lb-1
set Hyw=null
endfunction
function baw takes integer waw,string uaw returns nothing
local unit raw
local integer saw
local integer taw
local player iaw
local boolean Saw
local integer caw
local integer oaw
local integer Oaw
local boolean law
set Xb[Lb]=uaw
set Lb=Lb+1
set raw=GetDyingUnit()
set saw=GetPlayerId(GetOwningPlayer(raw))
set iaw=ro[saw]
if GetPlayerSlotState(iaw)==PLAYER_SLOT_STATE_PLAYING then
set law=GetPlayerController(iaw)==MAP_CONTROL_USER
else
set law=false
endif
if law and(not IsUnitType(raw,UNIT_TYPE_STRUCTURE)) then
set taw=GetUnitTypeId(raw)
set waw=Lo
set Xb[Lb]="when calling has in Upkeep, line 39"
set Lb=Lb+1
if tl[waw]==0 then
if waw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Saw=kbw(waw,taw)
set Lb=Lb-1
if Saw then
set caw=uo[saw]
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 40"
set Lb=Lb+1
if ll[caw]==0 then
if caw==0 then
call I1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call I1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[caw]=Db[caw]+10
set Lb=Lb-1
else
set oaw=uo[saw]
set Oaw=GetUnitLevel(raw)
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 42"
set Lb=Lb+1
if ll[oaw]==0 then
if oaw==0 then
call I1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call I1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[oaw]=Db[oaw]+Oaw
set Lb=Lb-1
endif
endif
set Lb=Lb-1
set raw=null
set iaw=null
endfunction
function kww takes integer Tww,string Yww returns unit
local integer Gww
local fogstate gww
local integer hww
local unit Fww
set Xb[Lb]=Yww
set Lb=Lb+1
set Gww=Ao
set gww=ConvertFogState(Tww)
set Xb[Lb]="when calling saveFogState in TypeCasting, line 52"
set Lb=Lb+1
if HO[Gww]==0 then
if Gww==0 then
call I1("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call I1("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call SaveFogStateHandle(Zo,Gww,0,gww)
set Lb=Lb-1
set hww=Ao
set Xb[Lb]="when calling loadUnit in TypeCasting, line 53"
set Lb=Lb+1
if HO[hww]==0 then
if hww==0 then
call I1("Nullpointer exception when calling Table.loadUnit","when calling error in Table, line 75")
else
call I1("Called Table.loadUnit on invalid object.","when calling error in Table, line 75")
endif
endif
set Fww=LoadUnitHandle(Zo,hww,0)
set Lb=Lb-1-1
set lR=Fww
set gww=null
set Fww=null
return lR
endfunction
function knw takes integer gnw,integer hnw,string Fnw returns nothing
set Xb[Lb]=Fnw
set Lb=Lb+1
if IO[gnw]==0 then
if gnw==0 then
call I1("Nullpointer exception when calling HashList.removeAt","when calling error in HashList, line 53")
else
call I1("Called HashList.removeAt on invalid object.","when calling error in HashList, line 53")
endif
endif
if IO[gnw]<=695 then
call NOw(gnw,hnw,"when calling removeAt in HashList, line 53")
else
call Ilw(gnw,hnw,"when calling removeAt in HashList, line 53")
endif
set Lb=Lb-1
endfunction
function Znw takes integer jnw,integer xnw,string vnw returns nothing
local integer mnw
local integer Qnw
local integer Wnw
local integer Enw
set Xb[Lb]=vnw
set Lb=Lb+1
if IO[jnw]==0 then
if jnw==0 then
call I1("Nullpointer exception when calling HashList.remove","when calling error in HashList, line 60")
else
call I1("Called HashList.remove on invalid object.","when calling error in HashList, line 60")
endif
endif
if IO[jnw]<=695 then
set mnw=jnw
set Qnw=xnw
set Xb[Lb]="when calling remove in HashList, line 60"
set Lb=Lb+1
set Wnw=0
set Enw=eb[jnw]-1
loop
exitwhen Wnw>Enw
if Qnw==LoadInteger(fc,mnw,Wnw) then
call knw(mnw,Wnw,"when calling removeAt in HashList, line 63")
exitwhen true
endif
set Wnw=Wnw+1
endloop
set Lb=Lb-1
else
call Klw(jnw,xnw,"when calling remove in HashList, line 60")
endif
set Lb=Lb-1
endfunction
function llw takes integer clw,integer olw,string Olw returns nothing
set Xb[Lb]=Olw
set Lb=Lb+1
if Xnw(clw,olw,"when calling has in HashMap, line 28") then
set qb[clw]=qb[clw]-1
endif
set Xb[Lb]="when calling removeInt in HashMap, line 30"
set Lb=Lb+1
if HO[clw]==0 then
if clw==0 then
call I1("Nullpointer exception when calling Table.removeInt","when calling error in Table, line 24")
else
call I1("Called Table.removeInt on invalid object.","when calling error in Table, line 24")
endif
endif
call RemoveSavedInteger(Zo,clw,olw)
set Lb=Lb-1-1
endfunction
function glw takes integer Rlw,integer Tlw,string Ylw returns nothing
local boolean Glw
set Xb[Lb]=Ylw
set Lb=Lb+1
call llw(Rlw,Tlw,"when calling remove in HashMap, line 66")
set Xb[Lb]="when calling hasKey in HashMap, line 67"
set Lb=Lb+1
if HO[Rlw]==0 then
if Rlw==0 then
call I1("Nullpointer exception when calling IterableMap.hasKey","when calling error in HashMap, line 87")
else
call I1("Called IterableMap.hasKey on invalid object.","when calling error in HashMap, line 87")
endif
endif
set Xb[Lb]="when calling hasKey in HashMap, line 87"
set Lb=Lb+1
set Glw=Dnw(ab[Rlw],Tlw,"when calling has in HashMap, line 88")
set Lb=Lb-1-1
if Glw then
call Znw(ab[Rlw],Tlw,"when calling remove in HashMap, line 68")
endif
set Lb=Lb-1
endfunction
function odw takes integer idw,integer Sdw,string cdw returns nothing
set Xb[Lb]=cdw
set Lb=Lb+1
if HO[idw]==0 then
if idw==0 then
call I1("Nullpointer exception when calling HashMap.remove","when calling error in HashMap, line 27")
else
call I1("Called HashMap.remove on invalid object.","when calling error in HashMap, line 27")
endif
endif
if HO[idw]<=732 then
call llw(idw,Sdw,"when calling remove in HashMap, line 27")
else
call glw(idw,Sdw,"when calling remove in HashMap, line 27")
endif
set Lb=Lb-1
endfunction
function byw takes integer Mbw,string wyw returns nothing
local integer uyw
local integer ryw
local real syw
local real tyw
local integer iyw
local unit Syw
local integer cyw
local integer oyw
local boolean Oyw
local integer lyw
set Xb[Lb]=wyw
set Lb=Lb+1
set cyw=Uc
set oyw=GetUnitTypeId(GetOrderedUnit())
set Xb[Lb]="when calling has in MassControl, line 33"
set Lb=Lb+1
if tl[cyw]==0 then
if cyw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Oyw=kbw(cyw,oyw)
set Lb=Lb-1
if Oyw then
if Xnw(Ec,GetHandleId(GetOrderedUnit()),"when calling has in MassControl, line 34") then
set uyw=tdw(Ec,GetHandleId(GetOrderedUnit()),"when calling get in MassControl, line 35")
set ryw=GetIssuedOrderId()
set syw=GetOrderPointX()
set tyw=GetOrderPointY()
set Xb[Lb]="when calling iterator in MassControl, line 38"
set Lb=Lb+1
set lyw=dbw(uyw,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set iyw=lyw
loop
exitwhen Tb[Gb[iyw]]==Yb[iyw]
set Gb[iyw]=Tb[Gb[iyw]]
set Syw=kww(fb[Gb[iyw]],"when calling unitFromIndex in MassControl, line 38")
set Xb[Lb]="when calling alloc_MassControl_CallbackSingle_line39 in MassControl, line 39"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set Mbw=YO
set GO[Mbw]=648
else
call I1("Out of memory: Could not create MassControl_CallbackSingle_line39.","when calling error in MassControl, line 39")
set Mbw=0
endif
else
set TO=TO-1
set Mbw=RO[TO]
set GO[Mbw]=648
endif
set Lb=Lb-1
set mb[Mbw]=Syw
set Qb[Mbw]=ryw
set Wb[Mbw]=syw
set Eb[Mbw]=tyw
set wyw="when calling doAfter in MassControl, line 39"
set Xb[Lb]="when calling doAfter in MassControl, line 39"
set Lb=Lb+1
call jB(iww("when calling getTimer in ClosureTimers, line 27"),0.01,Mbw,"when calling doAfter in ClosureTimers, line 27")
set Lb=Lb-1
endloop
set Xb[Lb]="when calling close in MassControl, line 38"
set Lb=Lb+1
if hb[iyw]then
call edw(iyw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
call odw(Ec,GetHandleId(GetOrderedUnit()),"when calling remove in MassControl, line 42")
endif
endif
set Lb=Lb-1
set Syw=null
endfunction
function Ouw takes unit suw,unit tuw returns real
local real iuw=GetUnitX(suw)
local real Suw=GetUnitY(suw)
local real cuw=iuw-GetUnitX(tuw)
local real ouw=Suw-GetUnitY(tuw)
return SquareRoot(cuw*cuw+ouw*ouw)
endfunction
function cqw takes integer Cew,string Vew returns nothing
local unit Bew
local integer New
local player Mew
local group wqw
local location uqw
local group rqw
local unit sqw
local boolean tqw
local boolean iqw
local boolean Sqw
set Xb[Lb]=Vew
set Lb=Lb+1
set Bew=GetTriggerUnit()
set New=GetUnitTypeId(Bew)
if Dnw(yo,New,"when calling has in RangeChecks, line 15") then
set Mew=GetOwningPlayer(Bew)
set uqw=GetUnitLoc(Bew)
set rqw=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(rqw,uqw,2000.0,null)
call DestroyBoolExpr(null)
set dc=CreateGroup()
call ForGroup(rqw,Af)
set wqw=dc
loop
exitwhen FirstOfGroup(wqw)==null
set sqw=FirstOfGroup(wqw)
call GroupRemoveUnit(wqw,sqw)
if GetOwningPlayer(sqw)==Mew and sqw!=Bew then
if GetUnitTypeId(sqw)==New and Ouw(sqw,Bew)<=1500 then
set iqw=true
else
if Dnw(Mo,New,"when calling has in RangeChecks, line 21") then
set tqw=Dnw(Mo,GetUnitTypeId(sqw),"when calling has in RangeChecks, line 21")
else
set tqw=false
endif
set iqw=tqw
endif
set Sqw=iqw
else
set Sqw=false
endif
if Sqw then
set Xb[Lb]="when calling alloc_RangeChecks_CallbackSingle_line23 in RangeChecks, line 23"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set Cew=YO
set GO[Cew]=653
else
call I1("Out of memory: Could not create RangeChecks_CallbackSingle_line23.","when calling error in RangeChecks, line 23")
set Cew=0
endif
else
set TO=TO-1
set Cew=RO[TO]
set GO[Cew]=653
endif
set Lb=Lb-1
set Jb[Cew]=Bew
set Xb[Lb]="when calling doAfter in RangeChecks, line 23"
set Lb=Lb+1
call jB(iww("when calling getTimer in ClosureTimers, line 27"),0.01,Cew,"when calling doAfter in ClosureTimers, line 27")
set Lb=Lb-1
if New==1747988557 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 27"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build settlements too close to each other.")
set Lb=Lb-1
elseif New==1747989041 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 29"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build settlements too close to each other.")
set Lb=Lb-1
elseif New==1747990344 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 31"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build settlements too close to each other.")
set Lb=Lb-1
elseif New==1747989075 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 33"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build churches too close to each other.")
set Lb=Lb-1
elseif New==1747990102 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 35"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build churches too close to each other.")
set Lb=Lb-1
elseif New==1747988785 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 37"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build churches too close to each other.")
set Lb=Lb-1
elseif New==1747989839 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 39"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build mosques too close to each other.")
set Lb=Lb-1
elseif New==1747989059 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 41"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build castles too close to each other.")
set Lb=Lb-1
elseif New==1747989331 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 43"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build castles too close to each other.")
set Lb=Lb-1
elseif New==1747990351 then
set Vew="when calling attentionToPlayer in RangeChecks, line 45"
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 45"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build castles too close to each other.")
set Lb=Lb-1
elseif New==1747990353 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 47"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build castles too close to each other.")
set Lb=Lb-1
elseif New==1747988568 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 49"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build inns too close to each other.")
set Lb=Lb-1
elseif New==1747990341 then
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 51"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build inns too close to each other.")
set Lb=Lb-1
else
set Xb[Lb]="when calling attentionToPlayer in RangeChecks, line 54"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,a5(Mew,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Mew,0.,0.,10.0,"You cannot build inns too close to each other.")
set Lb=Lb-1
endif
exitwhen true
endif
endloop
call GroupClear(wqw)
call DestroyGroup(wqw)
endif
set Lb=Lb-1
set Bew=null
set Mew=null
set wqw=null
set uqw=null
set rqw=null
set sqw=null
endfunction
function dpw takes integer lpw,string bpw returns nothing
local unit ypw
local integer ppw
local boolean epw
local player qpw
local integer apw
local integer npw
set Xb[Lb]=bpw
set Lb=Lb+1
set lpw=Xo
set ppw=GetUnitTypeId(GetTriggerUnit())
set Xb[Lb]="when calling has in OreCapture, line 15"
set Lb=Lb+1
if tl[lpw]==0 then
if lpw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set epw=kbw(lpw,ppw)
set Lb=Lb-1
if epw then
set ypw=GetTriggerUnit()
set qpw=GetOwningPlayer(ypw)
set npw=ic[GetPlayerId(GetOwningPlayer(ypw))]
set apw=Co
set ic[GetPlayerId(qpw)]=npw+tdw(apw,GetUnitTypeId(ypw),"when calling get in OreCapture, line 19")
endif
set Lb=Lb-1
set ypw=null
set qpw=null
endfunction
function MC takes integer BC,integer NC returns integer
if BC==1 then
if NC==0 then
return 1747989059
elseif NC==1 then
return 1747990351
elseif NC==2 then
return 1747989331
elseif NC==3 then
return 1747990353
else
return 1747989059
endif
elseif BC==2 then
if NC==0 then
return 1747989060
elseif NC==1 then
return 1747990352
elseif NC==2 then
return 1747990350
elseif NC==3 then
return 1747990354
else
return 1747989060
endif
elseif BC==3 then
if NC==0 then
return 1747988844
elseif NC==1 then
return 1747990356
elseif NC==2 then
return 1747989809
elseif NC==3 then
return 1747990355
else
return 1747988844
endif
elseif NC==0 then
return 1747989059
elseif NC==1 then
return 1747990351
elseif NC==2 then
return 1747989331
elseif NC==3 then
return 1747990353
else
return 1747989059
endif
endfunction
function VC takes integer CC returns integer
if CC==1747989059 then
return 1
elseif CC==1747989060 then
return 2
elseif CC==1747988844 then
return 3
elseif CC==1747990351 then
return 1
elseif CC==1747990352 then
return 2
elseif CC==1747990356 then
return 3
elseif CC==1747989331 then
return 1
elseif CC==1747990350 then
return 2
elseif CC==1747989809 then
return 3
elseif CC==1747990353 then
return 1
elseif CC==1747990354 then
return 2
elseif CC==1747990355 then
return 3
else
return 1
endif
endfunction
function dsw takes integer isw,string Ssw returns nothing
local unit csw
local player osw
local unit Osw
local integer lsw
local boolean bsw
local real ysw
local boolean psw
local integer esw
local real qsw
local real asw
local real nsw
set Xb[Lb]=Ssw
set Lb=Lb+1
set csw=GetTriggerUnit()
if Dnw(Mo,GetUnitTypeId(csw),"when calling has in CastleCapture, line 11") then
if GetUnitStatePercent(csw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=50.0 then
set bsw=GetOwningPlayer(csw)!=GetOwningPlayer(GetAttacker())
else
set bsw=false
endif
if bsw then
set ysw=GetUnitX(csw)
set qsw=GetUnitY(csw)
set Osw=GetAttacker()
set asw=ysw-GetUnitX(Osw)
set nsw=qsw-GetUnitY(Osw)
set psw=SquareRoot(asw*asw+nsw*nsw)<=300.0
else
set psw=false
endif
if psw then
set osw=GetOwningPlayer(GetAttacker())
call SetUnitOwner(csw,osw,true)
if GetPlayerId(osw)!=PLAYER_NEUTRAL_AGGRESSIVE then
set esw=VC(GetUnitTypeId(csw))
set lsw=uo[GetPlayerId(osw)]
set Xb[Lb]="when calling getForceId in CastleCapture, line 17"
set Lb=Lb+1
if ll[lsw]==0 then
if lsw==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set isw=Ub[lsw]
set Lb=Lb-1
set csw=ReplaceUnitBJ(csw,MC(esw,isw),bj_UNIT_STATE_METHOD_RELATIVE)
endif
call SetUnitState(csw,UNIT_STATE_LIFE,GetUnitState(csw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,60.0)*0.01)
call SetUnitState(csw,UNIT_STATE_MANA,GetUnitState(csw,UNIT_STATE_MAX_MANA)*RMaxBJ(0.,0.0)*0.01)
call UnitAddAbility(csw,1093677896)
endif
endif
set Lb=Lb-1
set csw=null
set osw=null
set Osw=null
endfunction
function d5 takes string n5 returns nothing
if (not hc)and(not Fc) then
return
endif
call DisplayTimedTextToPlayer(ro[0],0.,0.,60.,n5)
endfunction
function hOw takes integer nOw,string dOw returns nothing
local unit fOw
local boolean ROw
local player TOw
local boolean YOw
local boolean GOw
local boolean gOw
set Xb[Lb]=dOw
set Lb=Lb+1
set fOw=GetTriggerUnit()
set Xb[Lb]="when calling isCity in Garissons, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling isCity in UnitTools, line 5"
set Lb=Lb+1
set ROw=Dnw(wO,GetUnitTypeId(fOw),"when calling has in City, line 432")
set Lb=Lb-1-1
if ROw then
set YOw=true
else
set YOw=Dnw(Mo,GetUnitTypeId(fOw),"when calling has in Garissons, line 9")
endif
if YOw then
set TOw=GetOwningPlayer(fOw)
if GetPlayerSlotState(TOw)==PLAYER_SLOT_STATE_PLAYING then
set GOw=GetPlayerController(TOw)==MAP_CONTROL_USER
else
set GOw=false
endif
if not GOw then
set gOw=true
else
set gOw=GetPlayerId(GetOwningPlayer(fOw))==PLAYER_NEUTRAL_AGGRESSIVE
endif
if gOw then
call d5("TRYING TO SUMMON A GARRISON")
set Xb[Lb]="when calling alloc_Garissons_CallbackSingle_line12 in Garissons, line 12"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set nOw=YO
set GO[nOw]=645
else
call I1("Out of memory: Could not create Garissons_CallbackSingle_line12.","when calling error in Garissons, line 12")
set nOw=0
endif
else
set TO=TO-1
set nOw=RO[TO]
set GO[nOw]=645
endif
set Lb=Lb-1
set yb[nOw]=fOw
set Xb[Lb]="when calling doAfter in Garissons, line 12"
set Lb=Lb+1
call jB(iww("when calling getTimer in ClosureTimers, line 27"),0.01,nOw,"when calling doAfter in ClosureTimers, line 27")
set Lb=Lb-1
endif
endif
set Lb=Lb-1
set fOw=null
set TOw=null
endfunction
function H2 takes real U2,real I2,real P2,real A2,real D2 returns real
set P2=GetRandomReal(P2,A2)
return (U2+I2)/2.+Z2(P2)*Pow(2.718281828,-(Pow(P2,2.)/2.*D2))/SquareRoot(6.283185482*D2)*((I2-U2)/2.)
endfunction
function onw takes integer tnw,timer inw,real Snw,string cnw returns nothing
set Xb[Lb]=cnw
set Lb=Lb+1
if kO[tnw]==0 then
if tnw==0 then
call I1("Nullpointer exception when calling CallbackPeriodic.start","when calling error in ClosureTimers, line 132")
else
call I1("Called CallbackPeriodic.start on invalid object.","when calling error in ClosureTimers, line 132")
endif
endif
set Xb[Lb]="when calling start in ClosureTimers, line 132"
set Lb=Lb+1
call Vww(inw,tnw,"when calling setData in ClosureTimers, line 134")
call TimerStart(inw,Snw,true,iR)
set Lb=Lb-1-1
endfunction
function xSw takes integer OSw,unit lSw,string bSw,integer ySw,integer pSw,string eSw returns nothing
local playerunitevent qSw
local real aSw
local real nSw
local unit dSw
local player fSw
local integer RSw
local integer TSw
local real YSw
local integer GSw
local timer gSw
local integer hSw
local timer FSw
local real kSw
local real jSw
set Xb[Lb]=eSw
set Lb=Lb+1
set Dl[OSw]=0
set Hl[OSw]=0.
set Jl[OSw]=Zbw("when calling new_LinkedList in City, line 104")
set Al[OSw]=1.0
set kl[OSw]=lSw
set dSw=kl[OSw]
set kSw=GetUnitX(dSw)
set jSw=GetUnitY(dSw)
set Ql[OSw]=kSw
set Wl[OSw]=jSw
set jl[OSw]=bSw
set vl[OSw]=ySw
set fSw=GetOwningPlayer(kl[OSw])
set ml[OSw]=GetPlayerId(fSw)
set jl[OSw]=SubString(bSw,0,24)
set xl[OSw]=fS
set fS=fS+1
set qSw=EVENT_PLAYER_UNIT_DEATH
set Xb[Lb]="when calling alloc_City_City_EventListener_line121 in City, line 121"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set RSw=cO
set oO[RSw]=667
else
call I1("Out of memory: Could not create City_City_EventListener_line121.","when calling error in City, line 121")
set RSw=0
endif
else
set SO=SO-1
set RSw=iO[SO]
set oO[RSw]=667
endif
set Lb=Lb-1
set Ml[RSw]=0
set wb[RSw]=0
set ub[RSw]=0
set Vl[RSw]=OSw
set Xb[Lb]="when calling add in City, line 121"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set TSw=QS[GetHandleId(qSw)]
if TSw==0 then
set TSw=QV(qSw,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[RSw]=TSw
if US[Ml[RSw]]!=0 then
set ub[US[Ml[RSw]]]=RSw
set wb[RSw]=US[Ml[RSw]]
endif
set US[Ml[RSw]]=RSw
set Lb=Lb-1
set Ul[OSw]=H2(TS[0],TS[1],-5.0,5.0,0.15)
set YSw=H2(kdw(YS[pSw],0,"when calling get in City, line 133")*1.,kdw(YS[pSw],1,"when calling get in City, line 133")*1.,-5.0,5.0,0.15)
set El[OSw]=R2I(YSw)
set Pl[OSw]=0.
set aSw=2.5+GetRandomReal(2.5,5.0)
set Xb[Lb]="when calling alloc_City_City_CallbackPeriodic_line138 in City, line 138"
set Lb=Lb+1
if hO==0 then
if FO<32768 then
set FO=FO+1
set GSw=FO
set kO[GSw]=631
else
call I1("Out of memory: Could not create City_City_CallbackPeriodic_line138.","when calling error in City, line 138")
set GSw=0
endif
else
set hO=hO-1
set GSw=gO[hO]
set kO[GSw]=631
endif
set Lb=Lb-1
set Bl[GSw]=OSw
set Xb[Lb]="when calling doPeriodically in City, line 138"
set Lb=Lb+1
set gSw=iww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call onw(GSw,gSw,aSw,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1
set nSw=60+GetRandomReal(60,120.0)
set Xb[Lb]="when calling alloc_City_City_CallbackPeriodic_line154 in City, line 154"
set Lb=Lb+1
if hO==0 then
if FO<32768 then
set FO=FO+1
set hSw=FO
set kO[hSw]=632
else
call I1("Out of memory: Could not create City_City_CallbackPeriodic_line154.","when calling error in City, line 154")
set hSw=0
endif
else
set hO=hO-1
set hSw=gO[hO]
set kO[hSw]=632
endif
set Lb=Lb-1
set Nl[hSw]=OSw
set Xb[Lb]="when calling doPeriodically in City, line 154"
set Lb=Lb+1
set FSw=iww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call onw(hSw,FSw,nSw,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set qSw=null
set dSw=null
set fSw=null
set gSw=null
set FSw=null
endfunction
function oSw takes unit rSw,string sSw,integer tSw,integer iSw,string SSw returns integer
local integer cSw
set Xb[Lb]=SSw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_City in City, line 101"
set Lb=Lb+1
if pO==0 then
if eO<32768 then
set eO=eO+1
set cSw=eO
set qO[cSw]=654
else
call I1("Out of memory: Could not create City.","when calling error in City, line 71")
set cSw=0
endif
else
set pO=pO-1
set cSw=yO[pO]
set qO[cSw]=654
endif
set Lb=Lb-1
call xSw(cSw,rSw,sSw,tSw,iSw,"when calling construct_City in City, line 101")
set Lb=Lb-1
return cSw
endfunction
function hsw takes integer fsw,string Rsw returns nothing
local unit Tsw
local boolean Ysw
local integer Gsw
local unit gsw
set Xb[Lb]=Rsw
set Lb=Lb+1
set Tsw=GetConstructedStructure()
set Xb[Lb]="when calling isCity in CityBuilded, line 10"
set Lb=Lb+1
set Xb[Lb]="when calling isCity in UnitTools, line 5"
set Lb=Lb+1
set Ysw=Dnw(wO,GetUnitTypeId(Tsw),"when calling has in City, line 432")
set Lb=Lb-1-1
if Ysw then
set gsw=GetConstructedStructure()
set fsw=uo[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))]
set Xb[Lb]="when calling getForceId in CityBuilded, line 11"
set Lb=Lb+1
if ll[fsw]==0 then
if fsw==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set Gsw=Ub[fsw]
set Lb=Lb-1
set kS[fS]=oSw(gsw,"New",Gsw,1,"when calling new_City in CityBuilded, line 11")
endif
set Lb=Lb-1
set Tsw=null
set gsw=null
endfunction
function uiw takes integer Btw,integer Ntw,string Mtw returns nothing
local player wiw
set Xb[Lb]=Mtw
set Lb=Lb+1
if jc-Hl[Btw]>=RS then
set Hl[Btw]=jc
set Pl[Btw]=Pl[Btw]-gS[Dl[Btw]]
set Pl[Btw]=Pl[Btw]+gS[Ntw]
set Dl[Btw]=Ntw
else
set wiw=ro[ml[Btw]]
set Xb[Lb]="when calling noteToPlayer in City, line 271"
set Lb=Lb+1
call DisplayTimedTextToPlayer(wiw,0.,0.,10.0,t5(wiw,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(wiw,0.,0.,10.0,"Wait 1 turn to be able to change tax level.")
set Lb=Lb-1
endif
set Lb=Lb-1
set wiw=null
endfunction
function kqw takes integer dqw,string fqw returns nothing
local integer Rqw
local integer Tqw
local integer Yqw
local boolean Gqw
local unit gqw
local boolean hqw
local integer Fqw
set Xb[Lb]=fqw
set Lb=Lb+1
set Yqw=tS
set dqw=GetSpellAbilityId()
set Xb[Lb]="when calling has in Taxation, line 7"
set Lb=Lb+1
if tl[Yqw]==0 then
if Yqw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Gqw=kbw(Yqw,dqw)
set Lb=Lb-1
if Gqw then
set gqw=GetSpellTargetUnit()
set Xb[Lb]="when calling isCity in Taxation, line 8"
set Lb=Lb+1
set hqw=Dnw(wO,GetUnitTypeId(gqw),"when calling has in City, line 432")
set Lb=Lb-1
if hqw then
if GetOwningPlayer(GetSpellTargetUnit())==GetOwningPlayer(GetSpellAbilityUnit()) then
set Rqw=0
set Tqw=GetSpellAbilityId()
if Tqw==1093677642 then
set Rqw=1
elseif Tqw==1093677641 then
set Rqw=0
elseif Tqw==1093677640 then
set Rqw=2
elseif Tqw==1093678155 then
set Rqw=3
endif
set Fqw=kS[bV(GetSpellTargetUnit(),"when calling getCityId in Taxation, line 20")]
set Xb[Lb]="when calling changeTaxLevel in Taxation, line 20"
set Lb=Lb+1
if qO[Fqw]==0 then
if Fqw==0 then
call I1("Nullpointer exception when calling City.changeTaxLevel","when calling error in City, line 262")
else
call I1("Called City.changeTaxLevel on invalid object.","when calling error in City, line 262")
endif
endif
call uiw(Fqw,Rqw,"when calling changeTaxLevel in City, line 262")
set Lb=Lb-1
endif
endif
endif
set Lb=Lb-1
set gqw=null
endfunction
function obw takes integer ubw,string rbw returns nothing
local unit sbw
local player tbw
local player ibw
local player Sbw
local timer cbw
set Xb[Lb]=rbw
set Lb=Lb+1
set sbw=GetConstructingStructure()
if GetUnitTypeId(sbw)==1747988808 then
if Yc[GetPlayerId(GetOwningPlayer(sbw))]<3 then
set tbw=GetOwningPlayer(sbw)
set ibw=GetOwningPlayer(sbw)
set Yc[GetPlayerId(tbw)]=Yc[GetPlayerId(ibw)]+1
else
set Sbw=GetOwningPlayer(sbw)
set Xb[Lb]="when calling attentionToPlayer in LimitEncampments, line 18"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Sbw,0.,0.,10.0,a5(Sbw,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(Sbw,0.,0.,10.0,"You cannot build more than 3 encampments.")
set Lb=Lb-1
set Xb[Lb]="when calling alloc_LimitEncampments_CallbackSingle_line19 in LimitEncampments, line 19"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set ubw=YO
set GO[ubw]=647
else
call I1("Out of memory: Could not create LimitEncampments_CallbackSingle_line19.","when calling error in LimitEncampments, line 19")
set ubw=0
endif
else
set TO=TO-1
set ubw=RO[TO]
set GO[ubw]=647
endif
set Lb=Lb-1
set nb[ubw]=sbw
set Xb[Lb]="when calling doAfter in LimitEncampments, line 19"
set Lb=Lb+1
set cbw=iww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call fnw(ubw,cbw,0.01,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1
endif
endif
set Lb=Lb-1
set sbw=null
set tbw=null
set ibw=null
set Sbw=null
set cbw=null
endfunction
function oow takes integer cow returns nothing
if GetUnitTypeId(GetOrderedUnit())==1747989297 then
call d5("Issued ordinary order (|cff00ff0d"+I2S(GetIssuedOrderId())+"|r) for unit "+GetUnitName(GetOrderedUnit()))
endif
endfunction
function vpw takes integer fpw,string Rpw returns nothing
local unit Tpw
local integer Ypw
local boolean Gpw
local player gpw
local player hpw
local integer Fpw
local integer kpw
local integer jpw
local integer xpw
set Xb[Lb]=Rpw
set Lb=Lb+1
set Tpw=GetTriggerUnit()
set Ypw=Xo
set fpw=GetUnitTypeId(Tpw)
set Xb[Lb]="when calling has in OreCapture, line 23"
set Lb=Lb+1
if tl[Ypw]==0 then
if Ypw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Gpw=kbw(Ypw,fpw)
set Lb=Lb-1
if Gpw then
if GetUnitStatePercent(Tpw,UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)<=80.0 then
call SetUnitOwner(Tpw,GetOwningPlayer(GetAttacker()),true)
call SetUnitState(Tpw,UNIT_STATE_LIFE,GetUnitState(Tpw,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.0)*0.01)
set gpw=GetOwningPlayer(Tpw)
set kpw=ic[GetPlayerId(GetOwningPlayer(Tpw))]
set Fpw=Co
set ic[GetPlayerId(gpw)]=kpw-tdw(Fpw,GetUnitTypeId(Tpw),"when calling get in OreCapture, line 29")
set hpw=GetOwningPlayer(GetAttacker())
set xpw=ic[GetPlayerId(GetOwningPlayer(GetAttacker()))]
set jpw=Co
set ic[GetPlayerId(hpw)]=xpw+tdw(jpw,GetUnitTypeId(Tpw),"when calling get in OreCapture, line 30")
endif
endif
set Lb=Lb-1
set Tpw=null
set gpw=null
set hpw=null
endfunction
function Zdw takes integer Qdw,integer Wdw,string Edw returns nothing
set Xb[Lb]=Edw
set Lb=Lb+1
if ll[Qdw]==0 then
if Qdw==0 then
call I1("Nullpointer exception when calling PlayerStats.setSelectedCityId","when calling error in PlayerStats, line 116")
else
call I1("Called PlayerStats.setSelectedCityId on invalid object.","when calling error in PlayerStats, line 116")
endif
endif
set Xb[Lb]="when calling setSelectedCityId in PlayerStats, line 116"
set Lb=Lb+1
if Wdw>=0 and Wdw<fS then
set Ab[Qdw]=Wdw
set Xb[Lb]="when calling refreshMultiboardCity in PlayerStats, line 119"
set Lb=Lb+1
if ll[Qdw]==0 then
if Qdw==0 then
call I1("Nullpointer exception when calling PlayerStats.refreshMultiboardCity","when calling error in PlayerStats, line 71")
else
call I1("Called PlayerStats.refreshMultiboardCity on invalid object.","when calling error in PlayerStats, line 71")
endif
endif
call oew(Qdw,"when calling refreshMultiboardCity in PlayerStats, line 71")
set Lb=Lb-1
endif
set Lb=Lb-1-1
endfunction
function vsw takes integer Fsw,string ksw returns nothing
local unit jsw
local boolean xsw
set Xb[Lb]=ksw
set Lb=Lb+1
set jsw=GetTriggerUnit()
set Xb[Lb]="when calling isCity in CityManage, line 10"
set Lb=Lb+1
set Xb[Lb]="when calling isCity in UnitTools, line 5"
set Lb=Lb+1
set xsw=Dnw(wO,GetUnitTypeId(jsw),"when calling has in City, line 432")
set Lb=Lb-1-1
if xsw then
call Zdw(uo[GetPlayerId(GetTriggerPlayer())],bV(GetTriggerUnit(),"when calling getCityId in CityManage, line 11"),"when calling setSelectedCityId in CityManage, line 11")
endif
set Lb=Lb-1
set jsw=null
endfunction
function wbw takes integer Vlw returns nothing
local unit Blw=GetDyingUnit()
local player Nlw
local player Mlw
if GetUnitTypeId(Blw)==1747988808 then
set Nlw=GetOwningPlayer(Blw)
set Mlw=GetOwningPlayer(Blw)
set Yc[GetPlayerId(Nlw)]=Yc[GetPlayerId(Mlw)]-1
endif
set Blw=null
set Nlw=null
set Mlw=null
endfunction
function wpw takes integer Byw,string Nyw returns nothing
local force Myw
set Xb[Lb]=Nyw
set Lb=Lb+1
set Nyw=HB(GetTriggerPlayer())+" has left the game!"
set Myw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),Myw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,5.0,Nyw)
endif
set Byw=uo[GetPlayerId(GetTriggerPlayer())]
set Xb[Lb]="when calling setInGame in OnPlayerLeave, line 7"
set Lb=Lb+1
if ll[Byw]==0 then
if Byw==0 then
call I1("Nullpointer exception when calling PlayerStats.setInGame","when calling error in PlayerStats, line 45")
else
call I1("Called PlayerStats.setInGame on invalid object.","when calling error in PlayerStats, line 45")
endif
endif
set Pb[Byw]=false
set Lb=Lb-1
call SetPlayerName(GetTriggerPlayer(),GetPlayerName(GetTriggerPlayer())+" [LEFT]")
set Lb=Lb-1
set Myw=null
endfunction
function Zaw takes integer Waw,string Eaw returns nothing
set Xb[Lb]=Eaw
set Lb=Lb+1
if oO[Waw]==0 then
if Waw==0 then
call I1("Nullpointer exception when calling EventListener.onEvent","when calling error in ClosureEvents, line 109")
else
call I1("Called EventListener.onEvent on invalid object.","when calling error in ClosureEvents, line 109")
endif
endif
if oO[Waw]<=673 then
if oO[Waw]<=668 then
if oO[Waw]<=665 then
if oO[Waw]<=664 then
if oO[Waw]<=663 then
call dsw(Waw,"when calling CastleCapture_onEvent_line8 in ClosureEvents, line 109")
else
call hsw(Waw,"when calling CityBuilded_onEvent_line9 in ClosureEvents, line 109")
endif
else
call Ksw(Waw,"when calling CityManage_onEvent_line34 in ClosureEvents, line 109")
endif
elseif oO[Waw]<=667 then
if oO[Waw]<=666 then
call vsw(Waw,"when calling CityManage_onEvent_line9 in ClosureEvents, line 109")
else
call BSw(Waw)
endif
else
call Ecw(Waw,"when calling Clerics_onEvent_line5 in ClosureEvents, line 109")
endif
elseif oO[Waw]<=671 then
if oO[Waw]<=670 then
if oO[Waw]<=669 then
call oow(Waw)
else
call hOw(Waw,"when calling Garissons_onEvent_line7 in ClosureEvents, line 109")
endif
else
call obw(Waw,"when calling LimitEncampments_onEvent_line12 in ClosureEvents, line 109")
endif
elseif oO[Waw]<=672 then
call wbw(Waw)
else
call Lbw(Waw,"when calling MassControl_onEvent_line22 in ClosureEvents, line 109")
endif
elseif oO[Waw]<=679 then
if oO[Waw]<=676 then
if oO[Waw]<=675 then
if oO[Waw]<=674 then
call byw(Waw,"when calling MassControl_onEvent_line32 in ClosureEvents, line 109")
else
call Pyw(Waw,"when calling NoShipsNearRivers_onEvent_line7 in ClosureEvents, line 109")
endif
else
call Vyw(Waw,"when calling NoStarvationOnBoat_onEvent_line9 in ClosureEvents, line 109")
endif
elseif oO[Waw]<=678 then
if oO[Waw]<=677 then
call wpw(Waw,"when calling OnPlayerLeave_onEvent_line5 in ClosureEvents, line 109")
else
call dpw(Waw,"when calling OreCapture_onEvent_line14 in ClosureEvents, line 109")
endif
else
call vpw(Waw,"when calling OreCapture_onEvent_line21 in ClosureEvents, line 109")
endif
elseif oO[Waw]<=682 then
if oO[Waw]<=681 then
if oO[Waw]<=680 then
call Opw(Waw,"when calling OreCapture_onEvent_line9 in ClosureEvents, line 109")
else
call cqw(Waw,"when calling RangeChecks_onEvent_line12 in ClosureEvents, line 109")
endif
else
call kqw(Waw,"when calling Taxation_onEvent_line6 in ClosureEvents, line 109")
endif
elseif oO[Waw]<=683 then
call baw(Waw,"when calling Upkeep_onEvent_line34 in ClosureEvents, line 109")
else
call Mqw(Waw,"when calling Upkeep_onEvent_line8 in ClosureEvents, line 109")
endif
set Lb=Lb-1
endfunction
function sB takes string CV returns nothing
local unit VV
local integer BV
local integer NV
local integer MV
local eventid wB
local integer uB
local boolean rB
set Xb[Lb]=CV
set Lb=Lb+1
set VV=GetTriggerUnit()
set wB=GetTriggerEventId()
set Xb[Lb]="when calling toIntId in ClosureEvents, line 170"
set Lb=Lb+1
set uB=QS[GetHandleId(wB)]
if uB==0 then
set uB=QV(wB,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set BV=uB
if VV!=null then
set rB=GetUnitUserData(VV)>0
else
set rB=false
endif
if rB then
if IS[GetUnitUserData(VV)]!=0 then
set NV=IS[GetUnitUserData(VV)]
loop
exitwhen NV==0
if Ml[NV]==BV then
call Zaw(NV,"when calling onEvent in ClosureEvents, line 177")
endif
set NV=wb[NV]
endloop
endif
endif
if US[BV]!=0 then
set MV=US[BV]
loop
exitwhen MV==0
call Zaw(MV,"when calling onEvent in ClosureEvents, line 183")
set MV=wb[MV]
endloop
endif
set Lb=Lb-1
set VV=null
set wB=null
endfunction
function Bxw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 291"
set Lb=Lb+1
call sB("when calling generalEventCallback in ClosureEvents, line 291")
set Lb=Lb-1
endfunction
function C1 takes nothing returns boolean
call CreateGroup()
return true
endfunction
function XD takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())==1747989040 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747990361 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747989831 then
return true
endif
return false
endfunction
function CD takes nothing returns boolean
if e[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]!=false then
return false
endif
if not XD() then
return false
endif
return true
endfunction
function CE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989557,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989559,0)
endfunction
function XK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989060 then
return false
endif
return true
endfunction
function CK takes nothing returns boolean
if not XK() then
return false
endif
return true
endfunction
function XQ takes nothing returns boolean
if GetResearched()!=1378889801 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889801,true)!=1 then
return false
endif
return true
endfunction
function CQ takes nothing returns boolean
if not XQ() then
return false
endif
return true
endfunction
function Gnw takes integer Rnw,unit Tnw,string Ynw returns nothing
set Xb[Lb]=Ynw
set Lb=Lb+1
if WO[Rnw]==0 then
if Rnw==0 then
call I1("Nullpointer exception when calling ArrayQueue.enqueue","when calling error in DummyRecycler, line 55")
else
call I1("Called ArrayQueue.enqueue on invalid object.","when calling error in DummyRecycler, line 55")
endif
endif
set Xb[Lb]="when calling enqueue in DummyRecycler, line 55"
set Lb=Lb+1
if Ob[Rnw]<6 then
set Ob[Rnw]=Ob[Rnw]+1
set ob[Rnw]=ModuloInteger(ob[Rnw]+1,6)
else
call I1("Queue Overflow","when calling error in DummyRecycler, line 61")
endif
set Lb=Lb-1-1
endfunction
function bow takes string Oow returns integer
local integer low
set Xb[Lb]=Oow
set Lb=Lb+1
set Xb[Lb]="when calling alloc_ArrayQueue in DummyRecycler, line 49"
set Lb=Lb+1
if mO==0 then
if QO<32768 then
set QO=QO+1
set low=QO
set WO[low]=626
else
call I1("Out of memory: Could not create ArrayQueue.","when calling error in DummyRecycler, line 49")
set low=0
endif
else
set mO=mO-1
set low=vO[mO]
set WO[low]=626
endif
set Lb=Lb-1
set ob[low]=0
set Ob[low]=0
set Lb=Lb-1
return low
endfunction
function i1 takes real w1,real u1,player r1,real s1 returns unit
local unit t1=CreateUnit(r1,2019849581,w1,u1,s1*57.295779513)
call SetUnitX(t1,w1)
call SetUnitY(t1,u1)
call UnitAddAbility(t1,1097691750)
call UnitRemoveAbility(t1,1097691750)
call UnitAddAbility(t1,1097625443)
set cR=t1
set t1=null
return cR
endfunction
function M3 takes string X3 returns boolean
local integer C3
local integer V3
local integer B3
local integer N3
set Xb[Lb]=X3
set Lb=Lb+1
set uc=360*1./8
call CreateTimer()
set C3=0
set V3=7
loop
exitwhen C3>V3
set rc[C3]=bow("when calling new_ArrayQueue in DummyRecycler, line 140")
set B3=0
set N3=5
loop
exitwhen B3>N3
call Gnw(rc[C3],i1(Qc,Wc,SS,C3*uc*0.017453293),"when calling enqueue in DummyRecycler, line 142")
set B3=B3+1
endloop
set C3=C3+1
endloop
set Lb=Lb-1
return true
endfunction
function Cjw takes nothing returns boolean
set Lb=0
return M3("DummyRecycler, line 1")
endfunction
function Uqw takes integer Zqw returns nothing
set Jo[Ko]=Kb[Zqw]
set Ko=Ko+1
call TriggerEvaluate(Ho)
set Ko=Ko-1
call SetUnitUserData(Kb[Zqw],0)
endfunction
function Pdw takes integer Udw,string Idw returns nothing
set Xb[Lb]=Idw
set Lb=Lb+1
if nl[Udw]==0 then
if Udw==0 then
call I1("Nullpointer exception when calling UnitIndex.UnitIndex","when calling error in UnitIndexer, line 172")
else
call I1("Called UnitIndex.UnitIndex on invalid object.","when calling error in UnitIndexer, line 172")
endif
endif
set Xb[Lb]="when calling destroyUnitIndex in UnitIndexer, line 172"
set Lb=Lb+1
call Uqw(Udw)
set Xb[Lb]="when calling dealloc_UnitIndex in UnitIndexer, line 188"
set Lb=Lb+1
if nl[Udw]==0 then
call I1("Double free: object of type UnitIndex","when calling error in UnitIndexer, line 172")
else
set el[ql]=Udw
set ql=ql+1
set nl[Udw]=0
endif
set Lb=Lb-1-1-1
endfunction
function Eqw takes integer Qqw,unit Wqw returns nothing
set Kb[Qqw]=Wqw
call SetUnitUserData(Kb[Qqw],Qqw)
set Jo[Ko]=Wqw
set Ko=Ko+1
call TriggerEvaluate(Do)
set Ko=Ko-1
endfunction
function mqw takes unit jqw,string xqw returns integer
local integer vqw
set Xb[Lb]=xqw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_UnitIndex in UnitIndexer, line 181"
set Lb=Lb+1
if ql==0 then
if al<32768 then
set al=al+1
set vqw=al
set nl[vqw]=741
else
call I1("Out of memory: Could not create UnitIndex.","when calling error in UnitIndexer, line 172")
set vqw=0
endif
else
set ql=ql-1
set vqw=el[ql]
set nl[vqw]=741
endif
set Lb=Lb-1
call Eqw(vqw,jqw)
set Lb=Lb-1
return vqw
endfunction
function Bww takes unit Xww,string Cww returns boolean
local integer Vww_2
set Xb[Lb]=Cww
set Lb=Lb+1
if GetUnitUserData(Xww)==0 then
set Lb=Lb-1
return false
else
set Xb[Lb]="when calling toUnitIndex in UnitIndexer, line 169"
set Lb=Lb+1
set Vww_2=GetUnitUserData(Xww)
if Vww_2==0 then
set Vww_2=mqw(Xww,"when calling new_UnitIndex in UnitIndexer, line 135")
endif
set Lb=Lb-1
call Pdw(Vww_2,"when calling dispatch_UnitIndex_destroyUnitIndex in UnitIndexer, line 169")
set Lb=Lb-1
return true
endif
endfunction
function ruw takes string uuw returns nothing
set Xb[Lb]=uuw
set Lb=Lb+1
call Bww(Mc[wo-1],"when calling deindex in UnitIndexer, line 197")
set Lb=Lb-1
endfunction
function Cxw takes nothing returns nothing
set Lb=0
call ruw("UnitIndexer, line 197")
endfunction
function D1 takes nothing returns nothing
set nc=nc+0.030
endfunction
function DD takes nothing returns nothing
call UnitRemoveAbility(GetTriggerUnit(),1093677402)
endfunction
function DK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function DQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988812,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988559,0)
endfunction
function DT takes nothing returns nothing
call SetFloatGameState(GAME_STATE_TIME_OF_DAY,bj_MELEE_STARTING_TOD)
call MeleeStartingHeroLimit()
endfunction
function ovw takes integer tvw,integer ivw,integer Svw,string cvw returns nothing
if ivw<0 or ivw>=24 then
call I1("Index out of Bounds",cvw)
elseif ivw<=11 then
if ivw<=5 then
if ivw<=2 then
if ivw<=1 then
if ivw<=0 then
set Nb[tvw]=Svw
else
set Mb[tvw]=Svw
endif
else
set wy[tvw]=Svw
endif
elseif ivw<=4 then
if ivw<=3 then
set uy[tvw]=Svw
else
set ry[tvw]=Svw
endif
else
set sy[tvw]=Svw
endif
elseif ivw<=8 then
if ivw<=7 then
if ivw<=6 then
set ty[tvw]=Svw
else
set iy[tvw]=Svw
endif
else
set Sy[tvw]=Svw
endif
elseif ivw<=10 then
if ivw<=9 then
set cy[tvw]=Svw
else
set oy[tvw]=Svw
endif
else
set Oy[tvw]=Svw
endif
elseif ivw<=17 then
if ivw<=14 then
if ivw<=13 then
if ivw<=12 then
set ly[tvw]=Svw
else
set by[tvw]=Svw
endif
else
set yy[tvw]=Svw
endif
elseif ivw<=16 then
if ivw<=15 then
set py[tvw]=Svw
else
set ey[tvw]=Svw
endif
else
set qy[tvw]=Svw
endif
elseif ivw<=20 then
if ivw<=19 then
if ivw<=18 then
set ay[tvw]=Svw
else
set ny[tvw]=Svw
endif
else
set dy[tvw]=Svw
endif
elseif ivw<=22 then
if ivw<=21 then
set fy[tvw]=Svw
else
set Ry[tvw]=Svw
endif
else
set Ty[tvw]=Svw
endif
endfunction
function pvw takes integer Ovw,integer lvw,string bvw returns integer
local integer yvw
if lvw<0 or lvw>=24 then
call I1("Index out of Bounds",bvw)
elseif lvw<=11 then
if lvw<=5 then
if lvw<=2 then
if lvw<=1 then
if lvw<=0 then
set yvw=Nb[Ovw]
else
set yvw=Mb[Ovw]
endif
else
set yvw=wy[Ovw]
endif
elseif lvw<=4 then
if lvw<=3 then
set yvw=uy[Ovw]
else
set yvw=ry[Ovw]
endif
else
set yvw=sy[Ovw]
endif
elseif lvw<=8 then
if lvw<=7 then
if lvw<=6 then
set yvw=ty[Ovw]
else
set yvw=iy[Ovw]
endif
else
set yvw=Sy[Ovw]
endif
elseif lvw<=10 then
if lvw<=9 then
set yvw=cy[Ovw]
else
set yvw=oy[Ovw]
endif
else
set yvw=Oy[Ovw]
endif
elseif lvw<=17 then
if lvw<=14 then
if lvw<=13 then
if lvw<=12 then
set yvw=ly[Ovw]
else
set yvw=by[Ovw]
endif
else
set yvw=yy[Ovw]
endif
elseif lvw<=16 then
if lvw<=15 then
set yvw=py[Ovw]
else
set yvw=ey[Ovw]
endif
else
set yvw=qy[Ovw]
endif
elseif lvw<=20 then
if lvw<=19 then
if lvw<=18 then
set yvw=ay[Ovw]
else
set yvw=ny[Ovw]
endif
else
set yvw=dy[Ovw]
endif
elseif lvw<=22 then
if lvw<=21 then
set yvw=fy[Ovw]
else
set yvw=Ry[Ovw]
endif
else
set yvw=Ty[Ovw]
endif
return yvw
endfunction
function mew takes integer Few,player kew,integer jew,string xew returns nothing
local integer vew
set Xb[Lb]=xew
set Lb=Lb+1
set vew=GetPlayerId(kew)
if not Pb[Few]then
set Lb=Lb-1
return
endif
if vew>=24 then
set Lb=Lb-1
return
endif
if pvw(Few,vew,"when reading array PlayerStats_alliance_states in  in PlayerStats, line 61")==jew or kew==Ib[Few]then
set Lb=Lb-1
return
endif
call ovw(Few,vew,jew,"when writing array PlayerStats_alliance_states in PlayerStats, line 63")
call SetPlayerAllianceStateBJ(Ib[Few],kew,jew)
set Lb=Lb-1
endfunction
function hew takes integer Oew,string lew returns nothing
local integer bew
local integer yew
local integer pew
local integer eew
local player qew
local integer aew
local integer dew
local player few
local integer Rew
local player Tew
local fogstate Yew
local location Gew
local rect gew
set Xb[Lb]=lew
set Lb=Lb+1
set Hb[Oew]=true
set bew=GetPlayerId(Ib[Oew])
set yew=0
set pew=23
loop
exitwhen yew>pew
set eew=uo[yew]
set qew=Ib[Oew]
set aew=bj_ALLIANCE_UNALLIED
set Xb[Lb]="when calling setAlliance in PlayerStats, line 37"
set Lb=Lb+1
if ll[eew]==0 then
if eew==0 then
call I1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call I1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call mew(eew,qew,aew,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set dew=uo[bew]
set few=ro[yew]
set Rew=bj_ALLIANCE_UNALLIED
set lew="when calling setAlliance in PlayerStats, line 38"
set Xb[Lb]="when calling setAlliance in PlayerStats, line 38"
set Lb=Lb+1
if ll[dew]==0 then
if dew==0 then
call I1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call I1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call mew(dew,few,Rew,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set yew=yew+1
endloop
set Tew=Ib[Oew]
set Yew=FOG_OF_WAR_VISIBLE
set gew=bj_mapInitialPlayableArea
set Gew=Location(GetRectCenterX(gew),GetRectCenterY(gew))
set bj_lastCreatedFogModifier=CreateFogModifierRadiusLoc(Tew,Yew,Gew,999999.00,true,false)
call FogModifierStart(bj_lastCreatedFogModifier)
set Lb=Lb-1
set qew=null
set few=null
set Tew=null
set Yew=null
set Gew=null
set gew=null
endfunction
function n2 takes player p2 returns nothing
local fogstate e2
local location q2
local rect a2
call SetPlayerState(p2,PLAYER_STATE_RESOURCE_GOLD,99999999)
call SetPlayerState(p2,PLAYER_STATE_RESOURCE_LUMBER,99999999)
set e2=FOG_OF_WAR_VISIBLE
set a2=bj_mapInitialPlayableArea
set q2=Location(GetRectCenterX(a2),GetRectCenterY(a2))
set bj_lastCreatedFogModifier=CreateFogModifierRadiusLoc(p2,e2,q2,999999.00,true,false)
call FogModifierStart(bj_lastCreatedFogModifier)
set e2=null
set q2=null
set a2=null
endfunction
function qaw takes integer yaw,string paw,string eaw returns nothing
set Xb[Lb]=eaw
set Lb=Lb+1
if qO[yaw]==0 then
if yaw==0 then
call I1("Nullpointer exception when calling City.changeCityName","when calling error in City, line 171")
else
call I1("Called City.changeCityName on invalid object.","when calling error in City, line 171")
endif
endif
set Xb[Lb]="when calling changeCityName in City, line 171"
set Lb=Lb+1
set jl[yaw]=SubString(paw,0,24)
set Xb[Lb]="when calling refreshMultiboardIfPossible in City, line 174"
set Lb=Lb+1
if qO[yaw]==0 then
if yaw==0 then
call I1("Nullpointer exception when calling City.refreshMultiboardIfPossible","when calling error in City, line 250")
else
call I1("Called City.refreshMultiboardIfPossible on invalid object.","when calling error in City, line 250")
endif
endif
call Rtw(yaw,"when calling refreshMultiboardIfPossible in City, line 250")
set Lb=Lb-1-1-1
endfunction
function Arw takes integer Erw,player Zrw,string Urw returns nothing
local integer Irw
local integer Prw
set Xb[Lb]=Urw
set Lb=Lb+1
if Erw<0 then
set Lb=Lb-1
return
endif
if not Dnw(tO[Erw],GetPlayerId(Zrw),"when calling has in VoteKick, line 44") then
set sO[Erw]=sO[Erw]+1
set Irw=tO[Erw]
set Prw=GetPlayerId(Zrw)
set Xb[Lb]="when calling add in VoteKick, line 46"
set Lb=Lb+1
if IO[Irw]==0 then
if Irw==0 then
call I1("Nullpointer exception when calling HashSet.add","when calling error in HashSet, line 9")
else
call I1("Called HashSet.add on invalid object.","when calling error in HashSet, line 9")
endif
endif
call jjw(Irw,Prw,"when calling add in HashSet, line 9")
set Lb=Lb-1
endif
set Lb=Lb-1
endfunction
function Gbw takes integer fbw,integer Rbw returns integer
local integer Tbw=Tb[Fb[fbw]]
local integer Ybw=0
loop
exitwhen Tbw==Fb[fbw]
if fb[Tbw]==Rbw then
return Ybw
endif
set Tbw=Tb[Tbw]
set Ybw=Ybw+1
endloop
return -1
endfunction
function Rww takes string yww,string pww returns integer
local integer eww_2
local integer qww
local boolean aww
local integer nww
local string dww
local integer fww
set Xb[Lb]=pww
set Lb=Lb+1
set eww_2=StringHash(yww)
loop
set qww=Ao
set pww="when calling hasString in TypeCasting, line 25"
set Xb[Lb]="when calling hasString in TypeCasting, line 25"
set Lb=Lb+1
if HO[qww]==0 then
if qww==0 then
call I1("Nullpointer exception when calling Table.hasString","when calling error in Table, line 18")
else
call I1("Called Table.hasString on invalid object.","when calling error in Table, line 18")
endif
endif
set aww=HaveSavedString(Zo,qww,eww_2)
set Lb=Lb-1
if aww then
set nww=Ao
set Xb[Lb]="when calling loadString in TypeCasting, line 26"
set Lb=Lb+1
if HO[nww]==0 then
if nww==0 then
call I1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call I1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set dww=LoadStr(Zo,nww,eww_2)
set Lb=Lb-1
exitwhen dww==yww
else
set fww=Ao
set Xb[Lb]="when calling saveString in TypeCasting, line 29"
set Lb=Lb+1
if HO[fww]==0 then
if fww==0 then
call I1("Nullpointer exception when calling Table.saveString","when calling error in Table, line 60")
else
call I1("Called Table.saveString on invalid object.","when calling error in Table, line 60")
endif
endif
call SaveStr(Zo,fww,eww_2,yww)
set Lb=Lb-1
exitwhen true
endif
set eww_2=eww_2+1
endloop
set Lb=Lb-1
return eww_2
endfunction
function Wrw takes string vrw returns integer
local integer mrw=0
local integer Qrw=23
loop
exitwhen mrw>Qrw
if GetPlayerName(ro[mrw])==vrw then
return mrw
endif
set mrw=mrw+1
endloop
return -1
endfunction
function Grw takes nothing returns integer
local integer drw=0
local integer frw=0
local integer Rrw=23
local player Trw
local boolean Yrw
loop
exitwhen frw>Rrw
set Trw=ro[frw]
if GetPlayerSlotState(Trw)==PLAYER_SLOT_STATE_PLAYING then
set Yrw=GetPlayerController(Trw)==MAP_CONTROL_USER
else
set Yrw=false
endif
if Yrw then
set drw=drw+1
endif
set frw=frw+1
endloop
set Trw=null
return R2I((drw-1)*1./2)+1
endfunction
function xrw takes integer grw returns nothing
local string hrw
local force Frw
local string krw
local force jrw
if grw<0 then
set Frw=null
set jrw=null
return
endif
if sO[grw]>=Grw() then
call CustomDefeatBJ(ro[grw],"You've been kicked from the game!")
set hrw="The player "+HB(ro[grw])+" has been kicked with the power of democracy!"
set Frw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),Frw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,hrw)
endif
else
set krw=I2S(sO[grw])+" |cffff0000out of|r "+I2S(Grw())+" |cffff0000voted to kick the player|r "+HB(ro[grw])+"! |cff00ffdd(player number is "+I2S(grw)+")|r"
set jrw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),jrw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,krw)
endif
endif
set Frw=null
set jrw=null
endfunction
function usw takes player Drw,string Hrw,string Jrw returns nothing
local integer Krw
local integer Lrw
local integer Xrw
local boolean Crw
local integer Vrw
local integer Brw
local integer Nrw
local boolean Mrw
local boolean wsw
set Xb[Lb]=Jrw
set Lb=Lb+1
if StringLength(Hrw)<=2 then
set Mrw=S2I(Hrw)>0
else
set Mrw=false
endif
if Mrw then
set wsw=S2I(Hrw)<24
else
set wsw=false
endif
if wsw then
set Krw=S2I(Hrw)
else
set Lrw=wc
set Xrw=Rww(Hrw,"when calling stringToIndex in VoteKick, line 54")
set Xb[Lb]="when calling has in VoteKick, line 54"
set Lb=Lb+1
if tl[Lrw]==0 then
if Lrw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Crw=kbw(Lrw,Xrw)
set Lb=Lb-1
if Crw then
set Vrw=wc
set Brw=Rww(Hrw,"when calling stringToIndex in VoteKick, line 55")
set Xb[Lb]="when calling indexOf in VoteKick, line 55"
set Lb=Lb+1
if tl[Vrw]==0 then
if Vrw==0 then
call I1("Nullpointer exception when calling LinkedList.indexOf","when calling error in LinkedList, line 54")
else
call I1("Called LinkedList.indexOf on invalid object.","when calling error in LinkedList, line 54")
endif
endif
set Nrw=Gbw(Vrw,Brw)
set Lb=Lb-1
set Krw=Nrw
elseif Wrw(Hrw)!=-1 then
set Krw=Wrw(Hrw)
else
set Xb[Lb]="when calling noteToPlayer in VoteKick, line 59"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Drw,0.,0.,10.0,t5(Drw,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(Drw,0.,0.,10.0,"Couldn't find player: '"+Hrw+"'")
set Lb=Lb-1-1
return
endif
endif
call Arw(Krw,Drw,"when calling addVote in VoteKick, line 62")
call xrw(Krw)
set Lb=Lb-1
endfunction
function xX takes string dX,string fX returns string
local integer RX
local integer TX
local integer YX
local integer GX
local integer gX
local boolean hX
local integer FX
local integer kX
local integer jX
set Xb[Lb]=fX
set Lb=Lb+1
set RX=0
set TX=23
loop
exitwhen RX>TX
if dX==GetPlayerName(ro[RX]) then
set Lb=Lb-1
return iS[RX]
endif
set RX=RX+1
endloop
set GX=wc
set gX=Rww(dX,"when calling stringToIndex in BNetName, line 26")
set Xb[Lb]="when calling has in BNetName, line 26"
set Lb=Lb+1
if tl[GX]==0 then
if GX==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set hX=kbw(GX,gX)
set Lb=Lb-1
if hX then
set FX=wc
set kX=Rww(dX,"when calling stringToIndex in BNetName, line 27")
set Xb[Lb]="when calling indexOf in BNetName, line 27"
set Lb=Lb+1
if tl[FX]==0 then
if FX==0 then
call I1("Nullpointer exception when calling LinkedList.indexOf","when calling error in LinkedList, line 54")
else
call I1("Called LinkedList.indexOf on invalid object.","when calling error in LinkedList, line 54")
endif
endif
set jX=Gbw(FX,kX)
set Lb=Lb-1
set fX=iS[jX]
set Lb=Lb-1
return fX
endif
set YX=S2I(dX)
if YX>=0 and YX<24 then
set Lb=Lb-1
return iS[YX]
endif
set Lb=Lb-1
return ""
endfunction
function OM takes string bN returns nothing
local string array yN
local string pN
local player eN
local integer qN
local integer aN
local integer nN
local string dN
local string fN
local integer RN
local boolean TN
local group YN
local string GN
local player gN
local camerafield hN
local player FN
local camerafield kN
local integer jN
local integer xN
local integer vN
local unit mN
local integer QN
local integer WN
local integer EN
local integer ZN
local integer UN
local integer IN
local integer PN
local integer AN
local integer DN
local integer HN
local integer JN
local player KN
local camerafield LN
local real XN
local integer CN
local boolean VN
local group BN
local unit NN
local integer MN
local string wM
local force uM
local integer rM
local integer sM
local integer tM
local real iM
local boolean SM
local boolean cM
local boolean oM
set Xb[Lb]=bN
set Lb=Lb+1
set bN=GetEventPlayerChatString()
set pN=""
set eN=GetTriggerPlayer()
set qN=0
set aN=1
set nN=StringLength(bN)
loop
exitwhen aN>nN
set dN=SubString(bN,aN,aN+1)
if qN>0 then
set SM=aN>StringLength(yN[0])+1
else
set SM=false
endif
if SM then
set pN=pN+dN
endif
if dN!=" " then
set yN[qN]=yN[qN]+dN
else
set qN=qN+1
endif
set aN=aN+1
endloop
if yN[0]=="far" then
set gN=GetTriggerPlayer()
set hN=CAMERA_FIELD_TARGET_DISTANCE
if GetLocalPlayer()==gN then
call SetCameraField(hN,3000.0,0.)
endif
elseif yN[0]=="med" then
set FN=GetTriggerPlayer()
set kN=CAMERA_FIELD_TARGET_DISTANCE
if GetLocalPlayer()==FN then
call SetCameraField(kN,2300.0,0.)
endif
elseif yN[0]=="name" then
call SetPlayerName(GetTriggerPlayer(),SubString(pN,0,40))
elseif yN[0]=="rename" then
set jN=uo[GetPlayerId(eN)]
set Xb[Lb]="when calling getSelectedCityId in Commands, line 53"
set Lb=Lb+1
if ll[jN]==0 then
if jN==0 then
call I1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call I1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set xN=Ab[jN]
set Lb=Lb-1
if xN>=0 and xN<fS then
set vN=kS[xN]
set Xb[Lb]="when calling getCityUnit in Commands, line 55"
set Lb=Lb+1
if qO[vN]==0 then
if vN==0 then
call I1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call I1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set mN=kl[vN]
set Lb=Lb-1
if GetOwningPlayer(mN)!=eN then
set Xb[Lb]="when calling noteToPlayer in Commands, line 56"
set Lb=Lb+1
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,t5(eN,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,"The city you wanted to rename so eagerly doesn't belong to you!")
set Lb=Lb-1
else
call qaw(kS[xN],pN,"when calling changeCityName in Commands, line 58")
endif
endif
elseif yN[0]=="add_mod" then
set QN=uo[GetPlayerId(eN)]
set Xb[Lb]="when calling getSelectedCityId in Commands, line 60"
set Lb=Lb+1
if ll[QN]==0 then
if QN==0 then
call I1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call I1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set WN=Ab[QN]
set Lb=Lb-1
if not Fc then
set Lb=Lb-1
set eN=null
set YN=null
set gN=null
set hN=null
set FN=null
set kN=null
set mN=null
set KN=null
set LN=null
set BN=null
set NN=null
set uM=null
return
endif
if WN>=0 and WN<fS then
set fN=yN[1]
if fN=="massacred_pop" then
set EN=kS[WN]
set Xb[Lb]="when calling addModifier in Commands, line 66"
set Lb=Lb+1
if qO[EN]==0 then
if EN==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(EN,6,"when calling addModifier in City, line 365")
set Lb=Lb-1
elseif fN=="recently_conquered" then
set ZN=kS[WN]
set Xb[Lb]="when calling addModifier in Commands, line 68"
set Lb=Lb+1
if qO[ZN]==0 then
if ZN==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(ZN,0,"when calling addModifier in City, line 365")
set Lb=Lb-1
elseif fN=="recently_revolted" then
set UN=kS[WN]
set Xb[Lb]="when calling addModifier in Commands, line 70"
set Lb=Lb+1
if qO[UN]==0 then
if UN==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(UN,1,"when calling addModifier in City, line 365")
set Lb=Lb-1
elseif fN=="more_trade_estabilished" then
set IN=kS[WN]
set Xb[Lb]="when calling addModifier in Commands, line 72"
set Lb=Lb+1
if qO[IN]==0 then
if IN==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(IN,5,"when calling addModifier in City, line 365")
set Lb=Lb-1
elseif fN=="on_fire" then
set PN=kS[WN]
set Xb[Lb]="when calling addModifier in Commands, line 74"
set Lb=Lb+1
if qO[PN]==0 then
if PN==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(PN,4,"when calling addModifier in City, line 365")
set Lb=Lb-1
elseif fN=="plague_outburst" then
set AN=kS[WN]
set Xb[Lb]="when calling addModifier in Commands, line 76"
set Lb=Lb+1
if qO[AN]==0 then
if AN==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(AN,3,"when calling addModifier in City, line 365")
set Lb=Lb-1
elseif fN=="population_boom" then
set DN=kS[WN]
set Xb[Lb]="when calling addModifier in Commands, line 78"
set Lb=Lb+1
if qO[DN]==0 then
if DN==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(DN,2,"when calling addModifier in City, line 365")
set Lb=Lb-1
elseif fN=="prospering" then
set HN=kS[WN]
set Xb[Lb]="when calling addModifier in Commands, line 80"
set Lb=Lb+1
if qO[HN]==0 then
if HN==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(HN,7,"when calling addModifier in City, line 365")
set Lb=Lb-1
elseif fN=="sieged" then
set JN=kS[WN]
set Xb[Lb]="when calling addModifier in Commands, line 82"
set Lb=Lb+1
if qO[JN]==0 then
if JN==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(JN,8,"when calling addModifier in City, line 365")
set Lb=Lb-1
endif
endif
elseif yN[0]=="" then
set Fc=not Fc
set hc=not hc
call n2(eN)
elseif yN[0]=="votekick" then
call usw(eN,pN,"when calling voteKick in Commands, line 88")
elseif yN[0]=="zoom" then
set RN=S2I(yN[1])
set KN=GetTriggerPlayer()
set LN=CAMERA_FIELD_TARGET_DISTANCE
set XN=RN*1.
if GetLocalPlayer()==KN then
call SetCameraField(LN,XN,0.)
endif
elseif yN[0]=="observe" then
set CN=uo[GetPlayerId(eN)]
set Xb[Lb]="when calling isObserver in Commands, line 93"
set Lb=Lb+1
if ll[CN]==0 then
if CN==0 then
call I1("Nullpointer exception when calling PlayerStats.isObserver","when calling error in PlayerStats, line 29")
else
call I1("Called PlayerStats.isObserver on invalid object.","when calling error in PlayerStats, line 29")
endif
endif
set VN=Hb[CN]
set Lb=Lb-1
if not VN then
set TN=true
set BN=CreateGroup()
call GroupEnumUnitsOfPlayer(BN,eN,null)
call DestroyBoolExpr(null)
set dc=CreateGroup()
call ForGroup(BN,Af)
set YN=dc
loop
exitwhen FirstOfGroup(YN)==null
set NN=FirstOfGroup(YN)
call GroupRemoveUnit(YN,NN)
if not IsUnitHidden(NN) then
set cM=GetUnitTypeId(NN)!=1211118391
else
set cM=false
endif
if cM then
set oM=GetUnitTypeId(NN)!=1211118406
else
set oM=false
endif
if oM then
set TN=false
endif
endloop
call GroupClear(YN)
call DestroyGroup(YN)
if TN then
set MN=uo[GetPlayerId(eN)]
set Xb[Lb]="when calling becomeObserver in Commands, line 100"
set Lb=Lb+1
if ll[MN]==0 then
if MN==0 then
call I1("Nullpointer exception when calling PlayerStats.becomeObserver","when calling error in PlayerStats, line 32")
else
call I1("Called PlayerStats.becomeObserver on invalid object.","when calling error in PlayerStats, line 32")
endif
endif
call hew(MN,"when calling becomeObserver in PlayerStats, line 32")
set Lb=Lb-1
set wM=HB(eN)+" has just became an observer."
set uM=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),uM) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,wM)
endif
else
set Xb[Lb]="when calling noteToPlayer in Commands, line 103"
set Lb=Lb+1
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,t5(eN,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,"To become an observer, you should have no units!")
set Lb=Lb-1
endif
endif
elseif yN[0]=="add_po" then
if not Fc then
set Lb=Lb-1
set eN=null
set YN=null
set gN=null
set hN=null
set FN=null
set kN=null
set mN=null
set KN=null
set LN=null
set BN=null
set NN=null
set uM=null
return
endif
set rM=uo[GetPlayerId(eN)]
set Xb[Lb]="when calling getSelectedCityId in Commands, line 107"
set Lb=Lb+1
if ll[rM]==0 then
if rM==0 then
call I1("Nullpointer exception when calling PlayerStats.getSelectedCityId","when calling error in PlayerStats, line 112")
else
call I1("Called PlayerStats.getSelectedCityId on invalid object.","when calling error in PlayerStats, line 112")
endif
endif
set sM=Ab[rM]
set Lb=Lb-1
if sM>=0 and sM<fS then
set tM=kS[sM]
set iM=S2R(yN[1])
set Xb[Lb]="when calling addPublicOrder in Commands, line 109"
set Lb=Lb+1
if qO[tM]==0 then
if tM==0 then
call I1("Nullpointer exception when calling City.addPublicOrder","when calling error in City, line 332")
else
call I1("Called City.addPublicOrder on invalid object.","when calling error in City, line 332")
endif
endif
set Pl[tM]=Pl[tM]+iM
set Lb=Lb-1
endif
elseif yN[0]=="bnet" then
set GN=xX(pN,"when calling getBNetName in Commands, line 111")
if GN=="" then
set Xb[Lb]="when calling noteToPlayer in Commands, line 113"
set Lb=Lb+1
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,t5(eN,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,"Couldn't find player: '"+pN+"'")
set Lb=Lb-1
else
set Xb[Lb]="when calling noteToPlayer in Commands, line 115"
set Lb=Lb+1
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,t5(eN,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,"The name of "+pN+" is "+GN)
set Lb=Lb-1
endif
else
set Xb[Lb]="when calling noteToPlayer in Commands, line 117"
set Lb=Lb+1
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,t5(eN,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(eN,0.,0.,10.0,"Couldn't find command: '"+yN[0]+"'")
set Lb=Lb-1
endif
set Lb=Lb-1
set eN=null
set YN=null
set gN=null
set hN=null
set FN=null
set kN=null
set mN=null
set KN=null
set LN=null
set BN=null
set NN=null
set uM=null
endfunction
function Dxw takes nothing returns nothing
set Lb=0
call OM("Commands, line 126")
endfunction
function WA takes nothing returns boolean
if GetResearched()!=1378890054 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890054,true)!=1 then
return false
endif
return true
endfunction
function EA takes nothing returns boolean
if not WA() then
return false
endif
return true
endfunction
function WJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990356 then
return false
endif
return true
endfunction
function EJ takes nothing returns boolean
if not WJ() then
return false
endif
return true
endfunction
function ET takes nothing returns nothing
call ReplaceUnitBJ(GetEnumUnit(),1747988553,bj_UNIT_STATE_METHOD_RELATIVE)
endfunction
function Wm takes nothing returns boolean
if GetResearched()!=1378889796 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889796,true)!=2 then
return false
endif
return true
endfunction
function Em takes nothing returns boolean
if not Wm() then
return false
endif
return true
endfunction
function Eww takes nothing returns boolean
set Zo=InitHashtable()
return true
endfunction
function Ex takes nothing returns nothing
local player Gx=GetOwningPlayer(GetSpellTargetUnit())
local playerstate gx=PLAYER_STATE_RESOURCE_LUMBER
local playerstate hx
local playerstate Fx
local player kx
local force jx
local location xx
local real vx
local real mx
local player Qx
local force Wx
if gx==PLAYER_STATE_RESOURCE_GOLD then
set hx=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Gx,hx,GetPlayerState(Gx,hx)+500)
elseif gx==PLAYER_STATE_RESOURCE_LUMBER then
set Fx=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Gx,Fx,GetPlayerState(Gx,Fx)+500)
endif
call SetPlayerState(Gx,gx,GetPlayerState(Gx,gx)+500)
call RemoveUnit(GetSpellAbilityUnit())
set kx=GetOwningPlayer(GetSpellTargetUnit())
set jx=CreateForce()
call ForceAddPlayer(jx,kx)
if IsPlayerInForce(GetLocalPlayer(),jx) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1232")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set Qx=GetOwningPlayer(GetSpellTargetUnit())
set Wx=CreateForce()
call ForceAddPlayer(Wx,Qx)
set xx=y
set vx=GetLocationX(xx)
set mx=GetLocationY(xx)
if IsPlayerInForce(GetLocalPlayer(),Wx) then
call PingMinimap(vx,mx,2.00)
endif
call RemoveLocation(y)
set Gx=null
set gx=null
set hx=null
set Fx=null
set kx=null
set jx=null
set xx=null
set Qx=null
set Wx=null
endfunction
function srw takes string Luw returns boolean
local trigger Xuw
local playerunitevent Cuw
local playerunitevent Vuw
local integer Buw
local integer Nuw
local rect Muw
local region wrw
local integer urw
local integer rrw
set Xb[Lb]=Luw
set Lb=Lb+1
set Cuw=EVENT_PLAYER_UNIT_SPELL_FINISH
set Xb[Lb]="when calling alloc_Upkeep_EventListener_line8 in Upkeep, line 8"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set Buw=cO
set oO[Buw]=684
else
call I1("Out of memory: Could not create Upkeep_EventListener_line8.","when calling error in Upkeep, line 8")
set Buw=0
endif
else
set SO=SO-1
set Buw=iO[SO]
set oO[Buw]=684
endif
set Lb=Lb-1
set Ml[Buw]=0
set wb[Buw]=0
set ub[Buw]=0
set Xb[Lb]="when calling add in Upkeep, line 8"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set Nuw=QS[GetHandleId(Cuw)]
if Nuw==0 then
set Nuw=QV(Cuw,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[Buw]=Nuw
if US[Ml[Buw]]!=0 then
set ub[US[Ml[Buw]]]=Buw
set wb[Buw]=US[Ml[Buw]]
endif
set US[Ml[Buw]]=Buw
set Lb=Lb-1
set Xuw=CreateTrigger()
set Muw=GetWorldBounds()
set wrw=CreateRegion()
call RegionAddRect(wrw,Muw)
call TriggerRegisterEnterRegion(Xuw,wrw,null)
call TriggerAddAction(Xuw,Vf)
set Vuw=EVENT_PLAYER_UNIT_DEATH
set Xb[Lb]="when calling alloc_Upkeep_EventListener_line34 in Upkeep, line 34"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set urw=cO
set oO[urw]=683
else
call I1("Out of memory: Could not create Upkeep_EventListener_line34.","when calling error in Upkeep, line 34")
set urw=0
endif
else
set SO=SO-1
set urw=iO[SO]
set oO[urw]=683
endif
set Lb=Lb-1
set Ml[urw]=0
set wb[urw]=0
set ub[urw]=0
set Xb[Lb]="when calling add in Upkeep, line 34"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set rrw=QS[GetHandleId(Vuw)]
if rrw==0 then
set rrw=QV(Vuw,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[urw]=rrw
if US[Ml[urw]]!=0 then
set ub[US[Ml[urw]]]=urw
set wb[urw]=US[Ml[urw]]
endif
set US[Ml[urw]]=urw
set Lb=Lb-1-1
set Xuw=null
set Cuw=null
set Vuw=null
set Muw=null
set wrw=null
return true
endfunction
function Exw takes nothing returns boolean
set Lb=0
return srw("Upkeep, line 1")
endfunction
function F1 takes nothing returns boolean
set cc=InitHashtable()
return true
endfunction
function h9 takes unit g9 returns nothing
call UnitAddAbility(g9,1095577649)
call UnitMakeAbilityPermanent(g9,true,1095577649)
set Mc[wo]=g9
set wo=wo+1
call TriggerEvaluate(Bc)
set wo=wo-1
endfunction
function F9 takes nothing returns nothing
call h9(GetFilterUnit())
endfunction
function FK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function FQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989067,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989065,0)
endfunction
function Q5 takes string j5 returns boolean
local integer x5
local integer v5
local timer m5
set Xb[Lb]=j5
set Lb=Lb+1
set Xb[Lb]="when calling alloc_MultiboardCityUpdate_CallbackSingle_line18 in MultiboardCityUpdate, line 18"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set x5=YO
set GO[x5]=649
else
call I1("Out of memory: Could not create MultiboardCityUpdate_CallbackSingle_line18.","when calling error in MultiboardCityUpdate, line 18")
set x5=0
endif
else
set TO=TO-1
set x5=RO[TO]
set GO[x5]=649
endif
set Lb=Lb-1
set Xb[Lb]="when calling doAfter in MultiboardCityUpdate, line 18"
set Lb=Lb+1
call jB(iww("when calling getTimer in ClosureTimers, line 27"),0.01,x5,"when calling doAfter in ClosureTimers, line 27")
set Lb=Lb-1
set Xb[Lb]="when calling alloc_MultiboardCityUpdate_CallbackPeriodic_line25 in MultiboardCityUpdate, line 25"
set Lb=Lb+1
if hO==0 then
if FO<32768 then
set FO=FO+1
set v5=FO
set kO[v5]=637
else
call I1("Out of memory: Could not create MultiboardCityUpdate_CallbackPeriodic_line25.","when calling error in MultiboardCityUpdate, line 25")
set v5=0
endif
else
set hO=hO-1
set v5=gO[hO]
set kO[v5]=637
endif
set Lb=Lb-1
set Xb[Lb]="when calling doPeriodically in MultiboardCityUpdate, line 25"
set Lb=Lb+1
set m5=iww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call onw(v5,m5,1.0,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set m5=null
return true
endfunction
function Fxw takes nothing returns boolean
set Lb=0
return Q5("MultiboardCityUpdate, line 1")
endfunction
function GB takes nothing returns boolean
set XS=200
return true
endfunction
function YF takes nothing returns boolean
local unitstate TF=UNIT_STATE_MANA
if GetUnitState(GetEnumUnit(),TF)>0.00 then
set TF=null
return false
endif
set TF=null
return true
endfunction
function GF takes nothing returns nothing
if YF() then
call KillUnit(GetEnumUnit())
endif
endfunction
function YL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990085 then
return false
endif
return true
endfunction
function GL takes nothing returns boolean
if not YL() then
return false
endif
return true
endfunction
function GP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990323,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990106,0)
endfunction
function YU takes nothing returns boolean
if GetResearched()!=1378890037 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890037,true)!=2 then
return false
endif
return true
endfunction
function GU takes nothing returns boolean
if not YU() then
return false
endif
return true
endfunction
function YW takes nothing returns boolean
if GetResearched()!=1378889803 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889803,true)!=1 then
return false
endif
return true
endfunction
function GW takes nothing returns boolean
if not YW() then
return false
endif
return true
endfunction
function GY takes nothing returns nothing
local player dY=GetOwningPlayer(GetAttacker())
local player fY=GetOwningPlayer(GetAttacker())
local player RY
local player TY
local unit YY
set r[GetPlayerId(dY)+1]=r[GetPlayerId(fY)+1]+1
set RY=GetOwningPlayer(GetTriggerUnit())
set TY=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(RY)+1]=r[GetPlayerId(TY)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set YY=GetTriggerUnit()
call SetUnitState(YY,UNIT_STATE_LIFE,GetUnitState(YY,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set dY=null
set fY=null
set RY=null
set TY=null
set YY=null
endfunction
function GZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989573,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989572,0)
endfunction
function Gww takes nothing returns boolean
return true
endfunction
function O4 takes string r4 returns boolean
local playerunitevent s4
local playerunitevent t4
local integer i4
local integer S4
local integer c4
local integer o4
set Xb[Lb]=r4
set Lb=Lb+1
set s4=EVENT_PLAYER_UNIT_DEATH
set Xb[Lb]="when calling alloc_LimitEncampments_EventListener_line8 in LimitEncampments, line 8"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set i4=cO
set oO[i4]=672
else
call I1("Out of memory: Could not create LimitEncampments_EventListener_line8.","when calling error in LimitEncampments, line 8")
set i4=0
endif
else
set SO=SO-1
set i4=iO[SO]
set oO[i4]=672
endif
set Lb=Lb-1
set Ml[i4]=0
set wb[i4]=0
set ub[i4]=0
set Xb[Lb]="when calling add in LimitEncampments, line 8"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set S4=QS[GetHandleId(s4)]
if S4==0 then
set S4=QV(s4,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[i4]=S4
if US[Ml[i4]]!=0 then
set ub[US[Ml[i4]]]=i4
set wb[i4]=US[Ml[i4]]
endif
set US[Ml[i4]]=i4
set Lb=Lb-1
set t4=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Xb[Lb]="when calling alloc_LimitEncampments_EventListener_line12 in LimitEncampments, line 12"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set c4=cO
set oO[c4]=671
else
call I1("Out of memory: Could not create LimitEncampments_EventListener_line12.","when calling error in LimitEncampments, line 12")
set c4=0
endif
else
set SO=SO-1
set c4=iO[SO]
set oO[c4]=671
endif
set Lb=Lb-1
set Ml[c4]=0
set wb[c4]=0
set ub[c4]=0
set Xb[Lb]="when calling add in LimitEncampments, line 12"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set o4=QS[GetHandleId(t4)]
if o4==0 then
set o4=QV(t4,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[c4]=o4
if US[Ml[c4]]!=0 then
set ub[US[Ml[c4]]]=c4
set wb[c4]=US[Ml[c4]]
endif
set US[Ml[c4]]=c4
set Lb=Lb-1-1
set s4=null
set t4=null
return true
endfunction
function Gxw takes nothing returns boolean
set Lb=0
return O4("LimitEncampments, line 1")
endfunction
function DA takes nothing returns boolean
if GetResearched()!=1378890054 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890054,true)!=2 then
return false
endif
return true
endfunction
function HA takes nothing returns boolean
if not DA() then
return false
endif
return true
endfunction
function DJ takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747990351 then
return false
endif
return true
endfunction
function HJ takes nothing returns boolean
if not DJ() then
return false
endif
return true
endfunction
function HT takes nothing returns nothing
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_097","TRIGSTR_098","ReplaceableTextures\\CommandButtons\\BTNSteelMelee.blp")
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_103","TRIGSTR_104","ReplaceableTextures\\WorldEditUI\\Doodad-Cinematic.blp")
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_2667","TRIGSTR_2668","ReplaceableTextures\\WorldEditUI\\Editor-MultipleUnits.blp")
endfunction
function DY takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1966092336 then
return false
endif
if GetSpellAbilityId()!=1093677906 then
return false
endif
if GetOwningPlayer(GetSpellTargetUnit())==Player(PLAYER_NEUTRAL_AGGRESSIVE) then
return false
endif
if IsUnitType(GetSpellTargetUnit(),UNIT_TYPE_STRUCTURE)!=true then
return false
endif
return true
endfunction
function HY takes nothing returns boolean
if not DY() then
return false
endif
return true
endfunction
function Hjw takes nothing returns boolean
local integer Djw
set Lb=0
set Xb[Lb]="Abilities, line 1"
set Lb=Lb+1
set Xb[Lb]="when calling asList in Abilities, line 17"
set Lb=Lb+1
set Djw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(Djw,1093677642,"when calling add in LinkedList, line 393")
call ffw(Djw,1093677641,"when calling add in LinkedList, line 393")
call ffw(Djw,1093677640,"when calling add in LinkedList, line 393")
call ffw(Djw,1093678155,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set tS=Djw
set Lb=Lb-1
return true
endfunction
function Dm takes nothing returns boolean
if GetResearched()!=1378889798 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889798,true)!=1 then
return false
endif
return true
endfunction
function Hm takes nothing returns boolean
if not Dm() then
return false
endif
return true
endfunction
function Hww_2 takes nothing returns boolean
return true
endfunction
function Ax takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747990581 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990580 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989813 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747988569 then
return true
endif
return false
endfunction
function Dx takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989049 then
return false
endif
if not Ax() then
return false
endif
return true
endfunction
function Hx takes nothing returns boolean
if not Dx() then
return false
endif
return true
endfunction
function K3 takes string Z3 returns boolean
local integer U3
local integer I3
local boolean P3
local integer A3
local boolean D3
local boolean H3
local boolean J3
set Xb[Lb]=Z3
set Lb=Lb+1
if GetOwningPlayer(GetSpellAbilityUnit())==GetOwningPlayer(GetSpellTargetUnit()) then
set H3=true
else
set I3=uo[GetPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]
set Xb[Lb]="when calling isObserver in Diplomacy, line 107"
set Lb=Lb+1
if ll[I3]==0 then
if I3==0 then
call I1("Nullpointer exception when calling PlayerStats.isObserver","when calling error in PlayerStats, line 29")
else
call I1("Called PlayerStats.isObserver on invalid object.","when calling error in PlayerStats, line 29")
endif
endif
set P3=Hb[I3]
set Lb=Lb-1
set H3=P3
endif
if H3 then
set J3=true
else
set A3=uo[GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))]
set Xb[Lb]="when calling isObserver in Diplomacy, line 108"
set Lb=Lb+1
if ll[A3]==0 then
if A3==0 then
call I1("Nullpointer exception when calling PlayerStats.isObserver","when calling error in PlayerStats, line 29")
else
call I1("Called PlayerStats.isObserver on invalid object.","when calling error in PlayerStats, line 29")
endif
endif
set D3=Hb[A3]
set Lb=Lb-1
set J3=D3
endif
if J3 then
set Lb=Lb-1
return false
endif
set U3=GetSpellAbilityId()
set Lb=Lb-1
return U3==1093677396 or U3==1093677397 or U3==1093677398 or U3==1093677400 or U3==1093677399
endfunction
function Hxw takes nothing returns boolean
set Lb=0
return K3("Diplomacy, line 118")
endfunction
function UL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990086 then
return false
endif
return true
endfunction
function IL takes nothing returns boolean
if not UL() then
return false
endif
return true
endfunction
function IP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990594,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990584,0)
endfunction
function UU takes nothing returns boolean
if GetResearched()!=1378890034 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890034,true)!=2 then
return false
endif
return true
endfunction
function IU takes nothing returns boolean
if not UU() then
return false
endif
return true
endfunction
function UW takes nothing returns boolean
if GetResearched()!=1378889783 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889783,true)!=2 then
return false
endif
return true
endfunction
function IW takes nothing returns boolean
if not UW() then
return false
endif
return true
endfunction
function IZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651832,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651830,0)
endfunction
function Ij takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988791 then
return false
endif
return true
endfunction
function initializeTable takes string stackPos returns nothing
local integer i_2
local integer this
local integer parentKey
set Xb[Lb]=stackPos
set Lb=Lb+1
set i_2=0
loop
exitwhen i_2>15
set this=MS
set parentKey=StringHash(NS[i_2])
set stackPos="when calling saveInt in Colors, line 206"
set Xb[Lb]="when calling saveInt in Colors, line 206"
set Lb=Lb+1
if HO[this]==0 then
if this==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,this,parentKey,i_2)
set Lb=Lb-1
set i_2=i_2+1
endloop
set Lb=Lb-1
endfunction
function nqw takes string qqw returns integer
local integer aqw
set Xb[Lb]=qqw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_Table in Table, line 5"
set Lb=Lb+1
if AO==0 then
if DO<32768 then
set DO=DO+1
set aqw=DO
set HO[aqw]=731
else
call I1("Out of memory: Could not create Table.","when calling error in Table, line 6")
set aqw=0
endif
else
set AO=AO-1
set aqw=PO[AO]
set HO[aqw]=731
endif
set Lb=Lb-1-1
return aqw
endfunction
function WB takes string QB returns boolean
set Xb[Lb]=QB
set Lb=Lb+1
set CS[0]=255
set VS[0]=2
set BS[0]=2
set CS[1]=0
set VS[1]=65
set BS[1]=255
set CS[2]=27
set VS[2]=229
set BS[2]=184
set CS[3]=83
set VS[3]=0
set BS[3]=128
set CS[4]=255
set VS[4]=252
set BS[4]=0
set CS[5]=254
set VS[5]=137
set BS[5]=13
set CS[6]=31
set VS[6]=191
set BS[6]=0
set CS[7]=228
set VS[7]=90
set BS[7]=175
set CS[8]=148
set VS[8]=149
set BS[8]=150
set CS[9]=125
set VS[9]=190
set BS[9]=241
set CS[10]=15
set VS[10]=97
set BS[10]=69
set CS[11]=77
set VS[11]=41
set BS[11]=3
set CS[12]=155
set VS[12]=0
set BS[12]=0
set CS[13]=0
set VS[13]=0
set BS[13]=195
set CS[14]=0
set VS[14]=234
set BS[14]=255
set CS[15]=190
set VS[15]=0
set BS[15]=254
set CS[16]=235
set VS[16]=205
set BS[16]=135
set CS[17]=248
set VS[17]=164
set BS[17]=139
set CS[18]=191
set VS[18]=255
set BS[18]=128
set CS[19]=220
set VS[19]=185
set BS[19]=235
set CS[20]=40
set VS[20]=40
set BS[20]=40
set CS[21]=235
set VS[21]=240
set BS[21]=255
set CS[22]=0
set VS[22]=120
set BS[22]=30
set CS[23]=164
set VS[23]=11
set BS[23]=51
set NS[0]="0"
set NS[1]="1"
set NS[2]="2"
set NS[3]="3"
set NS[4]="4"
set NS[5]="5"
set NS[6]="6"
set NS[7]="7"
set NS[8]="8"
set NS[9]="9"
set NS[10]="A"
set NS[11]="B"
set NS[12]="C"
set NS[13]="D"
set NS[14]="E"
set NS[15]="F"
set MS=nqw("when calling new_Table in Colors, line 154")
call initializeTable("when calling initializeTable in Colors, line 209")
set Lb=Lb-1
return true
endfunction
function Ijw takes nothing returns boolean
set Lb=0
return WB("Colors, line 1")
endfunction
function Zk takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function Uk takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988793 then
return false
endif
if not Zk() then
return false
endif
return true
endfunction
function Ik takes nothing returns boolean
if not Uk() then
return false
endif
return true
endfunction
function Iv takes nothing returns nothing
local player Fv=GetOwningPlayer(GetKillingUnit())
local playerstate kv=PLAYER_STATE_RESOURCE_LUMBER
local playerstate jv
local playerstate xv
local player vv
local force mv
local location Qv
local real Wv
local real Ev
local player Zv
local force Uv
if kv==PLAYER_STATE_RESOURCE_GOLD then
set jv=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Fv,jv,GetPlayerState(Fv,jv)+500)
elseif kv==PLAYER_STATE_RESOURCE_LUMBER then
set xv=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Fv,xv,GetPlayerState(Fv,xv)+500)
endif
call SetPlayerState(Fv,kv,GetPlayerState(Fv,kv)+500)
set vv=GetOwningPlayer(GetKillingUnit())
set mv=CreateForce()
call ForceAddPlayer(mv,vv)
if IsPlayerInForce(GetLocalPlayer(),mv) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_084")
endif
set y=GetUnitLoc(GetDyingUnit())
set Zv=GetOwningPlayer(GetDyingUnit())
set Uv=CreateForce()
call ForceAddPlayer(Uv,Zv)
set Qv=y
set Wv=GetLocationX(Qv)
set Ev=GetLocationY(Qv)
if IsPlayerInForce(GetLocalPlayer(),Uv) then
call PingMinimap(Wv,Ev,2.00)
endif
call RemoveLocation(y)
set Fv=null
set kv=null
set jv=null
set xv=null
set vv=null
set mv=null
set Qv=null
set Zv=null
set Uv=null
endfunction
function Ixw takes nothing returns nothing
set Lb=0
call sB("ClosureEvents, line 241")
endfunction
function J2 takes nothing returns boolean
return true
endfunction
function JA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990603,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990604,0)
endfunction
function JG takes nothing returns nothing
local location WG
local location EG
local real ZG
local real UG
local rect IG
local group PG
local group AG
local code DG
local boolean HG
set u=GetUnitLoc(GetSpellAbilityUnit())
set WG=u
set c=Location(GetLocationX(WG)+200.00,GetLocationY(WG)+0.00)
set EG=u
set ZG=GetLocationX(EG)
set UG=GetLocationY(EG)
set O=Rect(ZG-150,UG-140,ZG+150,UG+140)
set IG=O
set PG=CreateGroup()
call GroupEnumUnitsInRect(PG,IG,null)
call DestroyBoolExpr(null)
set l=PG
set AG=l
set DG=Ay
set HG=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(AG,DG)
if HG then
call DestroyGroup(AG)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747988825,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set WG=null
set EG=null
set IG=null
set PG=null
set AG=null
endfunction
function HI takes nothing returns boolean
if GetResearched()!=1378890038 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890038,true)!=1 then
return false
endif
return true
endfunction
function JI takes nothing returns boolean
if not HI() then
return false
endif
return true
endfunction
function JJ takes nothing returns nothing
call UnitAddAbility(GetConstructedStructure(),1093677896)
endfunction
function Jg takes nothing returns nothing
local location Wg
local location Eg
local real Zg
local real Ug
local rect Ig
local group Pg
local group Ag
local code Dg
local boolean Hg
set u=GetUnitLoc(GetSpellAbilityUnit())
set Wg=u
set S=Location(GetLocationX(Wg)+0.00,GetLocationY(Wg)+200.00)
set Eg=u
set Zg=GetLocationX(Eg)
set Ug=GetLocationY(Eg)
set o=Rect(Zg-140,Ug-150,Zg+140,Ug+150)
set Ig=o
set Pg=CreateGroup()
call GroupEnumUnitsInRect(Pg,Ig,null)
call DestroyBoolExpr(null)
set l=Pg
set Ag=l
set Dg=By
set Hg=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Ag,Dg)
if Hg then
call DestroyGroup(Ag)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990090,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set Wg=null
set Eg=null
set Ig=null
set Pg=null
set Ag=null
endfunction
function Jh takes nothing returns nothing
local location Wh
local location Eh
local real Zh
local real Uh
local rect Ih
local group Ph
local group Ah
local code Dh
local boolean Hh
set u=GetUnitLoc(GetSpellAbilityUnit())
set Wh=u
set S=Location(GetLocationX(Wh)+0.00,GetLocationY(Wh)+200.00)
set Eh=u
set Zh=GetLocationX(Eh)
set Uh=GetLocationY(Eh)
set o=Rect(Zh-140,Uh-150,Zh+140,Uh+150)
set Ih=o
set Ph=CreateGroup()
call GroupEnumUnitsInRect(Ph,Ih,null)
call DestroyBoolExpr(null)
set l=Ph
set Ah=l
set Dh=Sp
set Hh=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Ah,Dh)
if Hh then
call DestroyGroup(Ah)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989079,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set Wh=null
set Eh=null
set Ih=null
set Ph=null
set Ah=null
endfunction
function plw takes string blw returns integer
local integer ylw
set Xb[Lb]=blw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_HashMap in HashMap, line 7"
set Lb=Lb+1
if AO==0 then
if DO<32768 then
set DO=DO+1
set ylw=DO
set HO[ylw]=732
else
call I1("Out of memory: Could not create HashMap.","when calling error in HashMap, line 8")
set ylw=0
endif
else
set AO=AO-1
set ylw=PO[AO]
set HO[ylw]=732
endif
set Lb=Lb-1
set qb[ylw]=0
set Lb=Lb-1
return ylw
endfunction
function Jjw takes nothing returns boolean
set Lb=0
set Xb[Lb]="EventHelper, line 1"
set Lb=Lb+1
call plw("when calling new_HashMap in EventHelper, line 6")
call plw("when calling new_HashMap in EventHelper, line 7")
call nqw("when calling new_Table in EventHelper, line 8")
set Lb=Lb-1
return true
endfunction
function Jm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988551,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989081,0)
endfunction
function Jww takes nothing returns boolean
return true
endfunction
function N2 takes player L2,string X2 returns string
local integer C2
local integer V2
local integer B2
set Xb[Lb]=X2
set Lb=Lb+1
set V2=uo[GetPlayerId(L2)]
set Xb[Lb]="when calling getForceId in Messages, line 5"
set Lb=Lb+1
if ll[V2]==0 then
if V2==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set B2=Ub[V2]
set Lb=Lb-1
set C2=GetRandomInt(0,2)
if B2==0 then
set X2=do[C2]
elseif B2==1 then
set X2=fo[C2]
elseif B2==2 then
set X2=Ro[C2]
elseif B2==3 then
set X2=To[C2]
else
set X2="Warning!"
endif
set Lb=Lb-1
return "|cffff0000"+X2+"|r"
endfunction
function l5 takes player i5,string S5 returns string
local integer c5
local integer o5
local integer O5
set Xb[Lb]=S5
set Lb=Lb+1
set o5=uo[GetPlayerId(i5)]
set Xb[Lb]="when calling getForceId in Messages, line 37"
set Lb=Lb+1
if ll[o5]==0 then
if o5==0 then
call I1("Nullpointer exception when calling PlayerStats.getForceId","when calling error in PlayerStats, line 122")
else
call I1("Called PlayerStats.getForceId on invalid object.","when calling error in PlayerStats, line 122")
endif
endif
set O5=Ub[o5]
set Lb=Lb-1
set c5=GetRandomInt(0,2)
if O5==0 then
set S5=Fo[c5]
elseif O5==1 then
set S5=ko[c5]
elseif O5==2 then
set S5=jo[c5]
elseif O5==3 then
set S5=xo[c5]
else
set S5="Good news!"
endif
set Lb=Lb-1
return "|cff00ff00"+S5+"|r"
endfunction
function E3 takes string xM returns nothing
local player vM
local player mM
local string QM
local integer WM
local force EM
local force ZM
local integer UM
local integer IM
local integer PM
local integer AM
local integer DM
local integer HM
local integer JM
local integer KM
local integer LM
local force XM
local force CM
local integer VM
local integer BM
local integer NM
local integer MM
local integer w3
local integer u3
local player r3
local force s3
local player t3
local player i3
local player S3
local integer c3
local integer o3
local integer O3
local integer l3
local player b3
local force y3
local player p3
local player e3
local player q3
local integer a3
local integer n3
local integer d3
local integer f3
local player R3
local force T3
local player Y3
local player G3
local player g3
local integer h3
local integer F3
local integer k3
local integer j3
local player x3
local force v3
local player m3
local player Q3
local player W3
set Xb[Lb]=xM
set Lb=Lb+1
set vM=GetOwningPlayer(GetSpellAbilityUnit())
set mM=GetOwningPlayer(GetSpellTargetUnit())
set QM=HB(vM)
set xM=HB(mM)
set WM=GetPlayerId(vM)
set XM=CreateForce()
call ForceAddPlayer(XM,vM)
set EM=XM
set CM=CreateForce()
call ForceAddPlayer(CM,vM)
set ZM=CM
set UM=GetSpellAbilityId()
if UM==1093677396 then
set VM=uo[WM]
set Xb[Lb]="when calling getAllianceState in Diplomacy, line 16"
set Lb=Lb+1
if ll[VM]==0 then
if VM==0 then
call I1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call I1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Xb[Lb]="when calling getAllianceState in PlayerStats, line 66"
set Lb=Lb+1
set BM=pvw(VM,GetPlayerId(mM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Lb=Lb-1-1
if BM==bj_ALLIANCE_UNALLIED then
set Lb=Lb-1
set vM=null
set mM=null
set EM=null
set ZM=null
set XM=null
set CM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
set x3=null
set v3=null
set m3=null
set Q3=null
set W3=null
return
endif
set NM=uo[WM]
set MM=bj_ALLIANCE_UNALLIED
set Xb[Lb]="when calling setAlliance in Diplomacy, line 18"
set Lb=Lb+1
if ll[NM]==0 then
if NM==0 then
call I1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call I1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call mew(NM,mM,MM,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set w3=uo[GetPlayerId(mM)]
set u3=bj_ALLIANCE_UNALLIED
set Xb[Lb]="when calling setAlliance in Diplomacy, line 19"
set Lb=Lb+1
if ll[w3]==0 then
if w3==0 then
call I1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call I1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call mew(w3,vM,u3,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set IM=0
set PM=23
loop
exitwhen IM>PM
set r3=ro[IM]
set s3=CreateForce()
call ForceAddPlayer(s3,r3)
if ro[IM]==mM then
set t3=ro[IM]
set Xb[Lb]="when calling warningToPlayer in Diplomacy, line 24"
set Lb=Lb+1
call DisplayTimedTextToPlayer(t3,0.,0.,10.0,N2(t3,"when calling getWarningStringForPlayer in Messages, line 79"))
call DisplayTimedTextToPlayer(t3,0.,0.,10.0,QM+" has declared war on you!")
set Lb=Lb-1
elseif s3==EM or s3==ZM then
set i3=ro[IM]
set Xb[Lb]="when calling attentionToPlayer in Diplomacy, line 26"
set Lb=Lb+1
call DisplayTimedTextToPlayer(i3,0.,0.,10.0,a5(i3,"when calling getAttentionStringForPlayer in Messages, line 88"))
call DisplayTimedTextToPlayer(i3,0.,0.,10.0,QM+" has declared war on your brother-in-arms, "+xM+"!")
set Lb=Lb-1
else
set S3=ro[IM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 28"
set Lb=Lb+1
call DisplayTimedTextToPlayer(S3,0.,0.,10.0,t5(S3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(S3,0.,0.,10.0,QM+" has declared war on "+xM)
set Lb=Lb-1
endif
set IM=IM+1
endloop
elseif UM==1093677397 then
set c3=uo[WM]
set Xb[Lb]="when calling getAllianceState in Diplomacy, line 31"
set Lb=Lb+1
if ll[c3]==0 then
if c3==0 then
call I1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call I1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Xb[Lb]="when calling getAllianceState in PlayerStats, line 66"
set Lb=Lb+1
set o3=pvw(c3,GetPlayerId(mM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Lb=Lb-1-1
if o3==bj_ALLIANCE_ALLIED_VISION then
set Lb=Lb-1
set vM=null
set mM=null
set EM=null
set ZM=null
set XM=null
set CM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
set x3=null
set v3=null
set m3=null
set Q3=null
set W3=null
return
endif
set O3=uo[WM]
set l3=bj_ALLIANCE_ALLIED_VISION
set Xb[Lb]="when calling setAlliance in Diplomacy, line 33"
set Lb=Lb+1
if ll[O3]==0 then
if O3==0 then
call I1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call I1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call mew(O3,mM,l3,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set AM=0
set DM=23
loop
exitwhen AM>DM
set b3=ro[AM]
set y3=CreateForce()
call ForceAddPlayer(y3,b3)
if ro[AM]==mM then
set p3=ro[AM]
set Xb[Lb]="when calling goodNewsToPlayer in Diplomacy, line 38"
set Lb=Lb+1
call DisplayTimedTextToPlayer(p3,0.,0.,10.0,l5(p3,"when calling getGoodNewsStringForPlayer in Messages, line 85"))
call DisplayTimedTextToPlayer(p3,0.,0.,10.0,QM+" seeks an alliance with you!")
set Lb=Lb-1
elseif y3==EM or y3==ZM then
set e3=ro[AM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 40"
set Lb=Lb+1
call DisplayTimedTextToPlayer(e3,0.,0.,10.0,t5(e3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(e3,0.,0.,10.0,QM+" has allied "+xM)
set Lb=Lb-1
else
set q3=ro[AM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 42"
set Lb=Lb+1
call DisplayTimedTextToPlayer(q3,0.,0.,10.0,t5(q3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(q3,0.,0.,10.0,QM+" has allied "+xM)
set Lb=Lb-1
endif
set AM=AM+1
endloop
elseif UM==1093677398 then
set a3=uo[WM]
set Xb[Lb]="when calling getAllianceState in Diplomacy, line 45"
set Lb=Lb+1
if ll[a3]==0 then
if a3==0 then
call I1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call I1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Xb[Lb]="when calling getAllianceState in PlayerStats, line 66"
set Lb=Lb+1
set n3=pvw(a3,GetPlayerId(mM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Lb=Lb-1-1
if n3==bj_ALLIANCE_NEUTRAL then
set Lb=Lb-1
set vM=null
set mM=null
set EM=null
set ZM=null
set XM=null
set CM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
set x3=null
set v3=null
set m3=null
set Q3=null
set W3=null
return
endif
set d3=uo[WM]
set f3=bj_ALLIANCE_NEUTRAL
set Xb[Lb]="when calling setAlliance in Diplomacy, line 47"
set Lb=Lb+1
if ll[d3]==0 then
if d3==0 then
call I1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call I1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call mew(d3,mM,f3,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set HM=0
set JM=23
loop
exitwhen HM>JM
set R3=ro[HM]
set T3=CreateForce()
call ForceAddPlayer(T3,R3)
if ro[HM]==mM then
set Y3=ro[HM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 52"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Y3,0.,0.,10.0,t5(Y3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(Y3,0.,0.,10.0,QM+" is now neutral towards you!")
set Lb=Lb-1
elseif T3==EM or T3==ZM then
set G3=ro[HM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 54"
set Lb=Lb+1
call DisplayTimedTextToPlayer(G3,0.,0.,10.0,t5(G3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(G3,0.,0.,10.0,QM+" shows neutrality towards "+xM)
set Lb=Lb-1
else
set g3=ro[HM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 56"
set Lb=Lb+1
call DisplayTimedTextToPlayer(g3,0.,0.,10.0,t5(g3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(g3,0.,0.,10.0,QM+" shows neutrality towards "+xM)
set Lb=Lb-1
endif
set HM=HM+1
endloop
elseif UM==1093677400 then
set h3=uo[WM]
set Xb[Lb]="when calling getAllianceState in Diplomacy, line 59"
set Lb=Lb+1
if ll[h3]==0 then
if h3==0 then
call I1("Nullpointer exception when calling PlayerStats.getAllianceState","when calling error in PlayerStats, line 66")
else
call I1("Called PlayerStats.getAllianceState on invalid object.","when calling error in PlayerStats, line 66")
endif
endif
set Xb[Lb]="when calling getAllianceState in PlayerStats, line 66"
set Lb=Lb+1
set F3=pvw(h3,GetPlayerId(mM),"when reading array PlayerStats_alliance_states in  in PlayerStats, line 67")
set Lb=Lb-1-1
if F3==bj_ALLIANCE_NEUTRAL then
set Lb=Lb-1
set vM=null
set mM=null
set EM=null
set ZM=null
set XM=null
set CM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
set x3=null
set v3=null
set m3=null
set Q3=null
set W3=null
return
endif
set k3=uo[WM]
set j3=bj_ALLIANCE_NEUTRAL
set Xb[Lb]="when calling setAlliance in Diplomacy, line 61"
set Lb=Lb+1
if ll[k3]==0 then
if k3==0 then
call I1("Nullpointer exception when calling PlayerStats.setAlliance","when calling error in PlayerStats, line 55")
else
call I1("Called PlayerStats.setAlliance on invalid object.","when calling error in PlayerStats, line 55")
endif
endif
call mew(k3,mM,j3,"when calling setAlliance in PlayerStats, line 55")
set Lb=Lb-1
set KM=0
set LM=23
loop
exitwhen KM>LM
set x3=ro[KM]
set v3=CreateForce()
call ForceAddPlayer(v3,x3)
if ro[KM]==mM then
set m3=ro[KM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 66"
set Lb=Lb+1
call DisplayTimedTextToPlayer(m3,0.,0.,10.0,t5(m3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(m3,0.,0.,10.0,QM+" unallies you!")
set Lb=Lb-1
elseif v3==EM or v3==ZM then
set Q3=ro[KM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 68"
set Lb=Lb+1
call DisplayTimedTextToPlayer(Q3,0.,0.,10.0,t5(Q3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(Q3,0.,0.,10.0,QM+" has unallied "+xM)
set Lb=Lb-1
else
set W3=ro[KM]
set Xb[Lb]="when calling noteToPlayer in Diplomacy, line 70"
set Lb=Lb+1
call DisplayTimedTextToPlayer(W3,0.,0.,10.0,t5(W3,"when calling getNoteStringForPlayer in Messages, line 82"))
call DisplayTimedTextToPlayer(W3,0.,0.,10.0,QM+" has unallied "+xM)
set Lb=Lb-1
endif
set KM=KM+1
endloop
endif
set Lb=Lb-1
set vM=null
set mM=null
set EM=null
set ZM=null
set XM=null
set CM=null
set r3=null
set s3=null
set t3=null
set i3=null
set S3=null
set b3=null
set y3=null
set p3=null
set e3=null
set q3=null
set R3=null
set T3=null
set Y3=null
set G3=null
set g3=null
set x3=null
set v3=null
set m3=null
set Q3=null
set W3=null
endfunction
function Jxw takes nothing returns nothing
set Lb=0
call E3("Diplomacy, line 119")
endfunction
function K2 takes nothing returns boolean
return true
endfunction
function K9 takes nothing returns boolean
local integer H9
local integer J9
set so=GetLocalPlayer()
set H9=0
set J9=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen H9>J9
set ro[H9]=Player(H9)
set H9=H9+1
endloop
return true
endfunction
function KF takes nothing returns nothing
local player QF=GetOwningPlayer(GetSpellTargetUnit())
local playerstate WF=PLAYER_STATE_RESOURCE_LUMBER
local playerstate EF
local playerstate ZF
local player UF
local force IF
local location PF
local real AF
local real DF
local player HF
local force JF
if WF==PLAYER_STATE_RESOURCE_GOLD then
set EF=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(QF,EF,GetPlayerState(QF,EF)+250)
elseif WF==PLAYER_STATE_RESOURCE_LUMBER then
set ZF=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(QF,ZF,GetPlayerState(QF,ZF)+250)
endif
call SetPlayerState(QF,WF,GetPlayerState(QF,WF)+250)
call RemoveUnit(GetSpellAbilityUnit())
set UF=GetOwningPlayer(GetSpellTargetUnit())
set IF=CreateForce()
call ForceAddPlayer(IF,UF)
if IsPlayerInForce(GetLocalPlayer(),IF) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1229")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set HF=GetOwningPlayer(GetSpellTargetUnit())
set JF=CreateForce()
call ForceAddPlayer(JF,HF)
set PF=y
set AF=GetLocationX(PF)
set DF=GetLocationY(PF)
if IsPlayerInForce(GetLocalPlayer(),JF) then
call PingMinimap(AF,DF,2.00)
endif
call RemoveLocation(y)
set QF=null
set WF=null
set EF=null
set ZF=null
set UF=null
set IF=null
set PF=null
set HF=null
set JF=null
endfunction
function KI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989830,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989829,0)
endfunction
function JP takes nothing returns boolean
if GetResearched()!=1378890051 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890051,true)!=1 then
return false
endif
return true
endfunction
function KP takes nothing returns boolean
if not JP() then
return false
endif
return true
endfunction
function KW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989057,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988558,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988551,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989066,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651824,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651826,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988818,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989080,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989072,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989082,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988559,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988812,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651828,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989065,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989067,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989301,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651843,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988561,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988788,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988565,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988566,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747988567,0)
endfunction
function JZ takes nothing returns boolean
if GetResearched()!=1378890035 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890035,true)!=1 then
return false
endif
return true
endfunction
function KZ takes nothing returns boolean
if not JZ() then
return false
endif
return true
endfunction
function Kjw takes nothing returns boolean
set Lb=0
set Xb[Lb]="RegisterEvents, line 1"
set Lb=Lb+1
set qo=plw("when calling new_HashMap in RegisterEvents, line 55")
call E0w(EVENT_PLAYER_UNIT_SPELL_EFFECT,null,SR,null)
set Lb=Lb-1
return true
endfunction
function Jv takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function Kv takes nothing returns boolean
if not Jv() then
return false
endif
return true
endfunction
function Kww takes nothing returns boolean
return true
endfunction
function y2 takes string X4 returns nothing
local fogmodifier array C4
local integer V4
local integer B4
local integer N4
local integer M4
local integer w2
local player u2
local fogstate r2
local location s2
local rect t2
local force i2
local integer S2
local integer c2
local integer o2
local integer O2
local string l2
local force b2
set Xb[Lb]=X4
set Lb=Lb+1
if Fc then
set Lb=Lb-1
set u2=null
set r2=null
set s2=null
set t2=null
set i2=null
set b2=null
return
endif
set V4=0
set B4=23
loop
exitwhen V4>B4
set u2=ro[V4]
set r2=FOG_OF_WAR_VISIBLE
set t2=bj_mapInitialPlayableArea
set s2=Location(GetRectCenterX(t2),GetRectCenterY(t2))
set bj_lastCreatedFogModifier=CreateFogModifierRadiusLoc(u2,r2,s2,999999.00,true,false)
call FogModifierStart(bj_lastCreatedFogModifier)
set C4[V4]=bj_lastCreatedFogModifier
call FogModifierStart(C4[V4])
set V4=V4+1
endloop
set i2=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),i2) then
call ShowInterface(false,0.50)
endif
set S2=Gc
set Xb[Lb]="when calling iterator in MainInit, line 89"
set Lb=Lb+1
set c2=dbw(S2,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set N4=c2
loop
exitwhen Tb[Gb[N4]]==Yb[N4]
set Gb[N4]=Tb[Gb[N4]]
set o2=fb[Gb[N4]]
set Xb[Lb]="when calling stringFromIndex in MainInit, line 89"
set Lb=Lb+1
set O2=Ao
set X4="when calling loadString in TypeCasting, line 35"
set Xb[Lb]="when calling loadString in TypeCasting, line 35"
set Lb=Lb+1
if HO[O2]==0 then
if O2==0 then
call I1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call I1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set l2=LoadStr(Zo,O2,o2)
set Lb=Lb-1-1
if not gc then
set b2=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),b2) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,10.0,l2)
endif
call TriggerSleepAction(12.5)
endif
endloop
set Xb[Lb]="when calling close in MainInit, line 89"
set Lb=Lb+1
if hb[N4]then
call edw(N4,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
call CinematicModeExBJ(false,bj_FORCE_ALL_PLAYERS,bj_CINEMODE_INTERFACEFADE)
set M4=0
set w2=23
loop
exitwhen M4>w2
call FogModifierStop(C4[M4])
set M4=M4+1
endloop
set gc=true
set Lb=Lb-1
set u2=null
set r2=null
set s2=null
set t2=null
set i2=null
set b2=null
endfunction
function Kxw takes nothing returns nothing
set Lb=0
call y2("MainInit, line 136")
endfunction
function L3 takes nothing returns boolean
return true
endfunction
function L9 takes nothing returns boolean
return true
endfunction
function LH takes nothing returns nothing
local integer IH=1
local integer PH=1751868773
local player AH=GetOwningPlayer(GetTriggerUnit())
local rect KH=bj_mapInitialPlayableArea
local location JH=Location(GetRectCenterX(KH),GetRectCenterY(KH))
local location DH=Location(GetLocationX(JH)+100000000.00,GetLocationY(JH)+100000000.00)
local real HH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set IH=IH-1
exitwhen IH<0
call CreateUnitAtLocSaveLast(AH,PH,DH,HH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set AH=null
set DH=null
set JH=null
set KH=null
endfunction
function KL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990328 then
return false
endif
return true
endfunction
function LL takes nothing returns boolean
if not KL() then
return false
endif
return true
endfunction
function LP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989825,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989817,0)
endfunction
function KT takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989043 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function LT takes nothing returns boolean
if not KT() then
return false
endif
return true
endfunction
function KU takes nothing returns boolean
if GetResearched()!=1378890033 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890033,true)!=1 then
return false
endif
return true
endfunction
function LU takes nothing returns boolean
if not KU() then
return false
endif
return true
endfunction
function LW takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,We)
endfunction
function LY takes nothing returns nothing
local unit JY=GetSpellTargetUnit()
local unitstate KY=UNIT_STATE_MANA
call SetUnitState(JY,UNIT_STATE_MANA,RMaxBJ(0.,GetUnitState(GetSpellTargetUnit(),KY)-600.00))
set JY=null
set KY=null
endfunction
function LZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989582,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989583,0)
endfunction
function Ljw takes nothing returns boolean
set Lb=0
set Xb[Lb]="TimerUtils, line 1"
set Lb=Lb+1
set Po=nqw("when calling new_Table in TimerUtils, line 12")
call CreateTimer()
call CreateTrigger()
set Lb=Lb-1
return true
endfunction
function Lv takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988788,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988535,0)
endfunction
function Lww takes nothing returns boolean
set Do=CreateTrigger()
set Ho=CreateTrigger()
call TriggerAddCondition(Bc,Filter(Xf))
call TriggerAddAction(Bc,Cf)
return true
endfunction
function Eww_2 takes integer jww_2,string xww returns trigger
local integer vww
local fogstate mww
local integer Qww
local trigger Www
set Xb[Lb]=xww
set Lb=Lb+1
set vww=Ao
set mww=ConvertFogState(jww_2)
set Xb[Lb]="when calling saveFogState in TypeCasting, line 94"
set Lb=Lb+1
if HO[vww]==0 then
if vww==0 then
call I1("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call I1("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call SaveFogStateHandle(Zo,vww,0,mww)
set Lb=Lb-1
set Qww=Ao
set Xb[Lb]="when calling loadTrigger in TypeCasting, line 95"
set Lb=Lb+1
if HO[Qww]==0 then
if Qww==0 then
call I1("Nullpointer exception when calling Table.loadTrigger","when calling error in Table, line 111")
else
call I1("Called Table.loadTrigger on invalid object.","when calling error in Table, line 111")
endif
endif
set Www=LoadTriggerHandle(Zo,Qww,0)
set Lb=Lb-1-1
set bR=Www
set mww=null
set Www=null
return bR
endfunction
function I0w takes string Z0w returns boolean
local boolean U0w
set Xb[Lb]=Z0w
set Lb=Lb+1
set U0w=TriggerEvaluate(Eww_2(tdw(qo,GetSpellAbilityId(),"when calling get in RegisterEvents, line 58"),"when calling triggerFromIndex in RegisterEvents, line 58"))
set Lb=Lb-1
return U0w
endfunction
function Lxw takes nothing returns boolean
set Lb=0
return I0w("RegisterEvents, line 58")
endfunction
function M1 takes nothing returns boolean
return true
endfunction
function BF takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function NF takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988801 then
return false
endif
if not BF() then
return false
endif
return true
endfunction
function MF takes nothing returns boolean
if not NF() then
return false
endif
return true
endfunction
function NH takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())==1747988531 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990328 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747989592 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990086 then
return true
endif
return false
endfunction
function MH takes nothing returns boolean
if not NH() then
return false
endif
return true
endfunction
function NP takes nothing returns boolean
if GetResearched()!=1378890051 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890051,true)!=2 then
return false
endif
return true
endfunction
function MP takes nothing returns boolean
if not NP() then
return false
endif
return true
endfunction
function MT takes nothing returns nothing
local player XT=GetOwningPlayer(GetAttacker())
local player CT=GetOwningPlayer(GetAttacker())
local player VT
local player BT
local unit NT
set r[GetPlayerId(XT)+1]=r[GetPlayerId(CT)+1]+1
set VT=GetOwningPlayer(GetTriggerUnit())
set BT=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(VT)+1]=r[GetPlayerId(BT)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set NT=GetTriggerUnit()
call SetUnitState(NT,UNIT_STATE_LIFE,GetUnitState(NT,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set XT=null
set CT=null
set VT=null
set BT=null
set NT=null
endfunction
function MY takes nothing returns nothing
set t=GetUnitLoc(GetSpellTargetUnit())
set bj_lastCreatedEffect=AddSpecialEffectLoc("Abilities\\Spells\\Orc\\Voodoo\\VoodooAuraTarget.mdl",t)
call DestroyEffect(bj_lastCreatedEffect)
set i=GetUnitLoc(GetSpellAbilityUnit())
set bj_lastCreatedEffect=AddSpecialEffectLoc("Abilities\\Spells\\Orc\\Voodoo\\VoodooAura.mdl",i)
call DestroyEffect(bj_lastCreatedEffect)
call RemoveLocation(t)
call RemoveLocation(i)
endfunction
function MZ takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,eq)
endfunction
function G9 takes string f9 returns boolean
local integer R9
local integer T9
local integer Y9
set Xb[Lb]=f9
set Lb=Lb+1
set Bc=CreateTrigger()
set Nc=CreateGroup()
set R9=0
set T9=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen R9>T9
call SetPlayerAbilityAvailable(ro[R9],1095577649,false)
set R9=R9+1
endloop
set Xb[Lb]="when calling alloc_OnUnitEnterLeave_CallbackSingle_line62 in OnUnitEnterLeave, line 62"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set Y9=YO
set GO[Y9]=651
else
call I1("Out of memory: Could not create OnUnitEnterLeave_CallbackSingle_line62.","when calling error in OnUnitEnterLeave, line 62")
set Y9=0
endif
else
set TO=TO-1
set Y9=RO[TO]
set GO[Y9]=651
endif
set Lb=Lb-1
set Xb[Lb]="when calling nullTimer in OnUnitEnterLeave, line 62"
set Lb=Lb+1
set Xb[Lb]="when calling doAfter in ClosureTimers, line 33"
set Lb=Lb+1
call jB(iww("when calling getTimer in ClosureTimers, line 27"),0.,Y9,"when calling doAfter in ClosureTimers, line 27")
set Lb=Lb-1-1-1
return true
endfunction
function Mjw takes nothing returns boolean
set Lb=0
return G9("OnUnitEnterLeave, line 1")
endfunction
function Nv takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function Mv takes nothing returns boolean
if not Nv() then
return false
endif
return true
endfunction
function Mxw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 293"
set Lb=Lb+1
call sB("when calling generalEventCallback in ClosureEvents, line 293")
set Lb=Lb-1
endfunction
function N1 takes nothing returns boolean
set Tc=InitHashtable()
return true
endfunction
function NA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990599,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990600,0)
endfunction
function BG takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function NG takes nothing returns nothing
if BG() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function NI takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,Lq)
endfunction
function NJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function NY takes nothing returns boolean
if GetSpellAbilityId()!=1093677620 then
return false
endif
return true
endfunction
function NZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989570,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989556,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989559,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989557,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989560,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989573,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989574,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651841,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651833,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651832,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989582,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990097,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747989812,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990098,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990099,0)
endfunction
function Bg takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function Ng takes nothing returns nothing
if Bg() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function Bh takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function Nh takes nothing returns nothing
if Bh() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function Nj takes nothing returns nothing
local player Pj=GetOwningPlayer(GetKillingUnit())
local playerstate Aj=PLAYER_STATE_RESOURCE_GOLD
local playerstate Dj
local playerstate Hj
local player Jj
local force Kj
local location Lj
local real Xj
local real Cj
local player Vj
local force Bj
if Aj==PLAYER_STATE_RESOURCE_GOLD then
set Dj=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Pj,Dj,GetPlayerState(Pj,Dj)+125)
elseif Aj==PLAYER_STATE_RESOURCE_LUMBER then
set Hj=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Pj,Hj,GetPlayerState(Pj,Hj)+125)
endif
call SetPlayerState(Pj,Aj,GetPlayerState(Pj,Aj)+125)
set Jj=GetOwningPlayer(GetKillingUnit())
set Kj=CreateForce()
call ForceAddPlayer(Kj,Jj)
if IsPlayerInForce(GetLocalPlayer(),Kj) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_091")
endif
set y=GetUnitLoc(GetDyingUnit())
set Vj=GetOwningPlayer(GetDyingUnit())
set Bj=CreateForce()
call ForceAddPlayer(Bj,Vj)
set Lj=y
set Xj=GetLocationX(Lj)
set Cj=GetLocationY(Lj)
if IsPlayerInForce(GetLocalPlayer(),Bj) then
call PingMinimap(Xj,Cj,2.00)
endif
call RemoveLocation(y)
set Pj=null
set Aj=null
set Dj=null
set Hj=null
set Jj=null
set Kj=null
set Lj=null
set Vj=null
set Bj=null
endfunction
function Njw takes nothing returns boolean
set Lb=0
set Xb[Lb]="ObjectIdGenerator, line 1"
set Lb=Lb+1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 7"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if il==0 then
if Sl<32768 then
set Sl=Sl+1
else
call I1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set il=il-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 8"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if il==0 then
if Sl<32768 then
set Sl=Sl+1
else
call I1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set il=il-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if il==0 then
if Sl<32768 then
set Sl=Sl+1
else
call I1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set il=il-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 10"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if il==0 then
if Sl<32768 then
set Sl=Sl+1
else
call I1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set il=il-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 11"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if il==0 then
if Sl<32768 then
set Sl=Sl+1
else
call I1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set il=il-1
endif
set Lb=Lb-1-1
set Xb[Lb]="when calling new_IdGenerator in ObjectIdGenerator, line 12"
set Lb=Lb+1
set Xb[Lb]="when calling alloc_IdGenerator in ObjectIdGenerator, line 20"
set Lb=Lb+1
if il==0 then
if Sl<32768 then
set Sl=Sl+1
else
call I1("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
endif
else
set il=il-1
endif
set Lb=Lb-1-1-1
return true
endfunction
function Nk takes nothing returns nothing
local player Pk=GetOwningPlayer(GetSpellTargetUnit())
local playerstate Ak=PLAYER_STATE_RESOURCE_GOLD
local playerstate Dk
local playerstate Hk
local player Jk
local force Kk
local location Lk
local real Xk
local real Ck
local player Vk
local force Bk
if Ak==PLAYER_STATE_RESOURCE_GOLD then
set Dk=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Pk,Dk,GetPlayerState(Pk,Dk)+500)
elseif Ak==PLAYER_STATE_RESOURCE_LUMBER then
set Hk=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Pk,Hk,GetPlayerState(Pk,Hk)+500)
endif
call SetPlayerState(Pk,Ak,GetPlayerState(Pk,Ak)+500)
call RemoveUnit(GetSpellAbilityUnit())
set Jk=GetOwningPlayer(GetSpellTargetUnit())
set Kk=CreateForce()
call ForceAddPlayer(Kk,Jk)
if IsPlayerInForce(GetLocalPlayer(),Kk) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1231")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set Vk=GetOwningPlayer(GetSpellTargetUnit())
set Bk=CreateForce()
call ForceAddPlayer(Bk,Vk)
set Lk=y
set Xk=GetLocationX(Lk)
set Ck=GetLocationY(Lk)
if IsPlayerInForce(GetLocalPlayer(),Bk) then
call PingMinimap(Xk,Ck,2.00)
endif
call RemoveLocation(y)
set Pk=null
set Ak=null
set Dk=null
set Hk=null
set Jk=null
set Kk=null
set Lk=null
set Vk=null
set Bk=null
endfunction
function Nm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989066,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988551,0)
endfunction
function Nxw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 292"
set Lb=Lb+1
call sB("when calling generalEventCallback in ClosureEvents, line 292")
set Lb=Lb-1
endfunction
function oH takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())==1747988545 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747989577 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747990320 then
return true
endif
if GetUnitTypeId(GetConstructedStructure())==1747989845 then
return true
endif
return false
endfunction
function OH takes nothing returns boolean
if p[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]!=false then
return false
endif
if not oH() then
return false
endif
return true
endfunction
function oL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989591 then
return false
endif
return true
endfunction
function OL takes nothing returns boolean
if not oL() then
return false
endif
return true
endfunction
function OP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990321,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990104,0)
endfunction
function oU takes nothing returns boolean
if GetResearched()!=1378889818 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889818,true)!=2 then
return false
endif
return true
endfunction
function OU takes nothing returns boolean
if not oU() then
return false
endif
return true
endfunction
function oW takes nothing returns boolean
if GetResearched()!=1378889800 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889800,true)!=1 then
return false
endif
return true
endfunction
function OW takes nothing returns boolean
if not oW() then
return false
endif
return true
endfunction
function OZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651833,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651841,0)
endfunction
function efw takes integer Adw,integer Ddw,integer Hdw,integer Jdw,integer Kdw,integer Ldw,integer Xdw,integer Cdw,integer Vdw,integer Bdw,integer Ndw,integer Mdw,integer wfw,integer ufw,integer rfw,integer sfw,integer tfw,integer ifw,integer Sfw,integer cfw,integer ofw,integer Ofw,integer lfw,integer bfw,string yfw returns integer
local integer pfw
set Xb[Lb]=yfw
set Lb=Lb+1
set pfw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(pfw,Adw,"when calling add in LinkedList, line 393")
call ffw(pfw,Ddw,"when calling add in LinkedList, line 393")
call ffw(pfw,Hdw,"when calling add in LinkedList, line 393")
call ffw(pfw,Jdw,"when calling add in LinkedList, line 393")
call ffw(pfw,Kdw,"when calling add in LinkedList, line 393")
call ffw(pfw,Ldw,"when calling add in LinkedList, line 393")
call ffw(pfw,Xdw,"when calling add in LinkedList, line 393")
call ffw(pfw,Cdw,"when calling add in LinkedList, line 393")
call ffw(pfw,Vdw,"when calling add in LinkedList, line 393")
call ffw(pfw,Bdw,"when calling add in LinkedList, line 393")
call ffw(pfw,Ndw,"when calling add in LinkedList, line 393")
call ffw(pfw,Mdw,"when calling add in LinkedList, line 393")
call ffw(pfw,wfw,"when calling add in LinkedList, line 393")
call ffw(pfw,ufw,"when calling add in LinkedList, line 393")
call ffw(pfw,rfw,"when calling add in LinkedList, line 393")
call ffw(pfw,sfw,"when calling add in LinkedList, line 393")
call ffw(pfw,tfw,"when calling add in LinkedList, line 393")
call ffw(pfw,ifw,"when calling add in LinkedList, line 393")
call ffw(pfw,Sfw,"when calling add in LinkedList, line 393")
call ffw(pfw,cfw,"when calling add in LinkedList, line 393")
call ffw(pfw,ofw,"when calling add in LinkedList, line 393")
call ffw(pfw,Ofw,"when calling add in LinkedList, line 393")
call ffw(pfw,lfw,"when calling add in LinkedList, line 393")
call ffw(pfw,bfw,"when calling add in LinkedList, line 393")
set Lb=Lb-1
return pfw
endfunction
function iN takes string tN returns boolean
set Xb[Lb]=tN
set Lb=Lb+1
set wc=efw(Rww("red","when calling stringToIndex in CommandTools, line 5"),Rww("blue","when calling stringToIndex in CommandTools, line 6"),Rww("teal","when calling stringToIndex in CommandTools, line 7"),Rww("purple","when calling stringToIndex in CommandTools, line 8"),Rww("yellow","when calling stringToIndex in CommandTools, line 9"),Rww("orange","when calling stringToIndex in CommandTools, line 10"),Rww("green","when calling stringToIndex in CommandTools, line 11"),Rww("pink","when calling stringToIndex in CommandTools, line 12"),Rww("grey","when calling stringToIndex in CommandTools, line 13"),Rww("light blue","when calling stringToIndex in CommandTools, line 14"),Rww("dark green","when calling stringToIndex in CommandTools, line 15"),Rww("brown","when calling stringToIndex in CommandTools, line 16"),Rww("maroon","when calling stringToIndex in CommandTools, line 17"),Rww("navy","when calling stringToIndex in CommandTools, line 18"),Rww("turquoise","when calling stringToIndex in CommandTools, line 19"),Rww("violet","when calling stringToIndex in CommandTools, line 20"),Rww("wheat","when calling stringToIndex in CommandTools, line 21"),Rww("peach","when calling stringToIndex in CommandTools, line 22"),Rww("mint","when calling stringToIndex in CommandTools, line 23"),Rww("lavender","when calling stringToIndex in CommandTools, line 24"),Rww("coal","when calling stringToIndex in CommandTools, line 25"),Rww("snow","when calling stringToIndex in CommandTools, line 26"),Rww("emerald","when calling stringToIndex in CommandTools, line 27"),Rww("peanut","when calling stringToIndex in CommandTools, line 28"),"when calling asList in CommandTools, line 4")
set Lb=Lb-1
return true
endfunction
function Oxw takes nothing returns boolean
set Lb=0
return iN("CommandTools, line 1")
endfunction
function P0w takes nothing returns boolean
return true
endfunction
function P1 takes nothing returns boolean
set oc=CreateForce()
set Oc=CreateForce()
set lc=CreateForce()
set bc=CreateForce()
set yc[0]=oc
set yc[1]=Oc
set yc[2]=lc
set yc[3]=bc
set pc[0]=62
set ec[0]=194
set qc[0]=255
set pc[1]=255
set ec[1]=238
set qc[1]=0
set pc[2]=0
set ec[2]=201
set qc[2]=10
set pc[3]=219
set ec[3]=0
set qc[3]=201
return true
endfunction
function IE takes nothing returns boolean
if GetResearched()!=1378889806 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889806,true)!=1 then
return false
endif
return true
endfunction
function PE takes nothing returns boolean
if not IE() then
return false
endif
return true
endfunction
function PL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function PT takes nothing returns nothing
local group ZT=GetUnitsOfTypeIdAll(1747988554)
local code UT=Yy
local boolean IT=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(ZT,UT)
if IT then
call DestroyGroup(ZT)
endif
set ZT=null
endfunction
function PU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989816,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989815,0)
endfunction
function PW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989301,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988790,0)
endfunction
function bww takes string Oww returns boolean
local integer lww
set Xb[Lb]=Oww
set Lb=Lb+1
set Ao=nqw("when calling new_Table in TypeCasting, line 6")
set Xb[Lb]="when calling initTypecastData in TypeCasting, line 14"
set Lb=Lb+1
set lww=Ao
set Xb[Lb]="when calling saveString in TypeCasting, line 11"
set Lb=Lb+1
if HO[lww]==0 then
if lww==0 then
call I1("Nullpointer exception when calling Table.saveString","when calling error in Table, line 60")
else
call I1("Called Table.saveString on invalid object.","when calling error in Table, line 60")
endif
endif
call SaveStr(Zo,lww,0,"")
set Lb=Lb-1-1-1
return true
endfunction
function Pjw takes nothing returns boolean
set Lb=0
return bww("TypeCasting, line 1")
endfunction
function QE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989556,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989570,0)
endfunction
function mG takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function QG takes nothing returns nothing
if mG() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function mK takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747989059 then
return false
endif
return true
endfunction
function QK takes nothing returns boolean
if not mK() then
return false
endif
return true
endfunction
function mQ takes nothing returns boolean
if GetResearched()!=1378889799 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889799,true)!=1 then
return false
endif
return true
endfunction
function QQ takes nothing returns boolean
if not mQ() then
return false
endif
return true
endfunction
function QX takes nothing returns boolean
return true
endfunction
function mg takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function Qg takes nothing returns nothing
if mg() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function mh takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function Qh takes nothing returns nothing
if mh() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function Qj takes nothing returns nothing
local player Tj=GetOwningPlayer(GetKillingUnit())
local playerstate Yj=PLAYER_STATE_RESOURCE_LUMBER
local playerstate Gj
local playerstate gj
local player hj
local force Fj
local location kj
local real jj
local real xj
local player vj
local force mj
if Yj==PLAYER_STATE_RESOURCE_GOLD then
set Gj=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Tj,Gj,GetPlayerState(Tj,Gj)+250)
elseif Yj==PLAYER_STATE_RESOURCE_LUMBER then
set gj=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Tj,gj,GetPlayerState(Tj,gj)+250)
endif
call SetPlayerState(Tj,Yj,GetPlayerState(Tj,Yj)+250)
set hj=GetOwningPlayer(GetKillingUnit())
set Fj=CreateForce()
call ForceAddPlayer(Fj,hj)
if IsPlayerInForce(GetLocalPlayer(),Fj) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_090")
endif
set y=GetUnitLoc(GetDyingUnit())
set vj=GetOwningPlayer(GetDyingUnit())
set mj=CreateForce()
call ForceAddPlayer(mj,vj)
set kj=y
set jj=GetLocationX(kj)
set xj=GetLocationY(kj)
if IsPlayerInForce(GetLocalPlayer(),mj) then
call PingMinimap(jj,xj,2.00)
endif
call RemoveLocation(y)
set Tj=null
set Yj=null
set Gj=null
set gj=null
set hj=null
set Fj=null
set kj=null
set vj=null
set mj=null
endfunction
function eqw takes string oqw,string Oqw,integer lqw,integer bqw,integer yqw,string pqw returns integer
set Xb[Lb]=pqw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_ReligionClass in Religion, line 15"
set Lb=Lb+1
if yl==0 then
if pl<32768 then
set pl=pl+1
set lqw=pl
else
call I1("Out of memory: Could not create ReligionClass.","when calling error in Religion, line 10")
set lqw=0
endif
else
set yl=yl-1
set lqw=bl[yl]
endif
set Lb=Lb-1-1
return lqw
endfunction
function Qxw takes nothing returns boolean
set Lb=0
set Xb[Lb]="Religion, line 1"
set Lb=Lb+1
call eqw("Catholicism","Catholic",244,255,96,"when calling new_ReligionClass in Religion, line 29")
call eqw("Orthodoxy","Orthodox",234,0,255,"when calling new_ReligionClass in Religion, line 35")
call eqw("Islam","Muslim",0,151,0,"when calling new_ReligionClass in Religion, line 41")
call eqw("Orthodoxy","Orthodox",234,0,255,"when calling new_ReligionClass in Religion, line 47")
set Lb=Lb-1
return true
endfunction
function fA takes nothing returns boolean
if GetResearched()!=1378890040 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890040,true)!=1 then
return false
endif
return true
endfunction
function RA takes nothing returns boolean
if not fA() then
return false
endif
return true
endfunction
function fJ takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747990353 then
return false
endif
return true
endfunction
function RJ takes nothing returns boolean
if not fJ() then
return false
endif
return true
endfunction
function Rj takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988801 then
return false
endif
return true
endfunction
function fm takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function Rm takes nothing returns boolean
if not fm() then
return false
endif
return true
endfunction
function Rv takes nothing returns nothing
local player Ov=GetOwningPlayer(GetKillingUnit())
local playerstate lv=PLAYER_STATE_RESOURCE_GOLD
local playerstate bv
local playerstate yv
local player pv
local force ev
local location qv
local real av
local real nv
local player dv
local force fv
if lv==PLAYER_STATE_RESOURCE_GOLD then
set bv=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Ov,bv,GetPlayerState(Ov,bv)+500)
elseif lv==PLAYER_STATE_RESOURCE_LUMBER then
set yv=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Ov,yv,GetPlayerState(Ov,yv)+500)
endif
call SetPlayerState(Ov,lv,GetPlayerState(Ov,lv)+500)
set pv=GetOwningPlayer(GetKillingUnit())
set ev=CreateForce()
call ForceAddPlayer(ev,pv)
if IsPlayerInForce(GetLocalPlayer(),ev) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_083")
endif
set y=GetUnitLoc(GetDyingUnit())
set dv=GetOwningPlayer(GetDyingUnit())
set fv=CreateForce()
call ForceAddPlayer(fv,dv)
set qv=y
set av=GetLocationX(qv)
set nv=GetLocationY(qv)
if IsPlayerInForce(GetLocalPlayer(),fv) then
call PingMinimap(av,nv,2.00)
endif
call RemoveLocation(y)
set Ov=null
set lv=null
set bv=null
set yv=null
set pv=null
set ev=null
set qv=null
set dv=null
set fv=null
endfunction
function dM takes string qM returns boolean
local integer aM
local timer nM
set Xb[Lb]=qM
set Lb=Lb+1
set Xb[Lb]="when calling alloc_DateTime_CallbackPeriodic_line31 in DateTime, line 31"
set Lb=Lb+1
if hO==0 then
if FO<32768 then
set FO=FO+1
set aM=FO
set kO[aM]=634
else
call I1("Out of memory: Could not create DateTime_CallbackPeriodic_line31.","when calling error in DateTime, line 31")
set aM=0
endif
else
set hO=hO-1
set aM=gO[hO]
set kO[aM]=634
endif
set Lb=Lb-1
set cb[aM]=120.0
set Xb[Lb]="when calling doPeriodically in DateTime, line 31"
set Lb=Lb+1
set nM=iww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call onw(aM,nM,1.0,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set nM=null
return true
endfunction
function Rxw takes nothing returns boolean
set Lb=0
return dM("DateTime, line 1")
endfunction
function iA takes nothing returns boolean
if GetResearched()!=1378890053 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890053,true)!=1 then
return false
endif
return true
endfunction
function SA takes nothing returns boolean
if not iA() then
return false
endif
return true
endfunction
function im takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function Sm takes nothing returns boolean
if not im() then
return false
endif
return true
endfunction
function TA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990595,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990608,0)
endfunction
function RI takes nothing returns boolean
if GetResearched()!=1378890036 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890036,true)!=1 then
return false
endif
return true
endfunction
function TI takes nothing returns boolean
if not RI() then
return false
endif
return true
endfunction
function TJ takes nothing returns nothing
call UnitAddAbility(GetConstructedStructure(),1093677896)
endfunction
function Tm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988567,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988564,0)
endfunction
function GM takes string fM returns boolean
local playerunitevent RM
local integer TM
local integer YM
set Xb[Lb]=fM
set Lb=Lb+1
set RM=EVENT_PLAYER_UNIT_ISSUED_ORDER
set Xb[Lb]="when calling alloc_Debug_EventListener_line5 in Debug, line 5"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set TM=cO
set oO[TM]=669
else
call I1("Out of memory: Could not create Debug_EventListener_line5.","when calling error in Debug, line 5")
set TM=0
endif
else
set SO=SO-1
set TM=iO[SO]
set oO[TM]=669
endif
set Lb=Lb-1
set Ml[TM]=0
set wb[TM]=0
set ub[TM]=0
set Xb[Lb]="when calling add in Debug, line 5"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set YM=QS[GetHandleId(RM)]
if YM==0 then
set YM=QV(RM,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[TM]=YM
if US[Ml[TM]]!=0 then
set ub[US[Ml[TM]]]=TM
set wb[TM]=US[Ml[TM]]
endif
set US[Ml[TM]]=TM
set Lb=Lb-1-1
set RM=null
return true
endfunction
function Txw takes nothing returns boolean
set Lb=0
return GM("Debug, line 1")
endfunction
function ZH takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())==1747988530 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990327 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747989591 then
return true
endif
if GetUnitTypeId(GetTriggerUnit())==1747990085 then
return true
endif
return false
endfunction
function UH takes nothing returns boolean
if not ZH() then
return false
endif
return true
endfunction
function UI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651844,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651845,0)
endfunction
function ZP takes nothing returns boolean
if GetResearched()!=1378890049 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890049,true)!=2 then
return false
endif
return true
endfunction
function UP takes nothing returns boolean
if not ZP() then
return false
endif
return true
endfunction
function ZZ takes nothing returns boolean
if GetResearched()!=1378889808 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889808,true)!=1 then
return false
endif
return true
endfunction
function UZ takes nothing returns boolean
if not ZZ() then
return false
endif
return true
endfunction
function Jcw takes integer Acw,string Dcw returns nothing
local integer Hcw
set Xb[Lb]=Dcw
set Lb=Lb+1
set Hcw=US[Ml[Acw]]
if Hcw==Acw then
set US[Ml[Acw]]=wb[Acw]
elseif ub[Acw]!=0 then
set wb[ub[Acw]]=wb[Acw]
endif
set ub[wb[Acw]]=ub[Acw]
set Hcw=IS[Ml[Acw]]
if Hcw==Acw then
set IS[Ml[Acw]]=wb[Acw]
elseif ub[Acw]!=0 then
set wb[ub[Acw]]=wb[Acw]
endif
set ub[wb[Acw]]=ub[Acw]
set wb[Acw]=0
set ub[Acw]=0
set Xb[Lb]="when calling dealloc_EventListener in ClosureEvents, line 202"
set Lb=Lb+1
if oO[Acw]==0 then
call I1("Double free: object of type EventListener","when calling error in ClosureEvents, line 98")
else
set iO[SO]=Acw
set SO=SO+1
set oO[Acw]=0
endif
set Lb=Lb-1-1
endfunction
function LV takes integer DV,string HV returns nothing
local integer JV
local integer KV
set Xb[Lb]=HV
set Lb=Lb+1
if DV>0 then
if IS[DV]!=0 then
set JV=IS[DV]
set IS[DV]=0
loop
exitwhen JV==0
set KV=JV
set JV=wb[JV]
set Xb[Lb]="when calling dispatch_EventListener_destroyEventListener in ClosureEvents, line 282"
set Lb=Lb+1
if oO[KV]==0 then
if KV==0 then
call I1("Nullpointer exception when calling EventListener.EventListener","when calling error in ClosureEvents, line 98")
else
call I1("Called EventListener.EventListener on invalid object.","when calling error in ClosureEvents, line 98")
endif
endif
call Jcw(KV,"when calling destroyEventListener in ClosureEvents, line 98")
set Lb=Lb-1
endloop
endif
endif
set Lb=Lb-1
endfunction
function Xcw takes integer Kcw,string Lcw returns nothing
set Xb[Lb]=Lcw
set Lb=Lb+1
if ib[Kcw]!=null then
if tdw(ZS,GetHandleId(ib[Kcw]),"when calling get in ClosureEvents, line 60")==Kcw then
call Mnw(ZS,GetHandleId(ib[Kcw]),rb[Kcw],"when calling put in ClosureEvents, line 62")
elseif sb[Kcw]!=0 then
set rb[sb[Kcw]]=rb[Kcw]
endif
elseif tdw(ES,tb[Kcw],"when calling get in ClosureEvents, line 66")==Kcw then
call Mnw(ES,tb[Kcw],rb[Kcw],"when calling put in ClosureEvents, line 68")
elseif sb[Kcw]!=0 then
set rb[sb[Kcw]]=rb[Kcw]
endif
set sb[rb[Kcw]]=sb[Kcw]
set rb[Kcw]=0
set sb[Kcw]=0
set Lb=Lb-1
endfunction
function Paw takes integer Uaw,string Iaw returns nothing
set Xb[Lb]=Iaw
set Lb=Lb+1
if xO[Uaw]==0 then
if Uaw==0 then
call I1("Nullpointer exception when calling OnCastListener.OnCastListener","when calling error in ClosureEvents, line 50")
else
call I1("Called OnCastListener.OnCastListener on invalid object.","when calling error in ClosureEvents, line 50")
endif
endif
set Xb[Lb]="when calling destroyOnCastListener in ClosureEvents, line 50"
set Lb=Lb+1
call Xcw(Uaw,"when calling OnCastListener_onDestroy in ClosureEvents, line 58")
set Xb[Lb]="when calling dealloc_OnCastListener in ClosureEvents, line 58"
set Lb=Lb+1
if xO[Uaw]==0 then
call I1("Double free: object of type OnCastListener","when calling error in ClosureEvents, line 50")
else
set jO=jO+1
set xO[Uaw]=0
endif
set Lb=Lb-1-1-1
endfunction
function AV takes unit WV,string EV returns nothing
local integer ZV
local integer UV
local integer IV
local integer PV
set Xb[Lb]=EV
set Lb=Lb+1
call LV(GetUnitUserData(WV),"when calling unregisterEvents in ClosureEvents, line 258")
if Xnw(ZS,GetHandleId(WV),"when calling has in ClosureEvents, line 259") then
set ZV=tdw(ZS,GetHandleId(WV),"when calling get in ClosureEvents, line 260")
call odw(ZS,GetHandleId(WV),"when calling remove in ClosureEvents, line 261")
loop
exitwhen ZV==0
set UV=ZV
set ZV=rb[ZV]
call Paw(UV,"when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 265")
endloop
endif
if Xnw(ZS,GetHandleId(WV),"when calling has in ClosureEvents, line 266") then
set IV=tdw(ZS,GetHandleId(WV),"when calling get in ClosureEvents, line 267")
loop
exitwhen IV==0
set PV=IV
set IV=rb[IV]
call Paw(PV,"when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 271")
endloop
endif
set Lb=Lb-1
endfunction
function Uxw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 288"
set Lb=Lb+1
call AV(Jo[Ko-1],"when calling unregisterEventsForUnit in ClosureEvents, line 288")
set Lb=Lb-1
endfunction
function V1 takes nothing returns nothing
call GroupAddUnit(dc,GetEnumUnit())
endfunction
function VG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990091 then
return false
endif
return true
endfunction
function VK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function VQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989072,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989073,0)
endfunction
function CW takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function VW takes nothing returns boolean
if not CW() then
return false
endif
return true
endfunction
function Vg takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989077 then
return false
endif
return true
endfunction
function Vh takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990071 then
return false
endif
return true
endfunction
function initialize takes nothing returns nothing
local integer i_2=0
local integer temp=no
loop
exitwhen i_2>temp
set i_2=i_2+1
endloop
endfunction
function Vjw takes nothing returns boolean
set Lb=0
set Xb[Lb]="StringUtils, line 1"
set Lb=Lb+1
set no=127
call initialize()
call Rww("","when calling stringToIndex in StringUtils, line 167")
set Lb=Lb-1
return true
endfunction
function arw takes string trw returns nothing
local unit irw
local integer Srw
local integer crw
local player orw
local integer Orw
local boolean lrw
local integer brw
local integer yrw
local integer prw
local integer erw
local boolean qrw
set Xb[Lb]=trw
set Lb=Lb+1
set irw=GetEnteringUnit()
set Srw=GetPlayerId(GetOwningPlayer(irw))
set orw=ro[Srw]
if GetPlayerSlotState(orw)==PLAYER_SLOT_STATE_PLAYING then
set qrw=GetPlayerController(orw)==MAP_CONTROL_USER
else
set qrw=false
endif
if qrw and(not IsUnitType(irw,UNIT_TYPE_STRUCTURE)) then
set crw=GetUnitTypeId(irw)
set Orw=Lo
set Xb[Lb]="when calling has in Upkeep, line 28"
set Lb=Lb+1
if tl[Orw]==0 then
if Orw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set lrw=kbw(Orw,crw)
set Lb=Lb-1
if lrw then
set brw=uo[Srw]
set yrw=-10
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 29"
set Lb=Lb+1
if ll[brw]==0 then
if brw==0 then
call I1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call I1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[brw]=Db[brw]+yrw
set Lb=Lb-1
else
set prw=uo[Srw]
set erw=-GetUnitLevel(irw)
set Xb[Lb]="when calling changeUpkeep in Upkeep, line 31"
set Lb=Lb+1
if ll[prw]==0 then
if prw==0 then
call I1("Nullpointer exception when calling PlayerStats.changeUpkeep","when calling error in PlayerStats, line 51")
else
call I1("Called PlayerStats.changeUpkeep on invalid object.","when calling error in PlayerStats, line 51")
endif
endif
set Db[prw]=Db[prw]+erw
set Lb=Lb-1
endif
endif
set Lb=Lb-1
set irw=null
set orw=null
endfunction
function Vxw takes nothing returns nothing
set Lb=0
call arw("Upkeep, line 23")
endfunction
function W2 takes nothing returns boolean
return true
endfunction
function WK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function WQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988559,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989064,0)
endfunction
function Www takes nothing returns boolean
set do[0]="Terrible! Terrible news, my lord!"
set do[1]="The messenger came to us with horrific news! May we execute him?"
set do[2]="A mere nightmare, Your Mightiness!"
set fo[0]="Holy Mother of God, we have horrific news!"
set fo[1]="Lord Preserve us, Great Prince!"
set fo[2]="Great Prince, we have horrific news!"
set Ro[0]="Allah be merciful! I bring terrible news"
set Ro[1]="Oh, Great Sultan! We have terrible news"
set Ro[2]="Oh, Great one! I bring ill news"
set To[0]="Saints save us, we have some most horrific news!"
set To[1]="My Basileus! We have horrific news!"
set To[2]="My Basileus, by the grace of our lord. We have horrific news!"
set Yo[0]="My King, we have received news concerning our realm"
set Yo[1]="The messenger arrived with news. No matter, could I execute him?"
set Yo[2]="My liege I bring news about the realm"
set Go[0]="Great Prince, a messenger came with news"
set Go[1]="May the God bless you, Great Prince, we have some news"
set Go[2]="There is something you should know, Great Prince"
set go[0]="My Sultan! We have news"
set go[1]="Praise be to Allah, Sultan! We bring news"
set go[2]="Great Sultan! We have some news"
set ho[0]="My Basileus, we have some news"
set ho[1]="My Basileus, we have some news"
set ho[2]="My Basileus, we have some news"
set Fo[0]="Milord! Good news!"
set Fo[1]="Praise the Holy Lord! We have good news"
set Fo[2]="My King, we bring great news for you!"
set ko[0]="By the grace of our Lord, we bring good news!"
set ko[1]="We received great news my Lord! Still the Messenger deserves to be pusnished"
set ko[2]="My Lord, we have received delightful news!"
set jo[0]="Praise be to Allah, Sultan! We have great news"
set jo[1]="Good tidings Sultan! I bring good news"
set jo[2]="Allah is glorious, Sultan! We have great news"
set xo[0]="Good news, my Basileus!"
set xo[1]="Praise the Holy Lord, we bring great news, my Basileus!"
set xo[2]="We received good news my Basileus! We shouldnt blind this messenger"
set vo[0]="Your Majesty, important news!"
set vo[1]="May the God bless you, my lord. There is something you must know!"
set vo[2]="There is something that needs your attention, my lord!"
set mo[0]="By the Saints! Great Prince, you must hear to this"
set mo[1]="You should hear this, Great Prince!"
set mo[2]="You need to see this, Great Prince!"
set Qo[0]="Great one, urgent news must be brought to your attention!"
set Qo[1]="My Sultan, there is something you need to know!"
set Qo[2]="My Great Sultan, there is something you must know!"
set Wo[0]="My Basileus, there is something you need to know!"
set Wo[1]="My Basileus, we can not delay this news!"
set Wo[2]="My Basileus, you should be aware of this!"
set Eo[0]="|cffffd900Med."
set Eo[1]="|cff00ff00Low"
set Eo[2]="|cffff0000High"
set Eo[3]="|cff940000Harsh"
return true
endfunction
function Dww takes string Uww returns boolean
local playerunitevent Iww
local integer Pww
local integer Aww
set Xb[Lb]=Uww
set Lb=Lb+1
set Iww=EVENT_PLAYER_UNIT_SPELL_CAST
set Xb[Lb]="when calling alloc_Taxation_EventListener_line6 in Taxation, line 6"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set Pww=cO
set oO[Pww]=682
else
call I1("Out of memory: Could not create Taxation_EventListener_line6.","when calling error in Taxation, line 6")
set Pww=0
endif
else
set SO=SO-1
set Pww=iO[SO]
set oO[Pww]=682
endif
set Lb=Lb-1
set Ml[Pww]=0
set wb[Pww]=0
set ub[Pww]=0
set Xb[Lb]="when calling add in Taxation, line 6"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set Aww=QS[GetHandleId(Iww)]
if Aww==0 then
set Aww=QV(Iww,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[Pww]=Aww
if US[Ml[Pww]]!=0 then
set ub[US[Ml[Pww]]]=Pww
set wb[Pww]=US[Ml[Pww]]
endif
set US[Ml[Pww]]=Pww
set Lb=Lb-1-1
set Iww=null
return true
endfunction
function Wxw takes nothing returns boolean
set Lb=0
return Dww("Taxation, line 1")
endfunction
function X9 takes nothing returns boolean
set io=ConvertPlayerColor(24)
set So=ConvertPlayerColor(25)
set co=ConvertPlayerColor(26)
set oo=ConvertPlayerColor(27)
set Oo[0]=PLAYER_COLOR_RED
set Oo[1]=PLAYER_COLOR_BLUE
set Oo[2]=PLAYER_COLOR_CYAN
set Oo[3]=PLAYER_COLOR_PURPLE
set Oo[4]=PLAYER_COLOR_YELLOW
set Oo[5]=PLAYER_COLOR_ORANGE
set Oo[6]=PLAYER_COLOR_GREEN
set Oo[7]=PLAYER_COLOR_PINK
set Oo[8]=PLAYER_COLOR_LIGHT_GRAY
set Oo[9]=PLAYER_COLOR_LIGHT_BLUE
set Oo[10]=PLAYER_COLOR_AQUA
set Oo[11]=PLAYER_COLOR_BROWN
set Oo[12]=PLAYER_COLOR_MAROON
set Oo[13]=PLAYER_COLOR_NAVY
set Oo[14]=PLAYER_COLOR_TURQUOISE
set Oo[15]=PLAYER_COLOR_VIOLET
set Oo[16]=PLAYER_COLOR_WHEAT
set Oo[17]=PLAYER_COLOR_PEACH
set Oo[18]=PLAYER_COLOR_MINT
set Oo[19]=PLAYER_COLOR_LAVENDER
set Oo[20]=PLAYER_COLOR_COAL
set Oo[21]=PLAYER_COLOR_SNOW
set Oo[22]=PLAYER_COLOR_EMERALD
set Oo[23]=PLAYER_COLOR_PEANUT
set Oo[24]=io
set Oo[25]=So
set Oo[26]=co
set Oo[27]=oo
return true
endfunction
function LE takes nothing returns boolean
if GetResearched()!=1378889806 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889806,true)!=2 then
return false
endif
return true
endfunction
function XE takes nothing returns boolean
if not LE() then
return false
endif
return true
endfunction
function XL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function XU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989828,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989827,0)
endfunction
function XV takes nothing returns nothing
call TriggerRegisterUnitEvent(xS,Jo[Ko-1],EVENT_UNIT_DAMAGED)
endfunction
function aFw takes integer Mhw,integer wFw,integer uFw,integer rFw,integer sFw,integer tFw,integer iFw,integer SFw,integer cFw,integer oFw,integer OFw,integer lFw,integer bFw,integer yFw,integer pFw,integer eFw,string qFw returns nothing
set Xb[Lb]=qFw
set Lb=Lb+1
call SaveInteger(fc,Mhw,eb[Mhw],wFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,wFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],uFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,uFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],rFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,rFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],sFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,sFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],tFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,tFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],iFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,iFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],SFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,SFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],cFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,cFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],oFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,oFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],OFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,OFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],lFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,lFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],bFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,bFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],yFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,yFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],pFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,pFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
call SaveInteger(fc,Mhw,eb[Mhw],eFw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Mhw]==0 then
if Mhw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Mhw,eFw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Mhw]=eb[Mhw]+1
set Lb=Lb-1
endfunction
function jkw takes integer nFw,integer dFw,integer fFw,integer RFw,integer TFw,integer YFw,integer GFw,integer gFw,integer hFw,integer FFw,integer kFw,integer jFw,integer xFw,integer vFw,integer mFw,integer QFw,string WFw returns nothing
local integer EFw
local hashtable ZFw
local integer UFw
local integer IFw
local hashtable PFw
local integer AFw
local integer DFw
local hashtable HFw
local integer JFw
local integer KFw
local hashtable LFw
local integer XFw
local integer CFw
local hashtable VFw
local integer BFw
local integer NFw
local hashtable MFw
local integer wkw
local integer ukw
local hashtable rkw
local integer skw
local integer tkw
local hashtable ikw
local integer Skw
local integer ckw
local hashtable okw
local integer Okw
local integer lkw
local hashtable bkw
local integer ykw
local integer pkw
local hashtable ekw
local integer qkw
local integer akw
local hashtable nkw
local integer dkw
local integer fkw
local hashtable Rkw
local integer Tkw
local integer Ykw
local hashtable Gkw
local integer gkw
local integer hkw
local hashtable Fkw
local integer kkw
set Xb[Lb]=WFw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set EFw=LoadInteger(Rc,nFw,dFw)
set Lb=Lb-1
if EFw<=0 then
set ZFw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set UFw=eb[nFw]
set Lb=Lb-1
call SaveInteger(ZFw,nFw,dFw,UFw)
call Qjw(nFw,dFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set IFw=LoadInteger(Rc,nFw,fFw)
set Lb=Lb-1
if IFw<=0 then
set PFw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set AFw=eb[nFw]
set Lb=Lb-1
call SaveInteger(PFw,nFw,fFw,AFw)
call Qjw(nFw,fFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set DFw=LoadInteger(Rc,nFw,RFw)
set Lb=Lb-1
if DFw<=0 then
set HFw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set JFw=eb[nFw]
set Lb=Lb-1
call SaveInteger(HFw,nFw,RFw,JFw)
call Qjw(nFw,RFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set KFw=LoadInteger(Rc,nFw,TFw)
set Lb=Lb-1
if KFw<=0 then
set LFw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set XFw=eb[nFw]
set Lb=Lb-1
call SaveInteger(LFw,nFw,TFw,XFw)
call Qjw(nFw,TFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set CFw=LoadInteger(Rc,nFw,YFw)
set Lb=Lb-1
if CFw<=0 then
set VFw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set BFw=eb[nFw]
set Lb=Lb-1
call SaveInteger(VFw,nFw,YFw,BFw)
call Qjw(nFw,YFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set NFw=LoadInteger(Rc,nFw,GFw)
set Lb=Lb-1
if NFw<=0 then
set MFw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set wkw=eb[nFw]
set Lb=Lb-1
call SaveInteger(MFw,nFw,GFw,wkw)
call Qjw(nFw,GFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ukw=LoadInteger(Rc,nFw,gFw)
set Lb=Lb-1
if ukw<=0 then
set rkw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set skw=eb[nFw]
set Lb=Lb-1
call SaveInteger(rkw,nFw,gFw,skw)
call Qjw(nFw,gFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set tkw=LoadInteger(Rc,nFw,hFw)
set Lb=Lb-1
if tkw<=0 then
set ikw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Skw=eb[nFw]
set Lb=Lb-1
call SaveInteger(ikw,nFw,hFw,Skw)
call Qjw(nFw,hFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ckw=LoadInteger(Rc,nFw,FFw)
set Lb=Lb-1
if ckw<=0 then
set okw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Okw=eb[nFw]
set Lb=Lb-1
call SaveInteger(okw,nFw,FFw,Okw)
call Qjw(nFw,FFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set lkw=LoadInteger(Rc,nFw,kFw)
set Lb=Lb-1
if lkw<=0 then
set bkw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ykw=eb[nFw]
set Lb=Lb-1
call SaveInteger(bkw,nFw,kFw,ykw)
call Qjw(nFw,kFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set pkw=LoadInteger(Rc,nFw,jFw)
set Lb=Lb-1
if pkw<=0 then
set ekw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set qkw=eb[nFw]
set Lb=Lb-1
call SaveInteger(ekw,nFw,jFw,qkw)
call Qjw(nFw,jFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set akw=LoadInteger(Rc,nFw,xFw)
set Lb=Lb-1
if akw<=0 then
set nkw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set dkw=eb[nFw]
set Lb=Lb-1
call SaveInteger(nkw,nFw,xFw,dkw)
call Qjw(nFw,xFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set fkw=LoadInteger(Rc,nFw,vFw)
set Lb=Lb-1
if fkw<=0 then
set Rkw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Tkw=eb[nFw]
set Lb=Lb-1
call SaveInteger(Rkw,nFw,vFw,Tkw)
call Qjw(nFw,vFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Ykw=LoadInteger(Rc,nFw,mFw)
set Lb=Lb-1
if Ykw<=0 then
set Gkw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set gkw=eb[nFw]
set Lb=Lb-1
call SaveInteger(Gkw,nFw,mFw,gkw)
call Qjw(nFw,mFw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set hkw=LoadInteger(Rc,nFw,QFw)
set Lb=Lb-1
if hkw<=0 then
set Fkw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[nFw]==0 then
if nFw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set kkw=eb[nFw]
set Lb=Lb-1
call SaveInteger(Fkw,nFw,QFw,kkw)
call Qjw(nFw,QFw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set ZFw=null
set PFw=null
set HFw=null
set LFw=null
set VFw=null
set MFw=null
set rkw=null
set ikw=null
set okw=null
set bkw=null
set ekw=null
set nkw=null
set Rkw=null
set Gkw=null
set Fkw=null
endfunction
function Ckw takes integer xkw,integer vkw,integer mkw,integer Qkw,integer Wkw,integer Ekw,integer Zkw,integer Ukw,integer Ikw,integer Pkw,integer Akw,integer Dkw,integer Hkw,integer Jkw,integer Kkw,integer Lkw,string Xkw returns nothing
set Xb[Lb]=Xkw
set Lb=Lb+1
if IO[xkw]==0 then
if xkw==0 then
call I1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call I1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if IO[xkw]<=695 then
call aFw(xkw,vkw,mkw,Qkw,Wkw,Ekw,Zkw,Ukw,Ikw,Pkw,Akw,Dkw,Hkw,Jkw,Kkw,Lkw,"when calling add in HashList, line 25")
else
call jkw(xkw,vkw,mkw,Qkw,Wkw,Ekw,Zkw,Ukw,Ikw,Pkw,Akw,Dkw,Hkw,Jkw,Kkw,Lkw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function Egw takes integer Rgw,integer Tgw,integer Ygw,integer Ggw,integer ggw,integer hgw,integer Fgw,integer kgw,integer jgw,integer xgw,integer vgw,integer mgw,integer Qgw,string Wgw returns nothing
set Xb[Lb]=Wgw
set Lb=Lb+1
call SaveInteger(fc,Rgw,eb[Rgw],Tgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,Tgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],Ygw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,Ygw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],Ggw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,Ggw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],ggw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,ggw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],hgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,hgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],Fgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,Fgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],kgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,kgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],jgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,jgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],xgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,xgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],vgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,vgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],mgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,mgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
call SaveInteger(fc,Rgw,eb[Rgw],Qgw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rgw]==0 then
if Rgw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rgw,Qgw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rgw]=eb[Rgw]+1
set Lb=Lb-1
endfunction
function Ehw takes integer Zgw,integer Ugw,integer Igw,integer Pgw,integer Agw,integer Dgw,integer Hgw,integer Jgw,integer Kgw,integer Lgw,integer Xgw,integer Cgw,integer Vgw,string Bgw returns nothing
local integer Ngw
local hashtable Mgw
local integer whw
local integer uhw
local hashtable rhw
local integer shw
local integer thw
local hashtable ihw
local integer Shw
local integer chw
local hashtable ohw
local integer Ohw
local integer lhw
local hashtable bhw
local integer yhw
local integer phw
local hashtable ehw
local integer qhw
local integer ahw
local hashtable nhw
local integer dhw
local integer fhw
local hashtable Rhw
local integer Thw
local integer Yhw
local hashtable Ghw
local integer ghw
local integer hhw
local hashtable Fhw
local integer khw
local integer jhw
local hashtable xhw
local integer vhw
local integer mhw
local hashtable Qhw
local integer Whw
set Xb[Lb]=Bgw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Ngw=LoadInteger(Rc,Zgw,Ugw)
set Lb=Lb-1
if Ngw<=0 then
set Mgw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set whw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(Mgw,Zgw,Ugw,whw)
call Qjw(Zgw,Ugw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set uhw=LoadInteger(Rc,Zgw,Igw)
set Lb=Lb-1
if uhw<=0 then
set rhw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set shw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(rhw,Zgw,Igw,shw)
call Qjw(Zgw,Igw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set thw=LoadInteger(Rc,Zgw,Pgw)
set Lb=Lb-1
if thw<=0 then
set ihw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Shw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(ihw,Zgw,Pgw,Shw)
call Qjw(Zgw,Pgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set chw=LoadInteger(Rc,Zgw,Agw)
set Lb=Lb-1
if chw<=0 then
set ohw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Ohw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(ohw,Zgw,Agw,Ohw)
call Qjw(Zgw,Agw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set lhw=LoadInteger(Rc,Zgw,Dgw)
set Lb=Lb-1
if lhw<=0 then
set bhw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set yhw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(bhw,Zgw,Dgw,yhw)
call Qjw(Zgw,Dgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set phw=LoadInteger(Rc,Zgw,Hgw)
set Lb=Lb-1
if phw<=0 then
set ehw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set qhw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(ehw,Zgw,Hgw,qhw)
call Qjw(Zgw,Hgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ahw=LoadInteger(Rc,Zgw,Jgw)
set Lb=Lb-1
if ahw<=0 then
set nhw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set dhw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(nhw,Zgw,Jgw,dhw)
call Qjw(Zgw,Jgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set fhw=LoadInteger(Rc,Zgw,Kgw)
set Lb=Lb-1
if fhw<=0 then
set Rhw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Thw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(Rhw,Zgw,Kgw,Thw)
call Qjw(Zgw,Kgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set Yhw=LoadInteger(Rc,Zgw,Lgw)
set Lb=Lb-1
if Yhw<=0 then
set Ghw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ghw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(Ghw,Zgw,Lgw,ghw)
call Qjw(Zgw,Lgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set hhw=LoadInteger(Rc,Zgw,Xgw)
set Lb=Lb-1
if hhw<=0 then
set Fhw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set khw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(Fhw,Zgw,Xgw,khw)
call Qjw(Zgw,Xgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set jhw=LoadInteger(Rc,Zgw,Cgw)
set Lb=Lb-1
if jhw<=0 then
set xhw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set vhw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(xhw,Zgw,Cgw,vhw)
call Qjw(Zgw,Cgw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set mhw=LoadInteger(Rc,Zgw,Vgw)
set Lb=Lb-1
if mhw<=0 then
set Qhw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[Zgw]==0 then
if Zgw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set Whw=eb[Zgw]
set Lb=Lb-1
call SaveInteger(Qhw,Zgw,Vgw,Whw)
call Qjw(Zgw,Vgw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set Mgw=null
set rhw=null
set ihw=null
set ohw=null
set bhw=null
set ehw=null
set nhw=null
set Rhw=null
set Ghw=null
set Fhw=null
set xhw=null
set Qhw=null
endfunction
function Nhw takes integer Zhw,integer Uhw,integer Ihw,integer Phw,integer Ahw,integer Dhw,integer Hhw,integer Jhw,integer Khw,integer Lhw,integer Xhw,integer Chw,integer Vhw,string Bhw returns nothing
set Xb[Lb]=Bhw
set Lb=Lb+1
if IO[Zhw]==0 then
if Zhw==0 then
call I1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call I1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if IO[Zhw]<=695 then
call Egw(Zhw,Uhw,Ihw,Phw,Ahw,Dhw,Hhw,Jhw,Khw,Lhw,Xhw,Chw,Vhw,"when calling add in HashList, line 25")
else
call Ehw(Zhw,Uhw,Ihw,Phw,Ahw,Dhw,Hhw,Jhw,Khw,Lhw,Xhw,Chw,Vhw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function Tjw takes integer Vkw,integer Bkw,integer Nkw,integer Mkw,integer wjw,integer ujw,integer rjw,integer sjw,integer tjw,integer ijw,integer Sjw,integer cjw,integer ojw,integer Ojw,integer ljw,integer bjw,integer yjw,integer pjw,integer ejw,integer qjw,integer ajw,integer njw,integer djw,string fjw returns integer
local integer Rjw
set Xb[Lb]=fjw
set Lb=Lb+1
set Rjw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(Rjw,Vkw,"when calling add in LinkedList, line 393")
call ffw(Rjw,Bkw,"when calling add in LinkedList, line 393")
call ffw(Rjw,Nkw,"when calling add in LinkedList, line 393")
call ffw(Rjw,Mkw,"when calling add in LinkedList, line 393")
call ffw(Rjw,wjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,ujw,"when calling add in LinkedList, line 393")
call ffw(Rjw,rjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,sjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,tjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,ijw,"when calling add in LinkedList, line 393")
call ffw(Rjw,Sjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,cjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,ojw,"when calling add in LinkedList, line 393")
call ffw(Rjw,Ojw,"when calling add in LinkedList, line 393")
call ffw(Rjw,ljw,"when calling add in LinkedList, line 393")
call ffw(Rjw,bjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,yjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,pjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,ejw,"when calling add in LinkedList, line 393")
call ffw(Rjw,qjw,"when calling add in LinkedList, line 393")
call ffw(Rjw,ajw,"when calling add in LinkedList, line 393")
call ffw(Rjw,njw,"when calling add in LinkedList, line 393")
call ffw(Rjw,djw,"when calling add in LinkedList, line 393")
set Lb=Lb-1
return Rjw
endfunction
function gGw takes integer eGw,integer qGw,integer aGw,integer nGw,integer dGw,integer fGw,integer RGw,integer TGw,integer YGw,string GGw returns nothing
set Xb[Lb]=GGw
set Lb=Lb+1
call SaveInteger(fc,eGw,eb[eGw],qGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[eGw]==0 then
if eGw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(eGw,qGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[eGw]=eb[eGw]+1
call SaveInteger(fc,eGw,eb[eGw],aGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[eGw]==0 then
if eGw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(eGw,aGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[eGw]=eb[eGw]+1
call SaveInteger(fc,eGw,eb[eGw],nGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[eGw]==0 then
if eGw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(eGw,nGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[eGw]=eb[eGw]+1
call SaveInteger(fc,eGw,eb[eGw],dGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[eGw]==0 then
if eGw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(eGw,dGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[eGw]=eb[eGw]+1
call SaveInteger(fc,eGw,eb[eGw],fGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[eGw]==0 then
if eGw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(eGw,fGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[eGw]=eb[eGw]+1
call SaveInteger(fc,eGw,eb[eGw],RGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[eGw]==0 then
if eGw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(eGw,RGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[eGw]=eb[eGw]+1
call SaveInteger(fc,eGw,eb[eGw],TGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[eGw]==0 then
if eGw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(eGw,TGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[eGw]=eb[eGw]+1
call SaveInteger(fc,eGw,eb[eGw],YGw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[eGw]==0 then
if eGw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(eGw,YGw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[eGw]=eb[eGw]+1
set Lb=Lb-1
endfunction
function ogw takes integer hGw,integer FGw,integer kGw,integer jGw,integer xGw,integer vGw,integer mGw,integer QGw,integer WGw,string EGw returns nothing
local integer ZGw
local hashtable UGw
local integer IGw
local integer PGw
local hashtable AGw
local integer DGw
local integer HGw
local hashtable JGw
local integer KGw
local integer LGw
local hashtable XGw
local integer CGw
local integer VGw
local hashtable BGw
local integer NGw
local integer MGw
local hashtable wgw
local integer ugw
local integer rgw
local hashtable sgw
local integer tgw
local integer igw
local hashtable Sgw
local integer cgw
set Xb[Lb]=EGw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ZGw=LoadInteger(Rc,hGw,FGw)
set Lb=Lb-1
if ZGw<=0 then
set UGw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set IGw=eb[hGw]
set Lb=Lb-1
call SaveInteger(UGw,hGw,FGw,IGw)
call Qjw(hGw,FGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set PGw=LoadInteger(Rc,hGw,kGw)
set Lb=Lb-1
if PGw<=0 then
set AGw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set DGw=eb[hGw]
set Lb=Lb-1
call SaveInteger(AGw,hGw,kGw,DGw)
call Qjw(hGw,kGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set HGw=LoadInteger(Rc,hGw,jGw)
set Lb=Lb-1
if HGw<=0 then
set JGw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set KGw=eb[hGw]
set Lb=Lb-1
call SaveInteger(JGw,hGw,jGw,KGw)
call Qjw(hGw,jGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set LGw=LoadInteger(Rc,hGw,xGw)
set Lb=Lb-1
if LGw<=0 then
set XGw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set CGw=eb[hGw]
set Lb=Lb-1
call SaveInteger(XGw,hGw,xGw,CGw)
call Qjw(hGw,xGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set VGw=LoadInteger(Rc,hGw,vGw)
set Lb=Lb-1
if VGw<=0 then
set BGw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set NGw=eb[hGw]
set Lb=Lb-1
call SaveInteger(BGw,hGw,vGw,NGw)
call Qjw(hGw,vGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set MGw=LoadInteger(Rc,hGw,mGw)
set Lb=Lb-1
if MGw<=0 then
set wgw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ugw=eb[hGw]
set Lb=Lb-1
call SaveInteger(wgw,hGw,mGw,ugw)
call Qjw(hGw,mGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set rgw=LoadInteger(Rc,hGw,QGw)
set Lb=Lb-1
if rgw<=0 then
set sgw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set tgw=eb[hGw]
set Lb=Lb-1
call SaveInteger(sgw,hGw,QGw,tgw)
call Qjw(hGw,QGw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set igw=LoadInteger(Rc,hGw,WGw)
set Lb=Lb-1
if igw<=0 then
set Sgw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[hGw]==0 then
if hGw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set cgw=eb[hGw]
set Lb=Lb-1
call SaveInteger(Sgw,hGw,WGw,cgw)
call Qjw(hGw,WGw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set UGw=null
set AGw=null
set JGw=null
set XGw=null
set BGw=null
set wgw=null
set sgw=null
set Sgw=null
endfunction
function fgw takes integer Ogw,integer lgw,integer bgw,integer ygw,integer pgw,integer egw,integer qgw,integer agw,integer ngw,string dgw returns nothing
set Xb[Lb]=dgw
set Lb=Lb+1
if IO[Ogw]==0 then
if Ogw==0 then
call I1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call I1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if IO[Ogw]<=695 then
call gGw(Ogw,lgw,bgw,ygw,pgw,egw,qgw,agw,ngw,"when calling add in HashList, line 25")
else
call ogw(Ogw,lgw,bgw,ygw,pgw,egw,qgw,agw,ngw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function pGw takes integer LYw,integer XYw,integer CYw,integer VYw,integer BYw,integer NYw,integer MYw,integer wGw,integer uGw,integer rGw,integer sGw,integer tGw,integer iGw,integer SGw,integer cGw,integer oGw,integer OGw,integer lGw,string bGw returns integer
local integer yGw
set Xb[Lb]=bGw
set Lb=Lb+1
set yGw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(yGw,LYw,"when calling add in LinkedList, line 393")
call ffw(yGw,XYw,"when calling add in LinkedList, line 393")
call ffw(yGw,CYw,"when calling add in LinkedList, line 393")
call ffw(yGw,VYw,"when calling add in LinkedList, line 393")
call ffw(yGw,BYw,"when calling add in LinkedList, line 393")
call ffw(yGw,NYw,"when calling add in LinkedList, line 393")
call ffw(yGw,MYw,"when calling add in LinkedList, line 393")
call ffw(yGw,wGw,"when calling add in LinkedList, line 393")
call ffw(yGw,uGw,"when calling add in LinkedList, line 393")
call ffw(yGw,rGw,"when calling add in LinkedList, line 393")
call ffw(yGw,sGw,"when calling add in LinkedList, line 393")
call ffw(yGw,tGw,"when calling add in LinkedList, line 393")
call ffw(yGw,iGw,"when calling add in LinkedList, line 393")
call ffw(yGw,SGw,"when calling add in LinkedList, line 393")
call ffw(yGw,cGw,"when calling add in LinkedList, line 393")
call ffw(yGw,oGw,"when calling add in LinkedList, line 393")
call ffw(yGw,OGw,"when calling add in LinkedList, line 393")
call ffw(yGw,lGw,"when calling add in LinkedList, line 393")
set Lb=Lb-1
return yGw
endfunction
function ulw takes string MOw returns integer
local integer wlw
set Xb[Lb]=MOw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_HashList in HashList, line 105"
set Lb=Lb+1
if ZO==0 then
if UO<32768 then
set UO=UO+1
set wlw=UO
set IO[wlw]=695
else
call I1("Out of memory: Could not create HashList.","when calling error in HashList, line 8")
set wlw=0
endif
else
set ZO=ZO-1
set wlw=EO[ZO]
set IO[wlw]=695
endif
set Lb=Lb-1
set eb[wlw]=0
set Lb=Lb-1
return wlw
endfunction
function Kuw takes string luw returns boolean
local integer buw
local integer yuw
local integer puw
local integer euw
local integer quw
local integer auw
local integer nuw
local integer duw
local integer fuw
local integer Ruw
local integer Tuw
local integer Yuw
local integer Guw
local integer guw
local integer huw
local integer Fuw
local integer kuw
local integer juw
local integer xuw
local integer vuw
local integer muw
local integer Quw
local integer Wuw
local integer Euw
local integer Zuw
local integer Uuw
local integer Iuw
local integer Puw
local integer Auw
local integer Duw
local integer Huw
local integer Juw
set Xb[Lb]=luw
set Lb=Lb+1
set Xb[Lb]="when calling asList in Units, line 87"
set Lb=Lb+1
set auw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(auw,1211119700,"when calling add in LinkedList, line 393")
call ffw(auw,1211119699,"when calling add in LinkedList, line 393")
call ffw(auw,1211119701,"when calling add in LinkedList, line 393")
call ffw(auw,1211118401,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Lo=auw
set Xb[Lb]="when calling asList in Units, line 114"
set Lb=Lb+1
set nuw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(nuw,1747989317,"when calling add in LinkedList, line 393")
call ffw(nuw,1747989305,"when calling add in LinkedList, line 393")
call ffw(nuw,1747989316,"when calling add in LinkedList, line 393")
call ffw(nuw,1747989315,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xo=nuw
set Co=plw("when calling new_HashMap in Units, line 115")
set Vo[0]=pGw(1747988528,1747988528,1747988528,1747988528,1747988528,1747988528,1747988532,1747988532,1747988532,1747988532,1211118401,1747989058,1747989058,1747989058,1747989058,1747989058,1747989058,1747988790,"when calling asList in Units, line 122")
set Vo[1]=pGw(1747990339,1747990339,1747990339,1747990339,1747990339,1747990339,1747990340,1747990340,1747990340,1747990340,1211119699,1747990593,1747990593,1747990593,1747990593,1747990593,1747990593,1747988790,"when calling asList in Units, line 128")
set Vo[2]=pGw(1747990087,1747990087,1747990087,1747990087,1747990087,1747990087,1747990088,1747990088,1747990088,1747990088,1211119701,1747989817,1747989817,1747989817,1747989817,1747989817,1747989817,1747988790,"when calling asList in Units, line 135")
set Vo[3]=pGw(1747989558,1747989558,1747989558,1747989558,1747989558,1747989558,1747989575,1747989575,1747989575,1747989575,1211119700,1747989571,1747989571,1747989571,1747989571,1747989571,1747989571,1747988790,"when calling asList in Units, line 142")
set buw=ulw("when calling new_HashList in Units, line 151")
call fgw(buw,1747989558,1747990339,1747990087,1747988528,1747989575,1747990340,1747990088,1747988532,"when calling add in Units, line 152")
set Bo=buw
set yuw=ulw("when calling new_HashList in Units, line 164")
call Nhw(yuw,1747988529,1747988530,1747988531,1747990326,1747990327,1747990328,1747990084,1747990085,1747990086,1747989590,1747989591,1747989592,"when calling add in Units, line 165")
set No=yuw
set puw=ulw("when calling new_HashList in Units, line 180")
call Nhw(puw,1747989059,1747989060,1747988844,1747990351,1747990352,1747990356,1747989331,1747990350,1747989809,1747990353,1747990354,1747990355,"when calling add in Units, line 181")
set Mo=puw
set euw=ulw("when calling new_HashList in Units, line 196")
call Ckw(euw,1747988529,1747988530,1747988531,1747990326,1747990327,1747990328,1747990084,1747990085,1747990086,1747989590,1747989591,1747989592,1747989555,1747989297,1747989325,"when calling add in Units, line 197")
set wO=euw
set Xb[Lb]="when calling asList in Units, line 206"
set Lb=Lb+1
set duw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(duw,1747989321,"when calling add in LinkedList, line 393")
call ffw(duw,1747989321,"when calling add in LinkedList, line 393")
call ffw(duw,1747989321,"when calling add in LinkedList, line 393")
call ffw(duw,1747989321,"when calling add in LinkedList, line 393")
call ffw(duw,1747989321,"when calling add in LinkedList, line 393")
call ffw(duw,1747989321,"when calling add in LinkedList, line 393")
call ffw(duw,1747988790,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set uO[0]=duw
set Xb[Lb]="when calling asList in Units, line 207"
set Lb=Lb+1
set fuw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(fuw,1747989321,"when calling add in LinkedList, line 393")
call ffw(fuw,1747989321,"when calling add in LinkedList, line 393")
call ffw(fuw,1747989321,"when calling add in LinkedList, line 393")
call ffw(fuw,1747989326,"when calling add in LinkedList, line 393")
call ffw(fuw,1747989326,"when calling add in LinkedList, line 393")
call ffw(fuw,1747989321,"when calling add in LinkedList, line 393")
call ffw(fuw,1747989321,"when calling add in LinkedList, line 393")
call ffw(fuw,1747989321,"when calling add in LinkedList, line 393")
call ffw(fuw,1747988790,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set uO[1]=fuw
set Xb[Lb]="when calling asList in Units, line 208"
set Lb=Lb+1
set Ruw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(Ruw,1747989321,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747989321,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747989321,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747989321,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747989326,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747989326,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747989326,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747989326,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747989337,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747989337,"when calling add in LinkedList, line 393")
call ffw(Ruw,1747988790,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set uO[2]=Ruw
set Tuw=GetHandleId(gu)
set Yuw=GetHandleId(kw)
set Guw=GetHandleId(ew)
set guw=GetHandleId(qw)
set huw=GetHandleId(Ow)
set Fuw=GetHandleId(hu)
set kuw=GetHandleId(Yu)
set juw=GetHandleId(Vw)
set xuw=GetHandleId(q)
set vuw=GetHandleId(Gu)
set muw=GetHandleId(a)
set Quw=GetHandleId(fw)
set Wuw=GetHandleId(dw)
set Euw=GetHandleId(Rw)
set Zuw=GetHandleId(ow)
set Uuw=GetHandleId(lw)
set Iuw=GetHandleId(bw)
set Puw=GetHandleId(yw)
set Auw=GetHandleId(pw)
set Duw=GetHandleId(aw)
set Huw=GetHandleId(d)
set Juw=GetHandleId(n)
set rO=Tjw(Tuw,Yuw,Guw,guw,huw,Fuw,kuw,juw,xuw,vuw,muw,Quw,Wuw,Euw,Zuw,Uuw,Iuw,Puw,Auw,Duw,Huw,Juw,GetHandleId(sS),"when calling asList in Units, line 211")
set quw=Co
call Mnw(quw,1747989317,15,"when calling put in Units, line 239")
call Mnw(quw,1747989305,50,"when calling put in Units, line 240")
call Mnw(quw,1747989316,25,"when calling put in Units, line 241")
call Mnw(quw,1747989315,40,"when calling put in Units, line 242")
set Lb=Lb-1
return true
endfunction
function Xjw takes nothing returns boolean
set Lb=0
return Kuw("Units, line 1")
endfunction
function wuw takes string Nww returns nothing
local unit Mww
set Xb[Lb]=Nww
set Lb=Lb+1
set Mww=Mc[wo-1]
set Xb[Lb]="when calling toUnitIndex in UnitIndexer, line 196"
set Lb=Lb+1
if GetUnitUserData(Mww)==0 then
call mqw(Mww,"when calling new_UnitIndex in UnitIndexer, line 135")
endif
set Lb=Lb-1-1
set Mww=null
endfunction
function Xxw takes nothing returns nothing
set Lb=0
call wuw("UnitIndexer, line 196")
endfunction
function YH takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988553 then
return false
endif
return true
endfunction
function YI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989836,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989837,0)
endfunction
function TP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function YP takes nothing returns boolean
if not TP() then
return false
endif
return true
endfunction
function TZ takes nothing returns boolean
if GetResearched()!=1378889810 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889810,true)!=1 then
return false
endif
return true
endfunction
function YZ takes nothing returns boolean
if not TZ() then
return false
endif
return true
endfunction
function Rx takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747990581 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990580 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989813 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747988569 then
return true
endif
return false
endfunction
function Tx takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989048 then
return false
endif
if not Rx() then
return false
endif
return true
endfunction
function Yx takes nothing returns boolean
if not Tx() then
return false
endif
return true
endfunction
function X1 takes string H1 returns boolean
local playerunitevent J1
local integer K1
local integer L1
set Xb[Lb]=H1
set Lb=Lb+1
set J1=EVENT_PLAYER_UNIT_ATTACKED
set Xb[Lb]="when calling alloc_Garissons_EventListener_line7 in Garissons, line 7"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set K1=cO
set oO[K1]=670
else
call I1("Out of memory: Could not create Garissons_EventListener_line7.","when calling error in Garissons, line 7")
set K1=0
endif
else
set SO=SO-1
set K1=iO[SO]
set oO[K1]=670
endif
set Lb=Lb-1
set Ml[K1]=0
set wb[K1]=0
set ub[K1]=0
set Xb[Lb]="when calling add in Garissons, line 7"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set L1=QS[GetHandleId(J1)]
if L1==0 then
set L1=QV(J1,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[K1]=L1
if US[Ml[K1]]!=0 then
set ub[US[Ml[K1]]]=K1
set wb[K1]=US[Ml[K1]]
endif
set US[Ml[K1]]=K1
set Lb=Lb-1-1
set J1=null
return true
endfunction
function Yxw takes nothing returns boolean
set Lb=0
return X1("Garissons, line 1")
endfunction
function Z8 takes nothing returns boolean
return true
endfunction
function ZA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990604,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990602,0)
endfunction
function ZD takes nothing returns nothing
local player QD=GetOwningPlayer(GetTriggerUnit())
local boolexpr WD=Condition(Wa)
local group ED=CreateGroup()
local code vD
local boolean mD
call GroupEnumUnitsOfPlayer(ED,QD,WD)
call DestroyBoolExpr(WD)
set vD=Ea
set mD=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(ED,vD)
if mD then
call DestroyGroup(ED)
endif
set QD=null
set WD=null
set ED=null
endfunction
function EI takes nothing returns boolean
if GetResearched()!=1378890032 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890032,true)!=1 then
return false
endif
return true
endfunction
function ZI takes nothing returns boolean
if not EI() then
return false
endif
return true
endfunction
function ZJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function ZY takes nothing returns nothing
local player vY=GetOwningPlayer(GetAttacker())
local player mY=GetOwningPlayer(GetAttacker())
local player QY
local player WY
local unit EY
set r[GetPlayerId(vY)+1]=r[GetPlayerId(mY)+1]+1
set QY=GetOwningPlayer(GetTriggerUnit())
set WY=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(QY)+1]=r[GetPlayerId(WY)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set EY=GetTriggerUnit()
call SetUnitState(EY,UNIT_STATE_LIFE,GetUnitState(EY,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set vY=null
set mY=null
set QY=null
set WY=null
set EY=null
endfunction
function Zm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988558,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989057,0)
endfunction
function Zww takes nothing returns boolean
return true
endfunction
function Zew takes integer Qew,integer Wew returns nothing
local integer Eew
if Ub[Qew]!=-1 then
call ForceRemovePlayer(yc[Ub[Qew]],Ib[Qew])
endif
set Ub[Qew]=Wew
call ForceAddPlayer(yc[Ub[Qew]],Ib[Qew])
call SetPlayerTechMaxAllowed(Ib[Qew],1747990087,0)
call SetPlayerTechMaxAllowed(Ib[Qew],1747990088,0)
call SetPlayerTechMaxAllowed(Ib[Qew],1747989558,0)
call SetPlayerTechMaxAllowed(Ib[Qew],1747989575,0)
call SetPlayerTechMaxAllowed(Ib[Qew],1747990339,0)
call SetPlayerTechMaxAllowed(Ib[Qew],1747990340,0)
call SetPlayerTechMaxAllowed(Ib[Qew],1747988528,0)
call SetPlayerTechMaxAllowed(Ib[Qew],1747988532,0)
set Eew=Ub[Qew]
if Eew==0 then
call SetPlayerTechMaxAllowed(Ib[Qew],1747988528,-1)
call SetPlayerTechMaxAllowed(Ib[Qew],1747988532,-1)
elseif Eew==1 then
call SetPlayerTechMaxAllowed(Ib[Qew],1747990339,-1)
call SetPlayerTechMaxAllowed(Ib[Qew],1747990340,-1)
elseif Eew==2 then
call SetPlayerTechMaxAllowed(Ib[Qew],1747990087,-1)
call SetPlayerTechMaxAllowed(Ib[Qew],1747990088,-1)
elseif Eew==3 then
call SetPlayerTechMaxAllowed(Ib[Qew],1747989558,-1)
call SetPlayerTechMaxAllowed(Ib[Qew],1747989575,-1)
endif
endfunction
function Ztw takes integer mtw,integer Qtw,string Wtw returns nothing
local integer Etw
set Xb[Lb]=Wtw
set Lb=Lb+1
set Etw=vl[mtw]
if Etw==0 then
set Xb[Lb]="when calling replaceCity in City, line 218"
set Lb=Lb+1
if qO[mtw]==0 then
if mtw==0 then
call I1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call I1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call gtw(mtw,1747988529,"when calling replaceCity in City, line 194")
set Lb=Lb-1
elseif Etw==3 then
set Xb[Lb]="when calling replaceCity in City, line 220"
set Lb=Lb+1
if qO[mtw]==0 then
if mtw==0 then
call I1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call I1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call gtw(mtw,1747989590,"when calling replaceCity in City, line 194")
set Lb=Lb-1
elseif Etw==1 then
set Xb[Lb]="when calling replaceCity in City, line 222"
set Lb=Lb+1
if qO[mtw]==0 then
if mtw==0 then
call I1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call I1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call gtw(mtw,1747990326,"when calling replaceCity in City, line 194")
set Lb=Lb-1
elseif Etw==2 then
set Xb[Lb]="when calling replaceCity in City, line 224"
set Lb=Lb+1
if qO[mtw]==0 then
if mtw==0 then
call I1("Nullpointer exception when calling City.replaceCity","when calling error in City, line 194")
else
call I1("Called City.replaceCity on invalid object.","when calling error in City, line 194")
endif
endif
call gtw(mtw,1747990084,"when calling replaceCity in City, line 194")
set Lb=Lb-1
endif
set Xb[Lb]="when calling changeOwner in City, line 225"
set Lb=Lb+1
if qO[mtw]==0 then
if mtw==0 then
call I1("Nullpointer exception when calling City.changeOwner","when calling error in City, line 199")
else
call I1("Called City.changeOwner on invalid object.","when calling error in City, line 199")
endif
endif
call vtw(mtw,Qtw,"when calling changeOwner in City, line 199")
set Lb=Lb-1-1
endfunction
function vC takes string qC returns nothing
local integer aC
local integer nC
local integer dC
local integer fC
local integer RC
local integer TC
local integer YC
local integer GC
local integer gC
local integer hC
local player FC
local location kC
local real jC
local integer xC
set Xb[Lb]=qC
set Lb=Lb+1
set aC=bV(GetSpellTargetUnit(),"when calling getCityId in CityManage, line 19")
set fC=kS[aC]
set Xb[Lb]="when calling getCityForceId in CityManage, line 20"
set Lb=Lb+1
if qO[fC]==0 then
if fC==0 then
call I1("Nullpointer exception when calling City.getCityForceId","when calling error in City, line 191")
else
call I1("Called City.getCityForceId on invalid object.","when calling error in City, line 191")
endif
endif
set RC=vl[fC]
set Lb=Lb-1
set nC=GetPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))
set TC=uo[nC]
set Xb[Lb]="when calling changeForce in CityManage, line 22"
set Lb=Lb+1
if ll[TC]==0 then
if TC==0 then
call I1("Nullpointer exception when calling PlayerStats.changeForce","when calling error in PlayerStats, line 125")
else
call I1("Called PlayerStats.changeForce on invalid object.","when calling error in PlayerStats, line 125")
endif
endif
call Zew(TC,RC)
set Lb=Lb-1
set YC=Vo[RC]
set Xb[Lb]="when calling iterator in CityManage, line 25"
set Lb=Lb+1
set GC=dbw(YC,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set dC=GC
loop
exitwhen Tb[Gb[dC]]==Yb[dC]
set Gb[dC]=Tb[Gb[dC]]
set gC=1
set hC=fb[Gb[dC]]
set FC=ro[nC]
set kC=GetSpellTargetLoc()
set jC=0.
call GroupClear(bj_lastCreatedGroup)
loop
set gC=gC-1
exitwhen gC<0
call CreateUnitAtLocSaveLast(FC,hC,kC,jC)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
endloop
set Xb[Lb]="when calling close in CityManage, line 25"
set Lb=Lb+1
if hb[dC]then
call edw(dC,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1
set xC=kS[aC]
set Xb[Lb]="when calling settleCity in CityManage, line 28"
set Lb=Lb+1
if qO[xC]==0 then
if xC==0 then
call I1("Nullpointer exception when calling City.settleCity","when calling error in City, line 215")
else
call I1("Called City.settleCity on invalid object.","when calling error in City, line 215")
endif
endif
call Ztw(xC,nC,"when calling settleCity in City, line 215")
set Lb=Lb-1
call KillUnit(GetSpellAbilityUnit())
set Lb=Lb-1
set FC=null
set kC=null
endfunction
function Zxw takes nothing returns nothing
set Lb=0
call vC("CityManage, line 18")
endfunction
function qL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990327 then
return false
endif
return true
endfunction
function aL takes nothing returns boolean
if not qL() then
return false
endif
return true
endfunction
function aP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990322,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990105,0)
endfunction
function qU takes nothing returns boolean
if GetResearched()!=1378890037 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890037,true)!=1 then
return false
endif
return true
endfunction
function aU takes nothing returns boolean
if not qU() then
return false
endif
return true
endfunction
function qW takes nothing returns boolean
if GetResearched()!=1378889800 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889800,true)!=2 then
return false
endif
return true
endfunction
function aW takes nothing returns boolean
if not qW() then
return false
endif
return true
endfunction
function aZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989560,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989579,0)
endfunction
function lD takes nothing returns boolean
if GetResearched()!=1378889818 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889818,true)!=1 then
return false
endif
return true
endfunction
function bD takes nothing returns boolean
if not lD() then
return false
endif
return true
endfunction
function bE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990098,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990095,0)
endfunction
function lK takes nothing returns boolean
if GetUnitTypeId(GetConstructedStructure())!=1747989331 then
return false
endif
return true
endfunction
function bK takes nothing returns boolean
if not lK() then
return false
endif
return true
endfunction
function lQ takes nothing returns boolean
if GetResearched()!=1378889802 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889802,true)!=2 then
return false
endif
return true
endfunction
function bQ takes nothing returns boolean
if not lQ() then
return false
endif
return true
endfunction
function bY takes nothing returns nothing
local player SY=GetOwningPlayer(GetAttacker())
local player cY=GetOwningPlayer(GetAttacker())
local player oY
local player OY
local unit lY
set r[GetPlayerId(SY)+1]=r[GetPlayerId(cY)+1]+1
set oY=GetOwningPlayer(GetTriggerUnit())
set OY=GetOwningPlayer(GetTriggerUnit())
set r[GetPlayerId(oY)+1]=r[GetPlayerId(OY)+1]-1
call ReplaceUnitBJ(GetTriggerUnit(),GetUnitTypeId(GetTriggerUnit()),bj_UNIT_STATE_METHOD_DEFAULTS)
call SetUnitOwner(bj_lastReplacedUnit,GetOwningPlayer(GetAttacker()),true)
set lY=GetTriggerUnit()
call SetUnitState(lY,UNIT_STATE_LIFE,GetUnitState(lY,UNIT_STATE_MAX_LIFE)*RMaxBJ(0.,100.)*0.01)
set SY=null
set cY=null
set oY=null
set OY=null
set lY=null
endfunction
function bk takes nothing returns nothing
local player wk=GetOwningPlayer(GetSpellTargetUnit())
local playerstate uk=PLAYER_STATE_RESOURCE_LUMBER
local playerstate rk
local playerstate sk
local player tk
local force ik
local location Sk
local real ck
local real ok
local player Ok
local force lk
if uk==PLAYER_STATE_RESOURCE_GOLD then
set rk=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(wk,rk,GetPlayerState(wk,rk)+500)
elseif uk==PLAYER_STATE_RESOURCE_LUMBER then
set sk=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(wk,sk,GetPlayerState(wk,sk)+500)
endif
call SetPlayerState(wk,uk,GetPlayerState(wk,uk)+500)
call RemoveUnit(GetSpellAbilityUnit())
set tk=GetOwningPlayer(GetSpellTargetUnit())
set ik=CreateForce()
call ForceAddPlayer(ik,tk)
if IsPlayerInForce(GetLocalPlayer(),ik) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1228")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set Ok=GetOwningPlayer(GetSpellTargetUnit())
set lk=CreateForce()
call ForceAddPlayer(lk,Ok)
set Sk=y
set ck=GetLocationX(Sk)
set ok=GetLocationY(Sk)
if IsPlayerInForce(GetLocalPlayer(),lk) then
call PingMinimap(ck,ok,2.00)
endif
call RemoveLocation(y)
set wk=null
set uk=null
set rk=null
set sk=null
set tk=null
set ik=null
set Sk=null
set Ok=null
set lk=null
endfunction
function XX takes string HX returns boolean
local playerunitevent JX
local integer KX
local integer LX
set Xb[Lb]=HX
set Lb=Lb+1
set JX=EVENT_PLAYER_UNIT_CONSTRUCT_FINISH
set Xb[Lb]="when calling alloc_CityBuilded_EventListener_line9 in CityBuilded, line 9"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set KX=cO
set oO[KX]=664
else
call I1("Out of memory: Could not create CityBuilded_EventListener_line9.","when calling error in CityBuilded, line 9")
set KX=0
endif
else
set SO=SO-1
set KX=iO[SO]
set oO[KX]=664
endif
set Lb=Lb-1
set Ml[KX]=0
set wb[KX]=0
set ub[KX]=0
set Xb[Lb]="when calling add in CityBuilded, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set LX=QS[GetHandleId(JX)]
if LX==0 then
set LX=QV(JX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[KX]=LX
if US[Ml[KX]]!=0 then
set ub[US[Ml[KX]]]=KX
set wb[KX]=US[Ml[KX]]
endif
set US[Ml[KX]]=KX
set Lb=Lb-1-1
set JX=null
return true
endfunction
function bxw takes nothing returns boolean
set Lb=0
return XX("CityBuilded, line 1")
endfunction
function cA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651855,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651851,0)
endfunction
function SI takes nothing returns boolean
if GetResearched()!=1378889797 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=1 then
return false
endif
return true
endfunction
function cI takes nothing returns boolean
if not SI() then
return false
endif
return true
endfunction
function cJ takes nothing returns nothing
local integer wJ=1
local integer uJ=1751343475
local player rJ=GetOwningPlayer(GetTriggerUnit())
local rect SJ=bj_mapInitialPlayableArea
local location iJ=Location(GetRectCenterX(SJ),GetRectCenterY(SJ))
local location sJ=Location(GetLocationX(iJ)+100000000.00,GetLocationY(iJ)+100000000.00)
local real tJ=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set wJ=wJ-1
exitwhen wJ<0
call CreateUnitAtLocSaveLast(rJ,uJ,sJ,tJ)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set rJ=null
set sJ=null
set iJ=null
set SJ=null
endfunction
function cm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988565,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988563,0)
endfunction
function cv takes nothing returns nothing
call SetMapFlag(MAP_LOCK_RESOURCE_TRADING,false)
endfunction
function cxw takes nothing returns boolean
local integer rxw
local integer sxw
local integer txw
local integer ixw
local integer Sxw
set Lb=0
set Xb[Lb]="City, line 1"
set Lb=Lb+1
set RS=120.0
set TS[0]=0.0020
set TS[1]=0.0025
set Xb[Lb]="when calling asList in City, line 37"
set Lb=Lb+1
set rxw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(rxw,10000,"when calling add in LinkedList, line 393")
call ffw(rxw,20000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set YS[0]=rxw
set Xb[Lb]="when calling asList in City, line 38"
set Lb=Lb+1
set sxw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(sxw,30000,"when calling add in LinkedList, line 393")
call ffw(sxw,40000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set YS[1]=sxw
set Xb[Lb]="when calling asList in City, line 39"
set Lb=Lb+1
set txw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(txw,60000,"when calling add in LinkedList, line 393")
call ffw(txw,90000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set YS[2]=txw
set Xb[Lb]="when calling asList in City, line 40"
set Lb=Lb+1
set ixw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(ixw,120000,"when calling add in LinkedList, line 393")
call ffw(ixw,160000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set YS[3]=ixw
set Xb[Lb]="when calling asList in City, line 41"
set Lb=Lb+1
set Sxw=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(Sxw,180000,"when calling add in LinkedList, line 393")
call ffw(Sxw,220000,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set YS[4]=Sxw
set GS[0]=1.0
set GS[1]=0.5
set GS[2]=1.6
set GS[3]=2.0
set gS[0]=0.0
set gS[1]=20.0
set gS[2]=-25.0
set gS[3]=-60.0
set hS[0]=0.05
set hS[1]=0.0
set hS[2]=0.15
set hS[3]=0.30
set FS[0]=1.0
set FS[1]=1.1
set FS[2]=0.85
set FS[3]=0.7
set Lb=Lb-1
return true
endfunction
function d2 takes nothing returns nothing
set jc=jc+0.01
endfunction
function nD takes nothing returns boolean
if GetResearched()!=1378890041 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890041,true)!=1 then
return false
endif
return true
endfunction
function dD takes nothing returns boolean
if not nD() then
return false
endif
return true
endfunction
function dE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990099,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990096,0)
endfunction
function nK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990350 then
return false
endif
return true
endfunction
function dK takes nothing returns boolean
if not nK() then
return false
endif
return true
endfunction
function nQ takes nothing returns boolean
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=1 then
return false
endif
return true
endfunction
function dQ takes nothing returns boolean
if not nQ() then
return false
endif
return true
endfunction
function ak takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function nk takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988791 then
return false
endif
if not ak() then
return false
endif
return true
endfunction
function dk takes nothing returns boolean
if not nk() then
return false
endif
return true
endfunction
function eM takes string bM returns boolean
local integer yM
local timer pM
set Xb[Lb]=bM
set Lb=Lb+1
set Xb[Lb]="when calling alloc_Credits_CallbackPeriodic_line5 in Credits, line 5"
set Lb=Lb+1
if hO==0 then
if FO<32768 then
set FO=FO+1
set yM=FO
set kO[yM]=633
else
call I1("Out of memory: Could not create Credits_CallbackPeriodic_line5.","when calling error in Credits, line 5")
set yM=0
endif
else
set hO=hO-1
set yM=gO[hO]
set kO[yM]=633
endif
set Lb=Lb-1
set Xb[Lb]="when calling doPeriodically in Credits, line 5"
set Lb=Lb+1
set pM=iww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call onw(yM,pM,600,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set pM=null
return true
endfunction
function dxw takes nothing returns boolean
set Lb=0
return eM("Credits, line 1")
endfunction
function e4 takes nothing returns boolean
set hc=false
set Fc=false
set kc=CreateTimer()
call TimerStart(kc,0.01,true,Kf)
return true
endfunction
function eA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651852,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651855,0)
endfunction
function eC takes nothing returns boolean
local boolean yC
local boolean pC
if GetUnitTypeId(GetSpellAbilityUnit())==1747988553 then
set yC=GetUnitTypeId(GetSpellTargetUnit())==1747989297
else
set yC=false
endif
if yC then
set pC=GetPlayerId(GetOwningPlayer(GetSpellTargetUnit()))==PLAYER_NEUTRAL_AGGRESSIVE
else
set pC=false
endif
return pC
endfunction
function pI takes nothing returns boolean
if GetResearched()!=1378889797 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=2 then
return false
endif
return true
endfunction
function eI takes nothing returns boolean
if not pI() then
return false
endif
return true
endfunction
function eJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function eX takes nothing returns boolean
return true
endfunction
function em takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988566,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988562,0)
endfunction
function aV takes string yV returns boolean
local playerunitevent pV
local integer eV
local integer qV
set Xb[Lb]=yV
set Lb=Lb+1
set pV=EVENT_PLAYER_UNIT_SPELL_CAST
set Xb[Lb]="when calling alloc_Clerics_EventListener_line5 in Clerics, line 5"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set eV=cO
set oO[eV]=668
else
call I1("Out of memory: Could not create Clerics_EventListener_line5.","when calling error in Clerics, line 5")
set eV=0
endif
else
set SO=SO-1
set eV=iO[SO]
set oO[eV]=668
endif
set Lb=Lb-1
set Ml[eV]=0
set wb[eV]=0
set ub[eV]=0
set Xb[Lb]="when calling add in Clerics, line 5"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set qV=QS[GetHandleId(pV)]
if qV==0 then
set qV=QV(pV,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[eV]=qV
if US[Ml[eV]]!=0 then
set ub[US[Ml[eV]]]=eV
set wb[eV]=US[Ml[eV]]
endif
set US[Ml[eV]]=eV
set Lb=Lb-1-1
set pV=null
return true
endfunction
function exw takes nothing returns boolean
set Lb=0
return aV("Clerics, line 1")
endfunction
function initMapBounds takes nothing returns nothing
local rect cond_result
local region receiver
local real temp
local real tuple_temp
set xc=bj_mapInitialPlayableArea
call RegionAddRect(CreateRegion(),xc)
set cond_result=GetWorldBounds()
set vc=cond_result
set receiver=CreateRegion()
call RegionAddRect(receiver,vc)
set mc=receiver
set temp=GetRectMaxX(vc)
set tuple_temp=GetRectMaxY(vc)
set Qc=temp
set Wc=tuple_temp
endfunction
function f2 takes nothing returns boolean
call initMapBounds()
return true
endfunction
function fD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651850,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651849,0)
endfunction
function fF takes nothing returns nothing
local group aF
local code nF
local boolean dF
set w=GetUnitsOfTypeIdAll(1747988790)
set aF=w
set nF=yp
set dF=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(aF,nF)
if dF then
call DestroyGroup(aF)
endif
call DestroyGroup(w)
set aF=null
endfunction
function fK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function fQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989065,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989296,0)
endfunction
function p1 takes string S1 returns boolean
local integer c1
local integer o1
local integer O1
local timer l1
local integer b1
local timer y1
set Xb[Lb]=S1
set Lb=Lb+1
set c1=0
set o1=23
loop
exitwhen c1>o1
set ic[c1]=0
set c1=c1+1
endloop
set Xb[Lb]="when calling alloc_Economy_CallbackPeriodic_line47 in Economy, line 47"
set Lb=Lb+1
if hO==0 then
if FO<32768 then
set FO=FO+1
set O1=FO
set kO[O1]=635
else
call I1("Out of memory: Could not create Economy_CallbackPeriodic_line47.","when calling error in Economy, line 47")
set O1=0
endif
else
set hO=hO-1
set O1=gO[hO]
set kO[O1]=635
endif
set Lb=Lb-1
set Xb[Lb]="when calling doPeriodically in Economy, line 47"
set Lb=Lb+1
set l1=iww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call onw(O1,l1,0.333333343,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1
set Xb[Lb]="when calling alloc_Economy_CallbackPeriodic_line54 in Economy, line 54"
set Lb=Lb+1
if hO==0 then
if FO<32768 then
set FO=FO+1
set b1=FO
set kO[b1]=636
else
call I1("Out of memory: Could not create Economy_CallbackPeriodic_line54.","when calling error in Economy, line 54")
set b1=0
endif
else
set hO=hO-1
set b1=gO[hO]
set kO[b1]=636
endif
set Lb=Lb-1
set Xb[Lb]="when calling doPeriodically in Economy, line 54"
set Lb=Lb+1
set y1=iww("when calling getTimer in ClosureTimers, line 57")
set Xb[Lb]="when calling doPeriodically in ClosureTimers, line 57"
set Lb=Lb+1
call onw(b1,y1,10.0,"when calling start in ClosureTimers, line 45")
set Lb=Lb-1-1-1
set l1=null
set y1=null
return true
endfunction
function fxw takes nothing returns boolean
set Lb=0
return p1("Economy, line 1")
endfunction
function gD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990584,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990594,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990583,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990607,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990598,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990606,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990599,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990601,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651855,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651852,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1848651850,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990595,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990596,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990604,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990603,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990322,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990323,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990321,0)
call SetPlayerTechMaxAllowed(GetEnumPlayer(),1747990324,0)
endfunction
function GE takes nothing returns boolean
if GetResearched()!=1378889807 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889807,true)!=1 then
return false
endif
return true
endfunction
function gE takes nothing returns boolean
if not GE() then
return false
endif
return true
endfunction
function gL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function gU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651848,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651846,0)
endfunction
function gW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651828,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651827,0)
endfunction
function gww takes nothing returns boolean
return true
endfunction
function L4 takes string v4 returns nothing
local integer m4
local integer Q4
local real W4
local player E4
local integer Z4
local integer U4
local integer I4
local boolean P4
local location A4
local integer D4
local real H4
local real J4
local real K4
set Xb[Lb]=v4
set Lb=Lb+1
set m4=24
set Q4=6
set W4=100.0
loop
exitwhen m4<=0
set Z4=1
set U4=Q4
loop
exitwhen Z4>U4
set H4=Z4*6.28318/Q4
set J4=311.2+W4*Cos(H4)
set K4=5166.7+W4*Sin(H4)
set E4=ro[24-m4+Z4-1]
set I4=uo[GetPlayerId(E4)]
set v4="when calling isInGame in MainInit, line 54"
set Xb[Lb]="when calling isInGame in MainInit, line 54"
set Lb=Lb+1
if ll[I4]==0 then
if I4==0 then
call I1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call I1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set P4=Pb[I4]
set Lb=Lb-1
if P4 then
set A4=Location(J4,K4)
call CreateNUnitsAtLoc(1,1747988554,E4,A4,AngleBetweenPoints(A4,Location(311.2,5166.7)))
endif
set Z4=Z4+1
endloop
set W4=W4+50.0
set m4=m4-Q4
set Q4=Q4+2
if m4<2147483647 then
set D4=m4
else
set D4=2147483647
endif
if Q4<D4 then
set D4=Q4
endif
set Q4=D4
endloop
set Lb=Lb-1
set E4=null
set A4=null
endfunction
function Xew takes player Uew,string Iew returns integer
local integer Pew
local integer Aew
local integer Dew
local player Hew
local integer Jew
local integer Kew
local boolean Lew
set Xb[Lb]=Iew
set Lb=Lb+1
set Xb[Lb]="when calling alloc_PlayerStats in PlayerStats, line 16"
set Lb=Lb+1
if ol==0 then
if Ol<32768 then
set Ol=Ol+1
set Aew=Ol
set ll[Aew]=717
else
call I1("Out of memory: Could not create PlayerStats.","when calling error in PlayerStats, line 6")
set Aew=0
endif
else
set ol=ol-1
set Aew=cl[ol]
set ll[Aew]=717
endif
set Lb=Lb-1
set Pew=Aew
set Dew=Aew
set Hew=Uew
set Xb[Lb]="when calling construct_PlayerStats in PlayerStats, line 16"
set Lb=Lb+1
set Pb[Aew]=false
set Hb[Aew]=false
set Db[Aew]=0
set Ub[Aew]=-1
set Ab[Aew]=-1
set Ib[Aew]=Uew
if GetPlayerSlotState(Uew)==PLAYER_SLOT_STATE_PLAYING then
set Lew=GetPlayerController(Uew)==MAP_CONTROL_USER
else
set Lew=false
endif
set Pb[Aew]=Lew
set Jew=0
set Kew=23
loop
exitwhen Jew>Kew
if ro[Jew]==Hew then
call ovw(Dew,Jew,-1,"when writing array PlayerStats_alliance_states in PlayerStats, line 25")
else
call ovw(Dew,Jew,bj_ALLIANCE_UNALLIED,"when writing array PlayerStats_alliance_states in PlayerStats, line 27")
endif
set Jew=Jew+1
endloop
set Lb=Lb-1-1
set Hew=null
return Pew
endfunction
function Yww takes rect qww,string aww,integer nww,integer dww,string fww returns nothing
local group Rww_2
local unit Tww
set Xb[Lb]=fww
set Lb=Lb+1
set Rww_2=CreateGroup()
call GroupEnumUnitsInRect(Rww_2,qww,null)
call DestroyBoolExpr(null)
set Tww=FirstOfGroup(Rww_2)
call GroupRemoveUnit(Rww_2,Tww)
set kS[fS]=oSw(Tww,aww,nww,dww,"when calling new_City in SettingCities, line 8")
set Lb=Lb-1
set Rww_2=null
set Tww=null
endfunction
function x4 takes string q4 returns boolean
local integer a4
local integer n4
local trigger d4
local integer f4
local integer R4
local integer T4
local integer Y4
local integer G4
local player g4
local integer h4
local player F4
local boolean k4
local boolean j4
set Xb[Lb]=q4
set Lb=Lb+1
set f4=Rww("You're playing |cffffff65Crusade over Europe|r.\n\nUse your |cff0011ffsettler|r to choose the foundation of your new kingdom.\nThe location you choose will |cffff0000determine the faction you will get|r.\nUse the |cff00ffffF1|r menu to create alliances.\nExpand quickly, Capture cities and ores to |cffff0000increase your income|r.\nUse the |cff00fff2F2|r menu to set the taxes of your newly acquired |cff0026ffcities|r.\nFor more information, please, go to |cff00d3f8F9 menu|r.","when calling stringToIndex in MainInit, line 21")
set Xb[Lb]="when calling asList in MainInit, line 20"
set Lb=Lb+1
set R4=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(R4,f4,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Gc=R4
set T4=0
set Y4=0
set G4=23
loop
exitwhen Y4>G4
set g4=ro[Y4]
if GetPlayerSlotState(g4)==PLAYER_SLOT_STATE_PLAYING then
set k4=GetPlayerController(g4)==MAP_CONTROL_USER
else
set k4=false
endif
if k4 then
set T4=T4+1
endif
set Y4=Y4+1
endloop
if hc then
call d5("Debug info is enabled. Only for Red.")
endif
if Fc then
call DisplayTimedTextToPlayer(so,0.,0.,45.,"Debug mode is on.")
endif
set Xb[Lb]="when calling setupCities in MainInit, line 106"
set Lb=Lb+1
call Yww(h,"Adrianopolis",3,1,"when calling newCity in SettingCities, line 27")
call Yww(Ss,"Arta",3,0,"when calling newCity in SettingCities, line 28")
call Yww(Br,"Athens",3,1,"when calling newCity in SettingCities, line 29")
call Yww(Vr,"Ragusa",3,0,"when calling newCity in SettingCities, line 30")
call Yww(ls,"Canakkale",3,0,"when calling newCity in SettingCities, line 31")
call Yww(cs,"Candia",3,0,"when calling newCity in SettingCities, line 32")
call Yww(k,"Constantinople",3,4,"when calling newCity in SettingCities, line 33")
call Yww(is,"Corinth",3,0,"when calling newCity in SettingCities, line 34")
call Yww(g,"Durazzo",3,0,"when calling newCity in SettingCities, line 35")
call Yww(ws,"Nikomedeia",3,0,"when calling newCity in SettingCities, line 36")
call Yww(lu,"Kutaisi",3,0,"when calling newCity in SettingCities, line 37")
call Yww(Dw,"Nicae",3,2,"when calling newCity in SettingCities, line 38")
call Yww(Zw,"Nicosia",3,0,"when calling newCity in SettingCities, line 39")
call Yww(Nr,"Rhodes",3,0,"when calling newCity in SettingCities, line 40")
call Yww(x,"Scopia",3,0,"when calling newCity in SettingCities, line 41")
call Yww(Pw,"Smyrna",3,0,"when calling newCity in SettingCities, line 42")
call Yww(bu,"Tbilisi",3,0,"when calling newCity in SettingCities, line 43")
call Yww(Ew,"Trebizond",3,1,"when calling newCity in SettingCities, line 44")
call Yww(F,"Thessalonika",3,3,"when calling newCity in SettingCities, line 45")
call Yww(Qu,"Astrakhan'",1,2,"when calling newCity in SettingCities, line 49")
call Yww(Gw,"Azaq",1,0,"when calling newCity in SettingCities, line 50")
call Yww(ru,"Baia",1,0,"when calling newCity in SettingCities, line 51")
call Yww(cu,"Bryansk",1,0,"when calling newCity in SettingCities, line 52")
call Yww(sw,"Caffa",1,0,"when calling newCity in SettingCities, line 53")
call Yww(U,"Constanta",1,0,"when calling newCity in SettingCities, line 54")
call Yww(iu,"Dnipro",1,0,"when calling newCity in SettingCities, line 55")
call Yww(nw,"Halych",1,0,"when calling newCity in SettingCities, line 56")
call Yww(gw,"Kiev",1,2,"when calling newCity in SettingCities, line 57")
call Yww(N,"Konigsberg",1,0,"when calling newCity in SettingCities, line 58")
call Yww(uw,"Hrodna",1,0,"when calling newCity in SettingCities, line 59")
call Yww(hw,"Minsk",1,1,"when calling newCity in SettingCities, line 60")
call Yww(Su,"Moscow",1,0,"when calling newCity in SettingCities, line 61")
call Yww(Sw,"Novgorod",1,0,"when calling newCity in SettingCities, line 62")
call Yww(tu,"Olesh'e",1,0,"when calling newCity in SettingCities, line 63")
call Yww(cw,"Polotsk",1,0,"when calling newCity in SettingCities, line 64")
call Yww(tw,"Pskov",1,0,"when calling newCity in SettingCities, line 65")
call Yww(iw,"Reval",1,0,"when calling newCity in SettingCities, line 66")
call Yww(M,"Riga",1,1,"when calling newCity in SettingCities, line 67")
call Yww(bs,"Bulgar",1,0,"when calling newCity in SettingCities, line 68")
call Yww(Wu,"Ryazan'",1,0,"when calling newCity in SettingCities, line 69")
call Yww(Ou,"Sarkel",1,0,"when calling newCity in SettingCities, line 70")
call Yww(Fw,"Smolensk",1,1,"when calling newCity in SettingCities, line 71")
call Yww(L,"Sofia",1,0,"when calling newCity in SettingCities, line 72")
call Yww(I,"Targovitse",1,1,"when calling newCity in SettingCities, line 73")
call Yww(uu,"Tmutarakan'",1,0,"when calling newCity in SettingCities, line 74")
call Yww(Mr,"Turku",1,0,"when calling newCity in SettingCities, line 75")
call Yww(rw,"Vilnius",1,1,"when calling newCity in SettingCities, line 76")
call Yww(su,"Zhytomir",1,0,"when calling newCity in SettingCities, line 77")
call Yww(au,"Acre",2,2,"when calling newCity in SettingCities, line 81")
call Yww(mw,"Adana",2,0,"when calling newCity in SettingCities, line 82")
call Yww(as,"Alamut",2,0,"when calling newCity in SettingCities, line 83")
call Yww(nu,"Al-Aqaba",2,0,"when calling newCity in SettingCities, line 84")
call Yww(Nw,"Alexandria",2,2,"when calling newCity in SettingCities, line 85")
call Yww(Kw,"Algiers",2,0,"when calling newCity in SettingCities, line 86")
call Yww(Aw,"Ankara",2,1,"when calling newCity in SettingCities, line 87")
call Yww(Ww,"Antioch",2,2,"when calling newCity in SettingCities, line 88")
call Yww(us,"Badajoz",2,0,"when calling newCity in SettingCities, line 89")
call Yww(Os,"Baghdad",2,4,"when calling newCity in SettingCities, line 90")
call Yww(ns,"Baku",2,0,"when calling newCity in SettingCities, line 91")
call Yww(Cw,"Benghazi",2,1,"when calling newCity in SettingCities, line 92")
call Yww(es,"Beleb-el-Anab",2,0,"when calling newCity in SettingCities, line 93")
call Yww(wu,"Cairo",2,3,"when calling newCity in SettingCities, line 94")
call Yww(Tr,"Cordoba",2,4,"when calling newCity in SettingCities, line 95")
call Yww(yu,"Damascus",2,2,"when calling newCity in SettingCities, line 96")
call Yww(Mw,"Damietta",2,1,"when calling newCity in SettingCities, line 97")
call Yww(Ru,"Diyarbakir",2,0,"when calling newCity in SettingCities, line 98")
call Yww(Iw,"Edessa",2,1,"when calling newCity in SettingCities, line 99")
call Yww(Tu,"Erez",2,1,"when calling newCity in SettingCities, line 100")
call Yww(Hw,"Fes",2,3,"when calling newCity in SettingCities, line 101")
call Yww(eu,"Gaza",2,0,"when calling newCity in SettingCities, line 102")
call Yww(Rr,"Granada",2,2,"when calling newCity in SettingCities, line 103")
call Yww(xw,"Isparta",2,0,"when calling newCity in SettingCities, line 104")
call Yww(Uw,"Jerusalem",2,3,"when calling newCity in SettingCities, line 105")
call Yww(vw,"Kayseri",2,1,"when calling newCity in SettingCities, line 106")
call Yww(os,"Kerak",2,0,"when calling newCity in SettingCities, line 107")
call Yww(ds,"Kermanshah",2,0,"when calling newCity in SettingCities, line 108")
call Yww(Qw,"Konya",2,0,"when calling newCity in SettingCities, line 109")
call Yww(Sr,"Lisbon",2,0,"when calling newCity in SettingCities, line 110")
call Yww(Ur,"Luxor",2,0,"when calling newCity in SettingCities, line 111")
call Yww(tr,"Madrid",2,0,"when calling newCity in SettingCities, line 112")
call Yww(Lw,"Mahdya",2,0,"when calling newCity in SettingCities, line 113")
call Yww(Zr,"Marrakesh",2,3,"when calling newCity in SettingCities, line 114")
call Yww(Bw,"Medina",2,2,"when calling newCity in SettingCities, line 115")
call Yww(ps,"Melilla",2,0,"when calling newCity in SettingCities, line 116")
call Yww(qu,"Mosul",2,1,"when calling newCity in SettingCities, line 117")
call Yww(Yr,"Murcia",2,1,"when calling newCity in SettingCities, line 118")
call Yww(Jw,"Oran",2,0,"when calling newCity in SettingCities, line 119")
call Yww(mu,"Palma",2,1,"when calling newCity in SettingCities, line 120")
call Yww(du,"Quarisiya",2,1,"when calling newCity in SettingCities, line 121")
call Yww(Er,"Silves",2,0,"when calling newCity in SettingCities, line 122")
call Yww(jw,"Sinop",2,0,"when calling newCity in SettingCities, line 123")
call Yww(fu,"Tamiya",2,0,"when calling newCity in SettingCities, line 124")
call Yww(pu,"Tartus",2,0,"when calling newCity in SettingCities, line 125")
call Yww(qs,"Tabriz",2,0,"when calling newCity in SettingCities, line 126")
call Yww(Xw,"Tripoli",2,1,"when calling newCity in SettingCities, line 127")
call Yww(Yw,"Tunis",2,1,"when calling newCity in SettingCities, line 128")
call Yww(Gr,"Valencia",2,0,"when calling newCity in SettingCities, line 129")
call Yww(ou,"Yerevan",2,0,"when calling newCity in SettingCities, line 130")
call Yww(J,"Aarhus",0,1,"when calling newCity in SettingCities, line 134")
call Yww(Zu,"Aberdeen",0,1,"when calling newCity in SettingCities, line 135")
call Yww(Ar,"Ajaccio",0,0,"when calling newCity in SettingCities, line 136")
call Yww(dr,"Ancona",0,1,"when calling newCity in SettingCities, line 137")
call Yww(Pr,"Angers",0,0,"when calling newCity in SettingCities, line 138")
call Yww(yr,"Antwerp",0,0,"when calling newCity in SettingCities, line 139")
call Yww(ur,"Barcelona",0,1,"when calling newCity in SettingCities, line 140")
call Yww(Kr,"Bari",0,0,"when calling newCity in SettingCities, line 141")
call Yww(A,"Belgrade",0,1,"when calling newCity in SettingCities, line 142")
call Yww(mr,"Bergen",0,1,"when calling newCity in SettingCities, line 143")
call Yww(hr,"Bern",0,0,"when calling newCity in SettingCities, line 144")
call Yww(ar,"Bologna",0,1,"when calling newCity in SettingCities, line 145")
call Yww(Mu,"Bordeaux",0,1,"when calling newCity in SettingCities, line 146")
call Yww(P,"Brasov",0,0,"when calling newCity in SettingCities, line 147")
call Yww(br,"Bruges",0,0,"when calling newCity in SettingCities, line 148")
call Yww(f,"Burgh",0,0,"when calling newCity in SettingCities, line 149")
call Yww(sr,"Burgos",0,1,"when calling newCity in SettingCities, line 150")
call Yww(Lu,"Caen",0,0,"when calling newCity in SettingCities, line 151")
call Yww(Du,"Caenarfon",0,0,"when calling newCity in SettingCities, line 152")
call Yww(Dr,"Cagliari",0,0,"when calling newCity in SettingCities, line 153")
call Yww(R,"Cardiff",0,0,"when calling newCity in SettingCities, line 154")
call Yww(Bu,"Clermont",0,1,"when calling newCity in SettingCities, line 155")
call Yww(ju,"Cologne",0,1,"when calling newCity in SettingCities, line 156")
call Yww(Vu,"Dijon",0,0,"when calling newCity in SettingCities, line 157")
call Yww(Pu,"Dublin",0,0,"when calling newCity in SettingCities, line 158")
call Yww(Eu,"Edinburgh",0,0,"when calling newCity in SettingCities, line 159")
call Yww(vr,"Eikundarsund",0,0,"when calling newCity in SettingCities, line 160")
call Yww(Q,"Esztergom",0,1,"when calling newCity in SettingCities, line 161")
call Yww(Ku,"Exeter",0,0,"when calling newCity in SettingCities, line 162")
call Yww(ww,"Gdansk",0,0,"when calling newCity in SettingCities, line 163")
call Yww(D,"Flensburg",0,0,"when calling newCity in SettingCities, line 164")
call Yww(xu,"Frankfurt",0,1,"when calling newCity in SettingCities, line 165")
call Yww(T,"Galway",0,0,"when calling newCity in SettingCities, line 166")
call Yww(pr,"Genoa",0,2,"when calling newCity in SettingCities, line 167")
call Yww(Tw,"Groningen",0,0,"when calling newCity in SettingCities, line 168")
call Yww(ku,"Innsbruck",0,0,"when calling newCity in SettingCities, line 169")
call Yww(Uu,"Inverness",0,0,"when calling newCity in SettingCities, line 170")
call Yww(Au,"Desmond",0,0,"when calling newCity in SettingCities, line 171")
call Yww(Jr,"Reggio",0,0,"when calling newCity in SettingCities, line 173")
call Yww(ts,"Kalmar",0,0,"when calling newCity in SettingCities, line 174")
call Yww(V,"Kassa",0,0,"when calling newCity in SettingCities, line 175")
call Yww(E,"Krakow",0,2,"when calling newCity in SettingCities, line 176")
call Yww(rr,"Leon",0,1,"when calling newCity in SettingCities, line 177")
call Yww(Hu,"London",0,0,"when calling newCity in SettingCities, line 178")
call Yww(kr,"Lund",0,0,"when calling newCity in SettingCities, line 179")
call Yww(Fr,"Lyon",0,0,"when calling newCity in SettingCities, line 180")
call Yww(K,"Madgeburg",0,0,"when calling newCity in SettingCities, line 181")
call Yww(lr,"Marsellie",0,1,"when calling newCity in SettingCities, line 182")
call Yww(Cr,"Metz",0,0,"when calling newCity in SettingCities, line 183")
call Yww(er,"Milan",0,1,"when calling newCity in SettingCities, line 184")
call Yww(Hr,"Naples",0,1,"when calling newCity in SettingCities, line 185")
call Yww(gr,"Nuremburg",0,0,"when calling newCity in SettingCities, line 186")
call Yww(Wr,"Nykoping",0,0,"when calling newCity in SettingCities, line 187")
call Yww(rs,"Oporto",0,0,"when calling newCity in SettingCities, line 188")
call Yww(xr,"Oslo",0,1,"when calling newCity in SettingCities, line 189")
call Yww(ys,"Buda",0,1,"when calling newCity in SettingCities, line 190")
call Yww(Lr,"Palermo",0,3,"when calling newCity in SettingCities, line 191")
call Yww(cr,"Pamplona",0,0,"when calling newCity in SettingCities, line 192")
call Yww(Cu,"Paris",0,1,"when calling newCity in SettingCities, line 193")
call Yww(nr,"Pisa",0,0,"when calling newCity in SettingCities, line 194")
call Yww(X,"Plock",0,0,"when calling newCity in SettingCities, line 195")
call Yww(C,"Poznan",0,1,"when calling newCity in SettingCities, line 196")
call Yww(m,"Prague",0,0,"when calling newCity in SettingCities, line 197")
call Yww(G,"Zadar",0,0,"when calling newCity in SettingCities, line 198")
call Yww(Ir,"Rennes",0,0,"when calling newCity in SettingCities, line 199")
call Yww(Xu,"Rheims",0,0,"when calling newCity in SettingCities, line 200")
call Yww(fr,"Rome",0,1,"when calling newCity in SettingCities, line 201")
call Yww(H,"Roskilde",0,0,"when calling newCity in SettingCities, line 202")
call Yww(ir,"Salamanca",0,0,"when calling newCity in SettingCities, line 203")
call Yww(Fu,"Salzburg",0,0,"when calling newCity in SettingCities, line 204")
call Yww(jr,"Skara",0,0,"when calling newCity in SettingCities, line 205")
call Yww(W,"Stettin",0,0,"when calling newCity in SettingCities, line 206")
call Yww(ss,"Stockholm",0,1,"when calling newCity in SettingCities, line 207")
call Yww(Xr,"Syracuse",0,0,"when calling newCity in SettingCities, line 208")
call Yww(Nu,"Toulouse",0,0,"when calling newCity in SettingCities, line 209")
call Yww(B,"Varad",0,0,"when calling newCity in SettingCities, line 210")
call Yww(qr,"Venice",0,2,"when calling newCity in SettingCities, line 211")
call Yww(v,"Vienna",0,0,"when calling newCity in SettingCities, line 212")
call Yww(Qr,"Visby",0,0,"when calling newCity in SettingCities, line 213")
call Yww(j,"Warwick",0,0,"when calling newCity in SettingCities, line 214")
call Yww(Ju,"Winchester",0,1,"when calling newCity in SettingCities, line 215")
call Yww(Z,"Wroclaw",0,0,"when calling newCity in SettingCities, line 216")
call Yww(Iu,"York",0,1,"when calling newCity in SettingCities, line 217")
call Yww(Y,"Zagreb",0,0,"when calling newCity in SettingCities, line 218")
call Yww(wr,"Zaragoza",0,0,"when calling newCity in SettingCities, line 219")
call Yww(vu,"Hamburg",0,1,"when calling newCity in SettingCities, line 220")
set Lb=Lb-1
call SetForceAllianceStateBJ(bj_FORCE_ALL_PLAYERS,bj_FORCE_PLAYER[PLAYER_NEUTRAL_PASSIVE],bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(bj_FORCE_ALL_PLAYERS,bj_FORCE_ALL_PLAYERS,bj_ALLIANCE_UNALLIED)
call SetForceAllianceStateBJ(oc,oc,bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(Oc,Oc,bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(lc,lc,bj_ALLIANCE_NEUTRAL)
call SetForceAllianceStateBJ(bc,bc,bj_ALLIANCE_NEUTRAL)
set a4=0
set n4=23
loop
exitwhen a4>n4
call SetPlayerState(ro[a4],PLAYER_STATE_RESOURCE_GOLD,200)
call SetPlayerState(ro[a4],PLAYER_STATE_RESOURCE_LUMBER,200)
if Fc then
call n2(ro[a4])
endif
set uo[a4]=Xew(ro[a4],"when calling new_PlayerStats in MainInit, line 127")
set h4=uo[a4]
set F4=ro[a4]
if GetPlayerSlotState(F4)==PLAYER_SLOT_STATE_PLAYING then
set j4=GetPlayerController(F4)==MAP_CONTROL_USER
else
set j4=false
endif
set q4="when calling setInGame in MainInit, line 128"
set Xb[Lb]="when calling setInGame in MainInit, line 128"
set Lb=Lb+1
if ll[h4]==0 then
if h4==0 then
call I1("Nullpointer exception when calling PlayerStats.setInGame","when calling error in PlayerStats, line 45")
else
call I1("Called PlayerStats.setInGame on invalid object.","when calling error in PlayerStats, line 45")
endif
endif
set Pb[h4]=j4
set Lb=Lb-1
set a4=a4+1
endloop
call L4("when calling setPlayersAtStart in MainInit, line 130")
set d4=CreateTrigger()
call TriggerRegisterTimerEvent(d4,0.01,false)
call TriggerAddAction(d4,Lf)
set Lb=Lb-1
set d4=null
set g4=null
set F4=null
return true
endfunction
function gxw takes nothing returns boolean
set Lb=0
return x4("MainInit, line 1")
endfunction
function hD takes nothing returns nothing
set s=bj_FORCE_ALL_PLAYERS
call ForForce(s,ma)
endfunction
function hE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989570,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989571,0)
endfunction
function fG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990090 then
return false
endif
return true
endfunction
function RG takes nothing returns boolean
if not fG() then
return false
endif
return true
endfunction
function TG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990081 then
return false
endif
return true
endfunction
function YG takes nothing returns boolean
if not TG() then
return false
endif
return true
endfunction
function nG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990092 then
return false
endif
return true
endfunction
function dG takes nothing returns boolean
if not nG() then
return false
endif
return true
endfunction
function GG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990072 then
return false
endif
return true
endfunction
function gG takes nothing returns boolean
if not GG() then
return false
endif
return true
endfunction
function hG takes nothing returns nothing
if dG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990091,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if RG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990089,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if YG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990073,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if gG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990071,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
endfunction
function gK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989809 then
return false
endif
return true
endfunction
function hK takes nothing returns boolean
if not gK() then
return false
endif
return true
endfunction
function gQ takes nothing returns boolean
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889797,true)!=2 then
return false
endif
return true
endfunction
function hQ takes nothing returns boolean
if not gQ() then
return false
endif
return true
endfunction
function hg takes nothing returns nothing
local location ag
local location ng
local real dg
local real fg
local rect Rg
local group Tg
local group Yg
local code Gg
local boolean gg
set u=GetUnitLoc(GetSpellAbilityUnit())
set ag=u
set S=Location(GetLocationX(ag)+0.00,GetLocationY(ag)+200.00)
set ng=u
set dg=GetLocationX(ng)
set fg=GetLocationY(ng)
set o=Rect(dg-140,fg-150,dg+140,fg+150)
set Rg=o
set Tg=CreateGroup()
call GroupEnumUnitsInRect(Tg,Rg,null)
call DestroyBoolExpr(null)
set l=Tg
set Yg=l
set Gg=Xy
set gg=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Yg,Gg)
if gg then
call DestroyGroup(Yg)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747988824,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set ag=null
set ng=null
set Rg=null
set Tg=null
set Yg=null
endfunction
function hh takes nothing returns nothing
local location ah
local location nh
local real dh
local real fh
local rect Rh
local group Th
local group Yh
local code Gh
local boolean gh
set u=GetUnitLoc(GetSpellAbilityUnit())
set ah=u
set c=Location(GetLocationX(ah)+200.00,GetLocationY(ah)+0.00)
set nh=u
set dh=GetLocationX(nh)
set fh=GetLocationY(nh)
set O=Rect(dh-150,fh-140,dh+150,fh+140)
set Rh=O
set Th=CreateGroup()
call GroupEnumUnitsInRect(Th,Rh,null)
call DestroyBoolExpr(null)
set l=Th
set Yh=l
set Gh=sp
set gh=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(Yh,Gh)
if gh then
call DestroyGroup(Yh)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990081,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set ah=null
set nh=null
set Rh=null
set Th=null
set Yh=null
endfunction
function hv takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747989048 then
return false
endif
return true
endfunction
function hww takes nothing returns boolean
return true
endfunction
function Q2 takes string R2 returns boolean
local playerunitevent T2
local playerunitevent Y2
local integer G2
local integer g2
local integer h2
local integer F2
local integer k2
local integer j2
local integer x2
local integer v2
local integer m2
set Xb[Lb]=R2
set Lb=Lb+1
set Ec=plw("when calling new_HashMap in MassControl, line 7")
set G2=R2I(500000)
set g2=R2I(700000)
set h2=R2I(1000000)
set Xb[Lb]="when calling asList in MassControl, line 8"
set Lb=Lb+1
set F2=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(F2,G2,"when calling add in LinkedList, line 393")
call ffw(F2,g2,"when calling add in LinkedList, line 393")
call ffw(F2,h2,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Zc=F2
set Xb[Lb]="when calling asList in MassControl, line 14"
set Lb=Lb+1
set k2=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(k2,1211118401,"when calling add in LinkedList, line 393")
call ffw(k2,1211119699,"when calling add in LinkedList, line 393")
call ffw(k2,1211119701,"when calling add in LinkedList, line 393")
call ffw(k2,1211119700,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Uc=k2
set T2=EVENT_PLAYER_UNIT_SPELL_CAST
set Xb[Lb]="when calling alloc_MassControl_EventListener_line22 in MassControl, line 22"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set j2=cO
set oO[j2]=673
else
call I1("Out of memory: Could not create MassControl_EventListener_line22.","when calling error in MassControl, line 22")
set j2=0
endif
else
set SO=SO-1
set j2=iO[SO]
set oO[j2]=673
endif
set Lb=Lb-1
set Ml[j2]=0
set wb[j2]=0
set ub[j2]=0
set Xb[Lb]="when calling add in MassControl, line 22"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set x2=QS[GetHandleId(T2)]
if x2==0 then
set x2=QV(T2,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[j2]=x2
if US[Ml[j2]]!=0 then
set ub[US[Ml[j2]]]=j2
set wb[j2]=US[Ml[j2]]
endif
set US[Ml[j2]]=j2
set Lb=Lb-1
set Y2=EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER
set Xb[Lb]="when calling alloc_MassControl_EventListener_line32 in MassControl, line 32"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set v2=cO
set oO[v2]=674
else
call I1("Out of memory: Could not create MassControl_EventListener_line32.","when calling error in MassControl, line 32")
set v2=0
endif
else
set SO=SO-1
set v2=iO[SO]
set oO[v2]=674
endif
set Lb=Lb-1
set Ml[v2]=0
set wb[v2]=0
set ub[v2]=0
set Xb[Lb]="when calling add in MassControl, line 32"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set m2=QS[GetHandleId(Y2)]
if m2==0 then
set m2=QV(Y2,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[v2]=m2
if US[Ml[v2]]!=0 then
set ub[US[Ml[v2]]]=v2
set wb[v2]=US[Ml[v2]]
endif
set US[Ml[v2]]=v2
set Lb=Lb-1-1
set T2=null
set Y2=null
return true
endfunction
function hxw takes nothing returns boolean
set Lb=0
return Q2("MassControl, line 1")
endfunction
function i0w takes nothing returns boolean
return true
endfunction
function iD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990601,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990599,0)
endfunction
function iK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function iQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651824,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651825,0)
endfunction
function tY takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989045 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function iY takes nothing returns boolean
if not tY() then
return false
endif
return true
endfunction
function j9 takes nothing returns nothing
local unit k9=GetTriggerUnit()
if GetUnitAbilityLevel(k9,1095577649)==0 then
set Mc[wo]=k9
set wo=wo+1
call TriggerExecute(Bc)
set wo=wo-1
endif
set k9=null
endfunction
function jA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990596,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990595,0)
endfunction
function jD takes nothing returns boolean
return IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE)==true
endfunction
function kI takes nothing returns boolean
if GetResearched()!=1378890036 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890036,true)!=2 then
return false
endif
return true
endfunction
function jI takes nothing returns boolean
if not kI() then
return false
endif
return true
endfunction
function jJ takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function jM takes nothing returns boolean
local trigger gM=CreateTrigger()
local trigger hM=gM
local playerunitevent FM=EVENT_PLAYER_UNIT_SPELL_EFFECT
local integer kM=0
loop
call TriggerRegisterPlayerUnitEvent(hM,Player(kM),FM,null)
set kM=kM+1
exitwhen kM==bj_MAX_PLAYER_SLOTS
endloop
call TriggerAddCondition(gM,Condition(Df))
call TriggerAddAction(gM,Hf)
set gM=null
set hM=null
set FM=null
return true
endfunction
function jm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989057,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989058,0)
endfunction
function Clw takes string Llw returns integer
local integer Xlw
set Xb[Lb]=Llw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_HashSet in HashSet, line 4"
set Lb=Lb+1
if ZO==0 then
if UO<32768 then
set UO=UO+1
set Xlw=UO
set IO[Xlw]=696
else
call I1("Out of memory: Could not create HashSet.","when calling error in HashSet, line 5")
set Xlw=0
endif
else
set ZO=ZO-1
set Xlw=EO[ZO]
set IO[Xlw]=696
endif
set Lb=Lb-1
set eb[Xlw]=0
set Lb=Lb-1
return Xlw
endfunction
function b9 takes string c9 returns boolean
local playerunitevent o9
local integer O9
local integer l9
set Xb[Lb]=c9
set Lb=Lb+1
set Vc=Clw("when calling new_HashSet in NoStarvationOnBoat, line 6")
set o9=EVENT_PLAYER_UNIT_ISSUED_ORDER
set Xb[Lb]="when calling alloc_NoStarvationOnBoat_EventListener_line9 in NoStarvationOnBoat, line 9"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set O9=cO
set oO[O9]=676
else
call I1("Out of memory: Could not create NoStarvationOnBoat_EventListener_line9.","when calling error in NoStarvationOnBoat, line 9")
set O9=0
endif
else
set SO=SO-1
set O9=iO[SO]
set oO[O9]=676
endif
set Lb=Lb-1
set Ml[O9]=0
set wb[O9]=0
set ub[O9]=0
set Xb[Lb]="when calling add in NoStarvationOnBoat, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set l9=QS[GetHandleId(o9)]
if l9==0 then
set l9=QV(o9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[O9]=l9
if US[Ml[O9]]!=0 then
set ub[US[Ml[O9]]]=O9
set wb[O9]=US[Ml[O9]]
endif
set US[Ml[O9]]=O9
set Lb=Lb-1-1
set o9=null
return true
endfunction
function jxw takes nothing returns boolean
set Lb=0
return b9("NoStarvationOnBoat, line 1")
endfunction
function FA takes nothing returns boolean
if GetResearched()!=1378890040 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890040,true)!=2 then
return false
endif
return true
endfunction
function kA takes nothing returns boolean
if not FA() then
return false
endif
return true
endfunction
function kD takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
return true
endfunction
function kF takes nothing returns nothing
local group gF
local code hF
local boolean FF
set b=GetUnitsOfTypeIdAll(1747989301)
set gF=b
set hF=ep
set FF=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(gF,hF)
if FF then
call DestroyGroup(gF)
endif
call DestroyGroup(b)
set gF=null
endfunction
function FJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990354 then
return false
endif
return true
endfunction
function kJ takes nothing returns boolean
if not FJ() then
return false
endif
return true
endfunction
function Fm takes nothing returns boolean
if GetResearched()!=1378889796 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889796,true)!=1 then
return false
endif
return true
endfunction
function km takes nothing returns boolean
if not Fm() then
return false
endif
return true
endfunction
function S9 takes string r9 returns boolean
local playerunitevent s9
local integer t9
local integer i9
set Xb[Lb]=r9
set Lb=Lb+1
set s9=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Xb[Lb]="when calling alloc_NoShipsNearRivers_EventListener_line7 in NoShipsNearRivers, line 7"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set t9=cO
set oO[t9]=675
else
call I1("Out of memory: Could not create NoShipsNearRivers_EventListener_line7.","when calling error in NoShipsNearRivers, line 7")
set t9=0
endif
else
set SO=SO-1
set t9=iO[SO]
set oO[t9]=675
endif
set Lb=Lb-1
set Ml[t9]=0
set wb[t9]=0
set ub[t9]=0
set Xb[Lb]="when calling add in NoShipsNearRivers, line 7"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set i9=QS[GetHandleId(s9)]
if i9==0 then
set i9=QV(s9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[t9]=i9
if US[Ml[t9]]!=0 then
set ub[US[Ml[t9]]]=t9
set wb[t9]=US[Ml[t9]]
endif
set US[Ml[t9]]=t9
set Lb=Lb-1-1
set s9=null
return true
endfunction
function kxw takes nothing returns boolean
set Lb=0
return S9("NoShipsNearRivers, line 1")
endfunction
function l0w takes nothing returns boolean
return true
endfunction
function lB takes nothing returns boolean
set AS=CreateGroup()
set JS=2147483647
set LS=Filter(Uf)
return true
endfunction
function OE takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function lE takes nothing returns boolean
if not OE() then
return false
endif
return true
endfunction
function lL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function Qww takes string xww,string vww returns boolean
local integer mww=StringLength(xww)
if StringLength(vww)>mww then
return false
endif
return SubString(xww,0,StringLength(vww))==vww
endfunction
function lM takes nothing returns boolean
return Qww(GetEventPlayerChatString(),"-")
endfunction
function lN takes nothing returns boolean
local trigger cN=CreateTrigger()
local trigger SN
local integer oN
local integer ON
call TriggerAddCondition(cN,Condition(If))
call TriggerAddAction(cN,Pf)
set SN=cN
set oN=0
set ON=23
loop
exitwhen oN>ON
call TriggerRegisterPlayerChatEvent(SN,ro[oN],"-",false)
set oN=oN+1
endloop
set SN=null
set cN=null
return true
endfunction
function lU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989814,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989825,0)
endfunction
function lW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988818,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988552,0)
endfunction
function IX takes string WX returns boolean
local playerunitevent EX
local integer ZX
local integer UX
set Xb[Lb]=WX
set Lb=Lb+1
set EX=EVENT_PLAYER_UNIT_ATTACKED
set Xb[Lb]="when calling alloc_CastleCapture_EventListener_line8 in CastleCapture, line 8"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set ZX=cO
set oO[ZX]=663
else
call I1("Out of memory: Could not create CastleCapture_EventListener_line8.","when calling error in CastleCapture, line 8")
set ZX=0
endif
else
set SO=SO-1
set ZX=iO[SO]
set oO[ZX]=663
endif
set Lb=Lb-1
set Ml[ZX]=0
set wb[ZX]=0
set ub[ZX]=0
set Xb[Lb]="when calling add in CastleCapture, line 8"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set UX=QS[GetHandleId(EX)]
if UX==0 then
set UX=QV(EX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[ZX]=UX
if US[Ml[ZX]]!=0 then
set ub[US[Ml[ZX]]]=ZX
set wb[ZX]=US[Ml[ZX]]
endif
set US[Ml[ZX]]=ZX
set Lb=Lb-1-1
set EX=null
return true
endfunction
function lxw takes nothing returns boolean
set Lb=0
return IX("CastleCapture, line 1")
endfunction
function vE takes nothing returns boolean
if GetResearched()!=1378889807 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889807,true)!=2 then
return false
endif
return true
endfunction
function mE takes nothing returns boolean
if not vE() then
return false
endif
return true
endfunction
function xF takes nothing returns boolean
if GetUnitTypeId(GetSpellTargetUnit())==1747988787 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747990361 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989831 then
return true
endif
if GetUnitTypeId(GetSpellTargetUnit())==1747989040 then
return true
endif
return false
endfunction
function vF takes nothing returns boolean
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988792 then
return false
endif
if not xF() then
return false
endif
return true
endfunction
function mF takes nothing returns boolean
if not vF() then
return false
endif
return true
endfunction
function mL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function mU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989815,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989838,0)
endfunction
function mW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651843,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651842,0)
endfunction
function mX takes nothing returns boolean
return true
endfunction
function Mfw takes integer Rfw,integer Tfw,integer Yfw,integer Gfw,integer gfw,integer hfw,integer Ffw,integer kfw,integer jfw,integer xfw,integer vfw,integer mfw,integer Qfw,integer Wfw,integer Efw,integer Zfw,integer Ufw,integer Ifw,integer Pfw,integer Afw,integer Dfw,integer Hfw,integer Jfw,integer Kfw,integer Lfw,integer Xfw,integer Cfw,integer Vfw,integer Bfw,string Nfw returns nothing
set Xb[Lb]=Nfw
set Lb=Lb+1
call SaveInteger(fc,Rfw,eb[Rfw],Tfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Tfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Yfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Yfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Gfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Gfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],gfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,gfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],hfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,hfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Ffw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Ffw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],kfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,kfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],jfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,jfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],xfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,xfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],vfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,vfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],mfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,mfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Qfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Qfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Wfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Wfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Efw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Efw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Zfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Zfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Ufw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Ufw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Ifw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Ifw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Pfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Pfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Afw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Afw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Dfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Dfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Hfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Hfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Jfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Jfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Kfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Kfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Lfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Lfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Xfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Xfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Cfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Cfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Vfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Vfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
call SaveInteger(fc,Rfw,eb[Rfw],Bfw)
set Xb[Lb]="when calling incrOccurences in HashList, line 28"
set Lb=Lb+1
if IO[Rfw]==0 then
if Rfw==0 then
call I1("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call I1("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call UOw(Rfw,Bfw,"when calling incrOccurences in HashList, line 18")
set Lb=Lb-1
set eb[Rfw]=eb[Rfw]+1
set Lb=Lb-1
endfunction
function yYw takes integer wRw,integer uRw,integer rRw,integer sRw,integer tRw,integer iRw,integer SRw,integer cRw,integer oRw,integer ORw,integer lRw,integer bRw,integer yRw,integer pRw,integer eRw,integer qRw,integer aRw,integer nRw,integer dRw,integer fRw,integer RRw,integer TRw,integer YRw,integer GRw,integer gRw,integer hRw,integer FRw,integer kRw,integer jRw,string xRw returns nothing
local integer vRw
local hashtable mRw
local integer QRw
local integer WRw
local hashtable ERw
local integer ZRw
local integer URw
local hashtable IRw
local integer PRw
local integer ARw
local hashtable DRw
local integer HRw
local integer JRw
local hashtable KRw
local integer LRw
local integer XRw
local hashtable CRw
local integer VRw
local integer BRw
local hashtable NRw
local integer MRw
local integer wTw
local hashtable uTw
local integer rTw
local integer sTw
local hashtable tTw
local integer iTw
local integer STw
local hashtable cTw
local integer oTw
local integer OTw
local hashtable lTw
local integer bTw
local integer yTw
local hashtable pTw
local integer eTw
local integer qTw
local hashtable aTw
local integer nTw
local integer dTw
local hashtable fTw
local integer RTw
local integer TTw
local hashtable YTw
local integer GTw
local integer gTw
local hashtable hTw
local integer FTw
local integer kTw
local hashtable jTw
local integer xTw
local integer vTw
local hashtable mTw
local integer QTw
local integer WTw
local hashtable ETw
local integer ZTw
local integer UTw
local hashtable ITw
local integer PTw
local integer ATw
local hashtable DTw
local integer HTw
local integer JTw
local hashtable KTw
local integer LTw
local integer XTw
local hashtable CTw
local integer VTw
local integer BTw
local hashtable NTw
local integer MTw
local integer wYw
local hashtable uYw
local integer rYw
local integer sYw
local hashtable tYw
local integer iYw
local integer SYw
local hashtable cYw
local integer oYw
local integer OYw
local hashtable lYw
local integer bYw
set Xb[Lb]=xRw
set Lb=Lb+1
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set vRw=LoadInteger(Rc,wRw,uRw)
set Lb=Lb-1
if vRw<=0 then
set mRw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set QRw=eb[wRw]
set Lb=Lb-1
call SaveInteger(mRw,wRw,uRw,QRw)
call Qjw(wRw,uRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set WRw=LoadInteger(Rc,wRw,rRw)
set Lb=Lb-1
if WRw<=0 then
set ERw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ZRw=eb[wRw]
set Lb=Lb-1
call SaveInteger(ERw,wRw,rRw,ZRw)
call Qjw(wRw,rRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set URw=LoadInteger(Rc,wRw,sRw)
set Lb=Lb-1
if URw<=0 then
set IRw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set PRw=eb[wRw]
set Lb=Lb-1
call SaveInteger(IRw,wRw,sRw,PRw)
call Qjw(wRw,sRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ARw=LoadInteger(Rc,wRw,tRw)
set Lb=Lb-1
if ARw<=0 then
set DRw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set HRw=eb[wRw]
set Lb=Lb-1
call SaveInteger(DRw,wRw,tRw,HRw)
call Qjw(wRw,tRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set JRw=LoadInteger(Rc,wRw,iRw)
set Lb=Lb-1
if JRw<=0 then
set KRw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set LRw=eb[wRw]
set Lb=Lb-1
call SaveInteger(KRw,wRw,iRw,LRw)
call Qjw(wRw,iRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set XRw=LoadInteger(Rc,wRw,SRw)
set Lb=Lb-1
if XRw<=0 then
set CRw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set VRw=eb[wRw]
set Lb=Lb-1
call SaveInteger(CRw,wRw,SRw,VRw)
call Qjw(wRw,SRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set BRw=LoadInteger(Rc,wRw,cRw)
set Lb=Lb-1
if BRw<=0 then
set NRw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set MRw=eb[wRw]
set Lb=Lb-1
call SaveInteger(NRw,wRw,cRw,MRw)
call Qjw(wRw,cRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set wTw=LoadInteger(Rc,wRw,oRw)
set Lb=Lb-1
if wTw<=0 then
set uTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set rTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(uTw,wRw,oRw,rTw)
call Qjw(wRw,oRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set sTw=LoadInteger(Rc,wRw,ORw)
set Lb=Lb-1
if sTw<=0 then
set tTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set iTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(tTw,wRw,ORw,iTw)
call Qjw(wRw,ORw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set STw=LoadInteger(Rc,wRw,lRw)
set Lb=Lb-1
if STw<=0 then
set cTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set oTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(cTw,wRw,lRw,oTw)
call Qjw(wRw,lRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set OTw=LoadInteger(Rc,wRw,bRw)
set Lb=Lb-1
if OTw<=0 then
set lTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set bTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(lTw,wRw,bRw,bTw)
call Qjw(wRw,bRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set yTw=LoadInteger(Rc,wRw,yRw)
set Lb=Lb-1
if yTw<=0 then
set pTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set eTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(pTw,wRw,yRw,eTw)
call Qjw(wRw,yRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set qTw=LoadInteger(Rc,wRw,pRw)
set Lb=Lb-1
if qTw<=0 then
set aTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set nTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(aTw,wRw,pRw,nTw)
call Qjw(wRw,pRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set dTw=LoadInteger(Rc,wRw,eRw)
set Lb=Lb-1
if dTw<=0 then
set fTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set RTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(fTw,wRw,eRw,RTw)
call Qjw(wRw,eRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set TTw=LoadInteger(Rc,wRw,qRw)
set Lb=Lb-1
if TTw<=0 then
set YTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set GTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(YTw,wRw,qRw,GTw)
call Qjw(wRw,qRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set gTw=LoadInteger(Rc,wRw,aRw)
set Lb=Lb-1
if gTw<=0 then
set hTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set FTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(hTw,wRw,aRw,FTw)
call Qjw(wRw,aRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set kTw=LoadInteger(Rc,wRw,nRw)
set Lb=Lb-1
if kTw<=0 then
set jTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set xTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(jTw,wRw,nRw,xTw)
call Qjw(wRw,nRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set vTw=LoadInteger(Rc,wRw,dRw)
set Lb=Lb-1
if vTw<=0 then
set mTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set QTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(mTw,wRw,dRw,QTw)
call Qjw(wRw,dRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set WTw=LoadInteger(Rc,wRw,fRw)
set Lb=Lb-1
if WTw<=0 then
set ETw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set ZTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(ETw,wRw,fRw,ZTw)
call Qjw(wRw,fRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set UTw=LoadInteger(Rc,wRw,RRw)
set Lb=Lb-1
if UTw<=0 then
set ITw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set PTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(ITw,wRw,RRw,PTw)
call Qjw(wRw,RRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set ATw=LoadInteger(Rc,wRw,TRw)
set Lb=Lb-1
if ATw<=0 then
set DTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set HTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(DTw,wRw,TRw,HTw)
call Qjw(wRw,TRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set JTw=LoadInteger(Rc,wRw,YRw)
set Lb=Lb-1
if JTw<=0 then
set KTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set LTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(KTw,wRw,YRw,LTw)
call Qjw(wRw,YRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set XTw=LoadInteger(Rc,wRw,GRw)
set Lb=Lb-1
if XTw<=0 then
set CTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set VTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(CTw,wRw,GRw,VTw)
call Qjw(wRw,GRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set BTw=LoadInteger(Rc,wRw,gRw)
set Lb=Lb-1
if BTw<=0 then
set NTw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set MTw=eb[wRw]
set Lb=Lb-1
call SaveInteger(NTw,wRw,gRw,MTw)
call Qjw(wRw,gRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set wYw=LoadInteger(Rc,wRw,hRw)
set Lb=Lb-1
if wYw<=0 then
set uYw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set rYw=eb[wRw]
set Lb=Lb-1
call SaveInteger(uYw,wRw,hRw,rYw)
call Qjw(wRw,hRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set sYw=LoadInteger(Rc,wRw,FRw)
set Lb=Lb-1
if sYw<=0 then
set tYw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set iYw=eb[wRw]
set Lb=Lb-1
call SaveInteger(tYw,wRw,FRw,iYw)
call Qjw(wRw,FRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set SYw=LoadInteger(Rc,wRw,kRw)
set Lb=Lb-1
if SYw<=0 then
set cYw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set oYw=eb[wRw]
set Lb=Lb-1
call SaveInteger(cYw,wRw,kRw,oYw)
call Qjw(wRw,kRw,"when calling add in HashSet, line 13")
endif
set Xb[Lb]="when calling count in HashSet, line 11"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call I1("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set OYw=LoadInteger(Rc,wRw,jRw)
set Lb=Lb-1
if OYw<=0 then
set lYw=Tc
set Xb[Lb]="when calling size in HashSet, line 12"
set Lb=Lb+1
if IO[wRw]==0 then
if wRw==0 then
call I1("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call I1("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set bYw=eb[wRw]
set Lb=Lb-1
call SaveInteger(lYw,wRw,jRw,bYw)
call Qjw(wRw,jRw,"when calling add in HashSet, line 13")
endif
set Lb=Lb-1
set mRw=null
set ERw=null
set IRw=null
set DRw=null
set KRw=null
set CRw=null
set NRw=null
set uTw=null
set tTw=null
set cTw=null
set lTw=null
set pTw=null
set aTw=null
set fTw=null
set YTw=null
set hTw=null
set jTw=null
set mTw=null
set ETw=null
set ITw=null
set DTw=null
set KTw=null
set CTw=null
set NTw=null
set uYw=null
set tYw=null
set cYw=null
set lYw=null
endfunction
function KYw takes integer pYw,integer eYw,integer qYw,integer aYw,integer nYw,integer dYw,integer fYw,integer RYw,integer TYw,integer YYw,integer GYw,integer gYw,integer hYw,integer FYw,integer kYw,integer jYw,integer xYw,integer vYw,integer mYw,integer QYw,integer WYw,integer EYw,integer ZYw,integer UYw,integer IYw,integer PYw,integer AYw,integer DYw,integer HYw,string JYw returns nothing
set Xb[Lb]=JYw
set Lb=Lb+1
if IO[pYw]==0 then
if pYw==0 then
call I1("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call I1("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if IO[pYw]<=695 then
call Mfw(pYw,eYw,qYw,aYw,nYw,dYw,fYw,RYw,TYw,YYw,GYw,gYw,hYw,FYw,kYw,jYw,xYw,vYw,mYw,QYw,WYw,EYw,ZYw,UYw,IYw,PYw,AYw,DYw,HYw,"when calling add in HashList, line 25")
else
call yYw(pYw,eYw,qYw,aYw,nYw,dYw,fYw,RYw,TYw,YYw,GYw,gYw,hYw,FYw,kYw,jYw,xYw,vYw,mYw,QYw,WYw,EYw,ZYw,UYw,IYw,PYw,AYw,DYw,HYw,"when calling add in HashList, line 25")
endif
set Lb=Lb-1
endfunction
function a0w takes string b0w returns boolean
local integer y0w
local playerunitevent p0w
local integer e0w
local integer q0w
set Xb[Lb]=b0w
set Lb=Lb+1
set y0w=ulw("when calling new_HashList in RangeChecks, line 6")
call KYw(y0w,1747988557,1747990614,1747988789,1747989846,1747990103,1747990064,1747989075,1747990102,1747988785,1747989839,1747990101,1747989554,1747989041,1747990344,1747989059,1747989060,1747988844,1747990351,1747990352,1747990356,1747989331,1747990350,1747989809,1747990353,1747990354,1747990355,1747988568,1747990341,"when calling add in RangeChecks, line 6")
set yo=y0w
set p0w=EVENT_PLAYER_UNIT_CONSTRUCT_START
set Xb[Lb]="when calling alloc_RangeChecks_EventListener_line12 in RangeChecks, line 12"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set e0w=cO
set oO[e0w]=681
else
call I1("Out of memory: Could not create RangeChecks_EventListener_line12.","when calling error in RangeChecks, line 12")
set e0w=0
endif
else
set SO=SO-1
set e0w=iO[SO]
set oO[e0w]=681
endif
set Lb=Lb-1
set Ml[e0w]=0
set wb[e0w]=0
set ub[e0w]=0
set Xb[Lb]="when calling add in RangeChecks, line 12"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set q0w=QS[GetHandleId(p0w)]
if q0w==0 then
set q0w=QV(p0w,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[e0w]=q0w
if US[Ml[e0w]]!=0 then
set ub[US[Ml[e0w]]]=e0w
set wb[e0w]=US[Ml[e0w]]
endif
set US[Ml[e0w]]=e0w
set Lb=Lb-1-1
set p0w=null
return true
endfunction
function mxw takes nothing returns boolean
set Lb=0
return a0w("RangeChecks, line 1")
endfunction
function n0w takes nothing returns boolean
set po=-340282366920938000000000000000000000000.
return true
endfunction
function aE takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function nE takes nothing returns boolean
if not aE() then
return false
endif
return true
endfunction
function nH takes nothing returns nothing
local integer lH=1
local integer bH=1751277938
local player yH=GetOwningPlayer(GetConstructedStructure())
local rect aH=bj_mapInitialPlayableArea
local location qH=Location(GetRectCenterX(aH),GetRectCenterY(aH))
local location pH=Location(GetLocationX(qH)+100000000.00,GetLocationY(qH)+1000000000.00)
local real eH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set lH=lH-1
exitwhen lH<0
call CreateUnitAtLocSaveLast(yH,bH,pH,eH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set p[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]=true
set yH=null
set pH=null
set qH=null
set aH=null
endfunction
function nL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function nU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651846,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651847,0)
endfunction
function nW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989080,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988818,0)
endfunction
function nX takes nothing returns boolean
local integer qX=0
local integer aX=23
loop
exitwhen qX>aX
set iS[qX]=GetPlayerName(ro[qX])
set qX=qX+1
endloop
return true
endfunction
function aY takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989042 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function nY takes nothing returns boolean
if not aY() then
return false
endif
return true
endfunction
function nrw takes nothing returns boolean
call Location(0.,0.)
return true
endfunction
function nxw takes nothing returns boolean
local integer qxw
local integer axw
set Lb=0
set Xb[Lb]="VoteKick, line 1"
set Lb=Lb+1
set qxw=0
set axw=23
loop
exitwhen qxw>axw
set tO[qxw]=Clw("when calling new_HashSet in VoteKick, line 11")
set qxw=qxw+1
endloop
set Lb=Lb-1
return true
endfunction
function oF takes nothing returns nothing
local location Mh
local location wF
local real uF
local real rF
local rect sF
local group tF
local group iF
local code SF
local boolean cF
set u=GetUnitLoc(GetSpellAbilityUnit())
set Mh=u
set S=Location(GetLocationX(Mh)+0.00,GetLocationY(Mh)+200.00)
set wF=u
set uF=GetLocationX(wF)
set rF=GetLocationY(wF)
set o=Rect(uF-140,rF-150,uF+140,rF+150)
set sF=o
set tF=CreateGroup()
call GroupEnumUnitsInRect(tF,sF,null)
call DestroyBoolExpr(null)
set l=tF
set iF=l
set SF=Op
set cF=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(iF,SF)
if cF then
call DestroyGroup(iF)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990072,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(S)
call RemoveLocation(u)
set Mh=null
set wF=null
set sF=null
set tF=null
set iF=null
endfunction
function oI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989833,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989834,0)
endfunction
function cP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function oP takes nothing returns boolean
if not cP() then
return false
endif
return true
endfunction
function cZ takes nothing returns boolean
if GetResearched()!=1378889809 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889809,true)!=2 then
return false
endif
return true
endfunction
function oZ takes nothing returns boolean
if not cZ() then
return false
endif
return true
endfunction
function og takes nothing returns nothing
local location MG
local location wg
local real ug
local real rg
local rect sg
local group tg
local group ig
local code Sg
local boolean cg
set u=GetUnitLoc(GetSpellAbilityUnit())
set MG=u
set c=Location(GetLocationX(MG)+200.00,GetLocationY(MG)+0.00)
set wg=u
set ug=GetLocationX(wg)
set rg=GetLocationY(wg)
set O=Rect(ug-150,rg-140,ug+150,rg+140)
set sg=O
set tg=CreateGroup()
call GroupEnumUnitsInRect(tg,sg,null)
call DestroyBoolExpr(null)
set l=tg
set ig=l
set Sg=Jy
set cg=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(ig,Sg)
if cg then
call DestroyGroup(ig)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747990092,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set MG=null
set wg=null
set sg=null
set tg=null
set ig=null
endfunction
function oh takes nothing returns nothing
local location Mg
local location wh
local real uh
local real rh
local rect sh
local group th
local group ih
local code Sh
local boolean ch
set u=GetUnitLoc(GetSpellAbilityUnit())
set Mg=u
set c=Location(GetLocationX(Mg)+200.00,GetLocationY(Mg)+0.00)
set wh=u
set uh=GetLocationX(wh)
set rh=GetLocationY(wh)
set O=Rect(uh-150,rh-140,uh+150,rh+140)
set sh=O
set th=CreateGroup()
call GroupEnumUnitsInRect(th,sh,null)
call DestroyBoolExpr(null)
set l=th
set ih=l
set Sh=wp
set ch=bj_wantDestroyGroup
set bj_wantDestroyGroup=false
call ForGroup(ih,Sh)
if ch then
call DestroyGroup(ih)
endif
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747988826,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"stand")
call DestroyGroup(l)
call RemoveLocation(c)
call RemoveLocation(u)
set Mg=null
set wh=null
set sh=null
set th=null
set ih=null
endfunction
function ov takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747989049 then
return false
endif
return true
endfunction
function E8 takes string C5 returns boolean
local integer V5
local integer B5
local integer N5
local integer M5
local integer w6
local integer u6
local integer r6
local integer s6
local integer t6
local integer i6
local integer S6
local integer c6
local integer o6
local integer O6
local integer l6
local integer b6
local integer y6
local integer p6
local integer e6
local integer q6
local integer a6
local integer n6
local integer d6
local integer f6
local integer R6
local integer T6
local integer Y6
local integer G6
local integer g6
local integer h6
local integer F6
local integer k6
local integer j6
local integer x6
local integer v6
local integer m6
local integer Q6
local integer W6
local integer E6
local integer Z6
local integer U6
local integer I6
local integer P6
local integer A6
local integer D6
local integer H6
local integer J6
local integer K6
local integer L6
local integer X6
local integer C6
local integer V6
local integer B6
local integer N6
local integer M6
local integer w7
local integer u7
local integer r7
local integer s7
local integer t7
local integer i7
local integer S7
local integer c7
local integer o7
local integer O7
local integer l7
local integer b7
local integer y7
local integer p7
local integer e7
local integer q7
local integer a7
local integer n7
local integer d7
local integer f7
local integer R7
local integer T7
local integer Y7
local integer G7
local integer g7
local integer h7
local integer F7
local integer k7
local integer j7
local integer x7
local integer v7
local integer m7
local integer Q7
local integer W7
local integer E7
local integer Z7
local integer U7
local integer I7
local integer P7
local integer A7
local integer D7
local integer H7
local integer J7
local integer K7
local integer L7
local integer X7
local integer C7
local integer V7
local integer B7
local integer N7
local integer M7
local integer w8
local integer u8
local integer r8
local integer s8
local integer t8
local integer i8
local integer S8
local integer c8
local integer o8
local integer O8
local integer l8
local integer b8
local integer y8
local integer p8
local integer e8
local integer q8
local integer a8
local integer n8
local integer d8
local integer f8
local integer R8
local integer T8
local integer Y8
local integer G8
local integer g8
local integer h8
local integer F8
local integer k8
local integer j8
local integer x8
local integer v8
local integer m8
local integer Q8
local integer W8
set Xb[Lb]=C5
set Lb=Lb+1
set V5=R2I(70)
set B5=R2I(30)
set N5=R2I(10)
set M5=R2I(70)
set w6=R2I(30)
set u6=R2I(140)
set Xb[Lb]="when calling asList in Multiboards, line 23"
set Lb=Lb+1
set r6=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(r6,V5,"when calling add in LinkedList, line 393")
call ffw(r6,B5,"when calling add in LinkedList, line 393")
call ffw(r6,N5,"when calling add in LinkedList, line 393")
call ffw(r6,M5,"when calling add in LinkedList, line 393")
call ffw(r6,w6,"when calling add in LinkedList, line 393")
call ffw(r6,u6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[0]=r6
set s6=R2I(70)
set t6=R2I(30)
set i6=R2I(10)
set S6=R2I(70)
set c6=R2I(30)
set o6=R2I(140)
set Xb[Lb]="when calling asList in Multiboards, line 24"
set Lb=Lb+1
set O6=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(O6,s6,"when calling add in LinkedList, line 393")
call ffw(O6,t6,"when calling add in LinkedList, line 393")
call ffw(O6,i6,"when calling add in LinkedList, line 393")
call ffw(O6,S6,"when calling add in LinkedList, line 393")
call ffw(O6,c6,"when calling add in LinkedList, line 393")
call ffw(O6,o6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[1]=O6
set l6=R2I(70)
set b6=R2I(30)
set y6=R2I(10)
set p6=R2I(70)
set e6=R2I(30)
set q6=R2I(140)
set Xb[Lb]="when calling asList in Multiboards, line 25"
set Lb=Lb+1
set a6=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(a6,l6,"when calling add in LinkedList, line 393")
call ffw(a6,b6,"when calling add in LinkedList, line 393")
call ffw(a6,y6,"when calling add in LinkedList, line 393")
call ffw(a6,p6,"when calling add in LinkedList, line 393")
call ffw(a6,e6,"when calling add in LinkedList, line 393")
call ffw(a6,q6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[2]=a6
set n6=R2I(2.5)
set d6=R2I(2.5)
set f6=R2I(400)
set R6=R2I(2.5)
set T6=R2I(2.5)
set Y6=R2I(2.5)
set Xb[Lb]="when calling asList in Multiboards, line 27"
set Lb=Lb+1
set G6=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(G6,n6,"when calling add in LinkedList, line 393")
call ffw(G6,d6,"when calling add in LinkedList, line 393")
call ffw(G6,f6,"when calling add in LinkedList, line 393")
call ffw(G6,R6,"when calling add in LinkedList, line 393")
call ffw(G6,T6,"when calling add in LinkedList, line 393")
call ffw(G6,Y6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[3]=G6
set g6=R2I(70)
set h6=R2I(30)
set F6=R2I(30)
set k6=R2I(10)
set j6=R2I(126)
set x6=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 28"
set Lb=Lb+1
set v6=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(v6,g6,"when calling add in LinkedList, line 393")
call ffw(v6,h6,"when calling add in LinkedList, line 393")
call ffw(v6,F6,"when calling add in LinkedList, line 393")
call ffw(v6,k6,"when calling add in LinkedList, line 393")
call ffw(v6,j6,"when calling add in LinkedList, line 393")
call ffw(v6,x6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[4]=v6
set m6=R2I(70)
set Q6=R2I(30)
set W6=R2I(30)
set E6=R2I(10)
set Z6=R2I(126)
set U6=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 29"
set Lb=Lb+1
set I6=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(I6,m6,"when calling add in LinkedList, line 393")
call ffw(I6,Q6,"when calling add in LinkedList, line 393")
call ffw(I6,W6,"when calling add in LinkedList, line 393")
call ffw(I6,E6,"when calling add in LinkedList, line 393")
call ffw(I6,Z6,"when calling add in LinkedList, line 393")
call ffw(I6,U6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[5]=I6
set P6=R2I(70)
set A6=R2I(30)
set D6=R2I(30)
set H6=R2I(10)
set J6=R2I(126)
set K6=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 30"
set Lb=Lb+1
set L6=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(L6,P6,"when calling add in LinkedList, line 393")
call ffw(L6,A6,"when calling add in LinkedList, line 393")
call ffw(L6,D6,"when calling add in LinkedList, line 393")
call ffw(L6,H6,"when calling add in LinkedList, line 393")
call ffw(L6,J6,"when calling add in LinkedList, line 393")
call ffw(L6,K6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[6]=L6
set X6=R2I(70)
set C6=R2I(30)
set V6=R2I(30)
set B6=R2I(10)
set N6=R2I(126)
set M6=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 31"
set Lb=Lb+1
set w7=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(w7,X6,"when calling add in LinkedList, line 393")
call ffw(w7,C6,"when calling add in LinkedList, line 393")
call ffw(w7,V6,"when calling add in LinkedList, line 393")
call ffw(w7,B6,"when calling add in LinkedList, line 393")
call ffw(w7,N6,"when calling add in LinkedList, line 393")
call ffw(w7,M6,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[7]=w7
set u7=R2I(70)
set r7=R2I(30)
set s7=R2I(30)
set t7=R2I(10)
set i7=R2I(126)
set S7=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 32"
set Lb=Lb+1
set c7=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(c7,u7,"when calling add in LinkedList, line 393")
call ffw(c7,r7,"when calling add in LinkedList, line 393")
call ffw(c7,s7,"when calling add in LinkedList, line 393")
call ffw(c7,t7,"when calling add in LinkedList, line 393")
call ffw(c7,i7,"when calling add in LinkedList, line 393")
call ffw(c7,S7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[8]=c7
set o7=R2I(70)
set O7=R2I(30)
set l7=R2I(30)
set b7=R2I(10)
set y7=R2I(126)
set p7=R2I(84.000007629)
set Xb[Lb]="when calling asList in Multiboards, line 33"
set Lb=Lb+1
set e7=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(e7,o7,"when calling add in LinkedList, line 393")
call ffw(e7,O7,"when calling add in LinkedList, line 393")
call ffw(e7,l7,"when calling add in LinkedList, line 393")
call ffw(e7,b7,"when calling add in LinkedList, line 393")
call ffw(e7,y7,"when calling add in LinkedList, line 393")
call ffw(e7,p7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Ic[9]=e7
set Pc[0]=4
set Pc[1]=0
set Ac[0]=4
set Ac[1]=1
set Dc[0]=1
set Dc[1]=4
set Hc[0]=1
set Hc[1]=5
set Jc[0]=1
set Jc[1]=6
set Kc[0]=2
set Kc[1]=6
set Lc[0]=2
set Lc[1]=3
set q7=Rww("Food","when calling stringToIndex in Multiboards, line 56")
set a7=Rww("0","when calling stringToIndex in Multiboards, line 56")
set n7=Rww("|","when calling stringToIndex in Multiboards, line 56")
set d7=Rww("Income","when calling stringToIndex in Multiboards, line 56")
set f7=Rww("0","when calling stringToIndex in Multiboards, line 56")
set R7=Rww(" ","when calling stringToIndex in Multiboards, line 56")
set Xb[Lb]="when calling asList in Multiboards, line 56"
set Lb=Lb+1
set T7=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(T7,q7,"when calling add in LinkedList, line 393")
call ffw(T7,a7,"when calling add in LinkedList, line 393")
call ffw(T7,n7,"when calling add in LinkedList, line 393")
call ffw(T7,d7,"when calling add in LinkedList, line 393")
call ffw(T7,f7,"when calling add in LinkedList, line 393")
call ffw(T7,R7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[0]=T7
set Y7=Rww("Iron","when calling stringToIndex in Multiboards, line 57")
set G7=Rww("0","when calling stringToIndex in Multiboards, line 57")
set g7=Rww("|","when calling stringToIndex in Multiboards, line 57")
set h7=Rww("Upkeep","when calling stringToIndex in Multiboards, line 57")
set F7=Rww("0","when calling stringToIndex in Multiboards, line 57")
set k7=Rww(" ","when calling stringToIndex in Multiboards, line 57")
set Xb[Lb]="when calling asList in Multiboards, line 57"
set Lb=Lb+1
set j7=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(j7,Y7,"when calling add in LinkedList, line 393")
call ffw(j7,G7,"when calling add in LinkedList, line 393")
call ffw(j7,g7,"when calling add in LinkedList, line 393")
call ffw(j7,h7,"when calling add in LinkedList, line 393")
call ffw(j7,F7,"when calling add in LinkedList, line 393")
call ffw(j7,k7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[1]=j7
set x7=Rww("Stone","when calling stringToIndex in Multiboards, line 58")
set v7=Rww("0","when calling stringToIndex in Multiboards, line 58")
set m7=Rww("|","when calling stringToIndex in Multiboards, line 58")
set Q7=Rww(" ","when calling stringToIndex in Multiboards, line 58")
set W7=Rww(" ","when calling stringToIndex in Multiboards, line 58")
set E7=Rww(" ","when calling stringToIndex in Multiboards, line 58")
set Xb[Lb]="when calling asList in Multiboards, line 58"
set Lb=Lb+1
set Z7=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(Z7,x7,"when calling add in LinkedList, line 393")
call ffw(Z7,v7,"when calling add in LinkedList, line 393")
call ffw(Z7,m7,"when calling add in LinkedList, line 393")
call ffw(Z7,Q7,"when calling add in LinkedList, line 393")
call ffw(Z7,W7,"when calling add in LinkedList, line 393")
call ffw(Z7,E7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[2]=Z7
set U7=Rww(" ","when calling stringToIndex in Multiboards, line 60")
set I7=Rww(" ","when calling stringToIndex in Multiboards, line 60")
set P7=Rww("                           City info","when calling stringToIndex in Multiboards, line 60")
set A7=Rww(" ","when calling stringToIndex in Multiboards, line 60")
set D7=Rww(" ","when calling stringToIndex in Multiboards, line 60")
set H7=Rww(" ","when calling stringToIndex in Multiboards, line 60")
set Xb[Lb]="when calling asList in Multiboards, line 60"
set Lb=Lb+1
set J7=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(J7,U7,"when calling add in LinkedList, line 393")
call ffw(J7,I7,"when calling add in LinkedList, line 393")
call ffw(J7,P7,"when calling add in LinkedList, line 393")
call ffw(J7,A7,"when calling add in LinkedList, line 393")
call ffw(J7,D7,"when calling add in LinkedList, line 393")
call ffw(J7,H7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[3]=J7
set K7=Rww("Tax","when calling stringToIndex in Multiboards, line 61")
set L7=Rww("0","when calling stringToIndex in Multiboards, line 61")
set X7=Rww(" ","when calling stringToIndex in Multiboards, line 61")
set C7=Rww("|","when calling stringToIndex in Multiboards, line 61")
set V7=Rww(" ","when calling stringToIndex in Multiboards, line 61")
set B7=Rww(" ","when calling stringToIndex in Multiboards, line 61")
set Xb[Lb]="when calling asList in Multiboards, line 61"
set Lb=Lb+1
set N7=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(N7,K7,"when calling add in LinkedList, line 393")
call ffw(N7,L7,"when calling add in LinkedList, line 393")
call ffw(N7,X7,"when calling add in LinkedList, line 393")
call ffw(N7,C7,"when calling add in LinkedList, line 393")
call ffw(N7,V7,"when calling add in LinkedList, line 393")
call ffw(N7,B7,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[4]=N7
set M7=Rww("Public order","when calling stringToIndex in Multiboards, line 62")
set w8=Rww("0","when calling stringToIndex in Multiboards, line 62")
set u8=Rww(" ","when calling stringToIndex in Multiboards, line 62")
set r8=Rww("|","when calling stringToIndex in Multiboards, line 62")
set s8=Rww(" ","when calling stringToIndex in Multiboards, line 62")
set t8=Rww(" ","when calling stringToIndex in Multiboards, line 62")
set Xb[Lb]="when calling asList in Multiboards, line 62"
set Lb=Lb+1
set i8=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(i8,M7,"when calling add in LinkedList, line 393")
call ffw(i8,w8,"when calling add in LinkedList, line 393")
call ffw(i8,u8,"when calling add in LinkedList, line 393")
call ffw(i8,r8,"when calling add in LinkedList, line 393")
call ffw(i8,s8,"when calling add in LinkedList, line 393")
call ffw(i8,t8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[5]=i8
set S8=Rww("Population","when calling stringToIndex in Multiboards, line 63")
set c8=Rww("0","when calling stringToIndex in Multiboards, line 63")
set o8=Rww(" ","when calling stringToIndex in Multiboards, line 63")
set O8=Rww("|","when calling stringToIndex in Multiboards, line 63")
set l8=Rww(" ","when calling stringToIndex in Multiboards, line 63")
set b8=Rww(" ","when calling stringToIndex in Multiboards, line 63")
set Xb[Lb]="when calling asList in Multiboards, line 63"
set Lb=Lb+1
set y8=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(y8,S8,"when calling add in LinkedList, line 393")
call ffw(y8,c8,"when calling add in LinkedList, line 393")
call ffw(y8,o8,"when calling add in LinkedList, line 393")
call ffw(y8,O8,"when calling add in LinkedList, line 393")
call ffw(y8,l8,"when calling add in LinkedList, line 393")
call ffw(y8,b8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[6]=y8
set p8=Rww(" ","when calling stringToIndex in Multiboards, line 64")
set e8=Rww(" ","when calling stringToIndex in Multiboards, line 64")
set q8=Rww(" ","when calling stringToIndex in Multiboards, line 64")
set a8=Rww("|","when calling stringToIndex in Multiboards, line 64")
set n8=Rww(" ","when calling stringToIndex in Multiboards, line 64")
set d8=Rww(" ","when calling stringToIndex in Multiboards, line 64")
set Xb[Lb]="when calling asList in Multiboards, line 64"
set Lb=Lb+1
set f8=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(f8,p8,"when calling add in LinkedList, line 393")
call ffw(f8,e8,"when calling add in LinkedList, line 393")
call ffw(f8,q8,"when calling add in LinkedList, line 393")
call ffw(f8,a8,"when calling add in LinkedList, line 393")
call ffw(f8,n8,"when calling add in LinkedList, line 393")
call ffw(f8,d8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[7]=f8
set R8=Rww(" ","when calling stringToIndex in Multiboards, line 65")
set T8=Rww(" ","when calling stringToIndex in Multiboards, line 65")
set Y8=Rww(" ","when calling stringToIndex in Multiboards, line 65")
set G8=Rww("|","when calling stringToIndex in Multiboards, line 65")
set g8=Rww(" ","when calling stringToIndex in Multiboards, line 65")
set h8=Rww(" ","when calling stringToIndex in Multiboards, line 65")
set Xb[Lb]="when calling asList in Multiboards, line 65"
set Lb=Lb+1
set F8=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(F8,R8,"when calling add in LinkedList, line 393")
call ffw(F8,T8,"when calling add in LinkedList, line 393")
call ffw(F8,Y8,"when calling add in LinkedList, line 393")
call ffw(F8,G8,"when calling add in LinkedList, line 393")
call ffw(F8,g8,"when calling add in LinkedList, line 393")
call ffw(F8,h8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[8]=F8
set k8=Rww(" ","when calling stringToIndex in Multiboards, line 66")
set j8=Rww(" ","when calling stringToIndex in Multiboards, line 66")
set x8=Rww(" ","when calling stringToIndex in Multiboards, line 66")
set v8=Rww("|","when calling stringToIndex in Multiboards, line 66")
set m8=Rww(" ","when calling stringToIndex in Multiboards, line 66")
set Q8=Rww(" ","when calling stringToIndex in Multiboards, line 66")
set Xb[Lb]="when calling asList in Multiboards, line 66"
set Lb=Lb+1
set W8=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(W8,k8,"when calling add in LinkedList, line 393")
call ffw(W8,j8,"when calling add in LinkedList, line 393")
call ffw(W8,x8,"when calling add in LinkedList, line 393")
call ffw(W8,v8,"when calling add in LinkedList, line 393")
call ffw(W8,m8,"when calling add in LinkedList, line 393")
call ffw(W8,Q8,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set Xc[9]=W8
set Lb=Lb-1
return true
endfunction
function oxw takes nothing returns boolean
set Lb=0
return E8("Multiboards, line 1")
endfunction
function p4 takes nothing returns boolean
return true
endfunction
function p9 takes nothing returns boolean
return true
endfunction
function yA takes nothing returns boolean
if GetResearched()!=1378890053 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890053,true)!=2 then
return false
endif
return true
endfunction
function pA takes nothing returns boolean
if not yA() then
return false
endif
return true
endfunction
function yJ takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989325 then
return false
endif
return true
endfunction
function pJ takes nothing returns boolean
if not yJ() then
return false
endif
return true
endfunction
function pX takes nothing returns boolean
return true
endfunction
function pg takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989046 then
return false
endif
return true
endfunction
function ph takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990073 then
return false
endif
return true
endfunction
function ym takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function pm takes nothing returns boolean
if not ym() then
return false
endif
return true
endfunction
function ttw takes string Lsw,string Xsw,real Csw,real Vsw,real Bsw,integer Nsw,real Msw,real wtw,boolean utw,string rtw returns integer
local integer stw
set Xb[Lb]=rtw
set Lb=Lb+1
set Xb[Lb]="when calling alloc_CityModifierClass in CityModifiers, line 37"
set Lb=Lb+1
if lO==0 then
if bO<32768 then
set bO=bO+1
set stw=bO
else
call I1("Out of memory: Could not create CityModifierClass.","when calling error in CityModifiers, line 26")
set stw=0
endif
else
set lO=lO-1
set stw=OO[lO]
endif
set Lb=Lb-1
set dl[stw]=Csw
set fl[stw]=wtw
set Rl[stw]=utw
set Tl[stw]=Vsw
set Yl[stw]=Nsw
set Gl[stw]=Msw
set gl[stw]=Bsw
set hl[stw]=Lsw
set Fl[stw]=Xsw
set Lb=Lb-1
return stw
endfunction
function XC takes string mC returns boolean
local integer QC
local integer WC
local integer EC
local integer ZC
local integer UC
local integer IC
local integer PC
local integer AC
local integer DC
local integer HC
local integer JC
local integer KC
local integer LC
set Xb[Lb]=mC
set Lb=Lb+1
set WC=R2I(0.5)
set EC=R2I(1)
set Xb[Lb]="when calling asList in CityModifiers, line 7"
set Lb=Lb+1
set ZC=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(ZC,WC,"when calling add in LinkedList, line 393")
call ffw(ZC,EC,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set oS[0]=ZC
set UC=R2I(1)
set IC=R2I(3)
set Xb[Lb]="when calling asList in CityModifiers, line 8"
set Lb=Lb+1
set PC=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(PC,UC,"when calling add in LinkedList, line 393")
call ffw(PC,IC,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set oS[1]=PC
set AC=R2I(3)
set DC=R2I(10)
set Xb[Lb]="when calling asList in CityModifiers, line 9"
set Lb=Lb+1
set HC=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(HC,AC,"when calling add in LinkedList, line 393")
call ffw(HC,DC,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set oS[2]=HC
set JC=R2I(10)
set KC=R2I(20)
set Xb[Lb]="when calling asList in CityModifiers, line 10"
set Lb=Lb+1
set LC=Zbw("when calling new_LinkedList in LinkedList, line 391")
call ffw(LC,JC,"when calling add in LinkedList, line 393")
call ffw(LC,KC,"when calling add in LinkedList, line 393")
set Lb=Lb-1
set oS[3]=LC
set OS=ttw("|cffff0000Just conquered|r","|cffc00000-PO -pop|r",240,1.0,0.0,1,-1.0,-30.0,false,"when calling new_CityModifierClass in CityModifiers, line 68")
set lS=ttw("|cfffffb00Just revolted|r","|cff00af00+PO|r|cffc00000 -pop|r",120.0,1.0,0.0,0,0.,30.0,false,"when calling new_CityModifierClass in CityModifiers, line 76")
set bS=ttw("|cff33ff00Population Boom|r","|cff33ff00++pop|r",120.0,0.01,0.,0,0.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 84")
set yS=ttw("|cffff0000Plague outburst|r","|cffff0000--pop|r",240,0.03,0.,2,-1.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 92")
set pS=ttw("|cffaf0000Big Fire|r","|cffc00000-pop|r",30,0.01,0.,2,-1.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 100")
set eS=ttw("|cff15ff00More trade estabilished|r","|cff00af00+tax +pop|r",240,0.01,0.15,0,1.,0.,true,"when calling new_CityModifierClass in CityModifiers, line 108")
set qS=ttw("|cffff0000Massacred population|r","|cff00af00+PO |r|cffff0000--pop|r",30,0.05,0.,3,-1.,10.,true,"when calling new_CityModifierClass in CityModifiers, line 116")
set aS=ttw("|cff00ff00Prospering|r","|cff00af00+PO +pop +tax|r",240,0.01,0.10,1,1.,20.0,true,"when calling new_CityModifierClass in CityModifiers, line 124")
set nS=ttw("|cffff0000Sieged|r","|cffc00000-PO -pop|r",5,1.0,0.,0,-1.,-10.0,true,"when calling new_CityModifierClass in CityModifiers, line 132")
set dS=plw("when calling new_HashMap in CityModifiers, line 142")
set QC=dS
call Mnw(QC,0,OS,"when calling put in CityModifiers, line 149")
call Mnw(QC,1,lS,"when calling put in CityModifiers, line 150")
call Mnw(QC,2,bS,"when calling put in CityModifiers, line 151")
call Mnw(QC,3,yS,"when calling put in CityModifiers, line 152")
call Mnw(QC,4,pS,"when calling put in CityModifiers, line 153")
call Mnw(QC,5,eS,"when calling put in CityModifiers, line 154")
call Mnw(QC,6,qS,"when calling put in CityModifiers, line 155")
call Mnw(QC,7,aS,"when calling put in CityModifiers, line 156")
call Mnw(QC,8,nS,"when calling put in CityModifiers, line 157")
set Lb=Lb-1
return true
endfunction
function pxw takes nothing returns boolean
set Lb=0
return XC("CityModifiers, line 1")
endfunction
function eF takes nothing returns boolean
local unitstate pF=UNIT_STATE_MANA
if GetUnitState(GetEnumUnit(),pF)>0.00 then
set pF=null
return false
endif
set pF=null
return true
endfunction
function qF takes nothing returns nothing
if eF() then
call KillUnit(GetEnumUnit())
endif
endfunction
function qI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989832,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989833,0)
endfunction
function eP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function qP takes nothing returns boolean
if not eP() then
return false
endif
return true
endfunction
function eZ takes nothing returns boolean
if GetResearched()!=1378889811 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889811,true)!=1 then
return false
endif
return true
endfunction
function qZ takes nothing returns boolean
if not eZ() then
return false
endif
return true
endfunction
function eg takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function qg takes nothing returns nothing
if eg() then
call SetUnitPositionLoc(GetEnumUnit(),S)
endif
endfunction
function eh takes nothing returns boolean
if IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)!=false then
return false
endif
return true
endfunction
function qh takes nothing returns nothing
if eh() then
call SetUnitPositionLoc(GetEnumUnit(),c)
endif
endfunction
function qj takes nothing returns nothing
local player tj=GetOwningPlayer(GetKillingUnit())
local playerstate ij=PLAYER_STATE_RESOURCE_LUMBER
local playerstate Sj
local playerstate cj
local player oj
local force Oj
local location lj
local real bj
local real yj
local player pj
local force ej
if ij==PLAYER_STATE_RESOURCE_GOLD then
set Sj=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(tj,Sj,GetPlayerState(tj,Sj)+125)
elseif ij==PLAYER_STATE_RESOURCE_LUMBER then
set cj=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(tj,cj,GetPlayerState(tj,cj)+125)
endif
call SetPlayerState(tj,ij,GetPlayerState(tj,ij)+125)
set oj=GetOwningPlayer(GetKillingUnit())
set Oj=CreateForce()
call ForceAddPlayer(Oj,oj)
if IsPlayerInForce(GetLocalPlayer(),Oj) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_089")
endif
set y=GetUnitLoc(GetDyingUnit())
set pj=GetOwningPlayer(GetDyingUnit())
set ej=CreateForce()
call ForceAddPlayer(ej,pj)
set lj=y
set bj=GetLocationX(lj)
set yj=GetLocationY(lj)
if IsPlayerInForce(GetLocalPlayer(),ej) then
call PingMinimap(bj,yj,2.00)
endif
call RemoveLocation(y)
set tj=null
set ij=null
set Sj=null
set cj=null
set oj=null
set Oj=null
set lj=null
set pj=null
set ej=null
endfunction
function qx takes nothing returns nothing
local player tx=GetOwningPlayer(GetKillingUnit())
local playerstate ix=PLAYER_STATE_RESOURCE_GOLD
local playerstate Sx
local playerstate cx
local player ox
local force Ox
local location lx
local real bx
local real yx
local player px
local force ex
if ix==PLAYER_STATE_RESOURCE_GOLD then
set Sx=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(tx,Sx,GetPlayerState(tx,Sx)+250)
elseif ix==PLAYER_STATE_RESOURCE_LUMBER then
set cx=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(tx,cx,GetPlayerState(tx,cx)+250)
endif
call SetPlayerState(tx,ix,GetPlayerState(tx,ix)+250)
set ox=GetOwningPlayer(GetKillingUnit())
set Ox=CreateForce()
call ForceAddPlayer(Ox,ox)
if IsPlayerInForce(GetLocalPlayer(),Ox) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_092")
endif
set y=GetUnitLoc(GetDyingUnit())
set px=GetOwningPlayer(GetDyingUnit())
set ex=CreateForce()
call ForceAddPlayer(ex,px)
set lx=y
set bx=GetLocationX(lx)
set yx=GetLocationY(lx)
if IsPlayerInForce(GetLocalPlayer(),ex) then
call PingMinimap(bx,yx,2.00)
endif
call RemoveLocation(y)
set tx=null
set ix=null
set Sx=null
set cx=null
set ox=null
set Ox=null
set lx=null
set px=null
set ex=null
endfunction
function uL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988530 then
return false
endif
return true
endfunction
function rL takes nothing returns boolean
if not uL() then
return false
endif
return true
endfunction
function rP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990324,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990325,0)
endfunction
function uU takes nothing returns boolean
if GetResearched()!=1378889818 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889818,true)!=1 then
return false
endif
return true
endfunction
function rU takes nothing returns boolean
if not uU() then
return false
endif
return true
endfunction
function uW takes nothing returns boolean
if GetResearched()!=1378889801 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889801,true)!=2 then
return false
endif
return true
endfunction
function rW takes nothing returns boolean
if not uW() then
return false
endif
return true
endfunction
function rZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651841,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651831,0)
endfunction
function rsw takes nothing returns boolean
return true
endfunction
function rv takes nothing returns nothing
local player Jx=GetOwningPlayer(GetSpellTargetUnit())
local playerstate Kx=PLAYER_STATE_RESOURCE_GOLD
local playerstate Lx
local playerstate Xx
local player Cx
local force Vx
local location Bx
local real Nx
local real Mx
local player wv
local force uv
if Kx==PLAYER_STATE_RESOURCE_GOLD then
set Lx=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(Jx,Lx,GetPlayerState(Jx,Lx)+500)
elseif Kx==PLAYER_STATE_RESOURCE_LUMBER then
set Xx=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(Jx,Xx,GetPlayerState(Jx,Xx)+500)
endif
call SetPlayerState(Jx,Kx,GetPlayerState(Jx,Kx)+500)
call RemoveUnit(GetSpellAbilityUnit())
set Cx=GetOwningPlayer(GetSpellTargetUnit())
set Vx=CreateForce()
call ForceAddPlayer(Vx,Cx)
if IsPlayerInForce(GetLocalPlayer(),Vx) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1234")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set wv=GetOwningPlayer(GetSpellTargetUnit())
set uv=CreateForce()
call ForceAddPlayer(uv,wv)
set Bx=y
set Nx=GetLocationX(Bx)
set Mx=GetLocationY(Bx)
if IsPlayerInForce(GetLocalPlayer(),uv) then
call PingMinimap(Nx,Mx,2.00)
endif
call RemoveLocation(y)
set Jx=null
set Kx=null
set Lx=null
set Xx=null
set Cx=null
set Vx=null
set Bx=null
set wv=null
set uv=null
endfunction
function rww takes timer Bww_2,string Nww returns integer
local integer Mww
local integer www
local integer uww
set Xb[Lb]=Nww
set Lb=Lb+1
set Mww=Po
set www=GetHandleId(Bww_2)
set Xb[Lb]="when calling loadInt in TimerUtils, line 21"
set Lb=Lb+1
if HO[Mww]==0 then
if Mww==0 then
call I1("Nullpointer exception when calling Table.loadInt","when calling error in Table, line 39")
else
call I1("Called Table.loadInt on invalid object.","when calling error in Table, line 39")
endif
endif
set uww=LoadInteger(Zo,Mww,www)
set Lb=Lb-1-1
return uww
endfunction
function Jow takes integer vow,integer mow,string Qow returns nothing
local integer Wow
local multiboard Eow
local integer Zow
local boolean Uow
local integer Iow
local integer Aow
local string Dow
local integer How
set Xb[Lb]=Qow
set Lb=Lb+1
set Wow=0
set mow=23
loop
exitwhen Wow>mow
set Zow=uo[Wow]
set Qow="when calling isInGame in Economy, line 49"
set Xb[Lb]="when calling isInGame in Economy, line 49"
set Lb=Lb+1
if ll[Zow]==0 then
if Zow==0 then
call I1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call I1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set Uow=Pb[Zow]
set Lb=Lb-1
if Uow then
set Eow=Cc[Wow]
set Iow=Ac[0]
set Aow=Ac[1]
set vow=uo[Wow]
set Xb[Lb]="when calling getUpkeep in Economy, line 51"
set Lb=Lb+1
if ll[vow]==0 then
if vow==0 then
call I1("Nullpointer exception when calling PlayerStats.getUpkeep","when calling error in PlayerStats, line 48")
else
call I1("Called PlayerStats.getUpkeep on invalid object.","when calling error in PlayerStats, line 48")
endif
endif
set How=Db[vow]
set Lb=Lb-1
set Dow=jww(How)
call MultiboardSetItemValue(MultiboardGetItem(Eow,Aow,Iow),Dow)
endif
set Wow=Wow+1
endloop
set Lb=Lb-1
set Eow=null
endfunction
function Sow takes integer sow,integer tow returns nothing
local integer iow
set cb[sow]=cb[sow]-1.
set iow=0
set tow=23
loop
exitwhen iow>tow
call MultiboardSetTitleText(Cc[iow],"Income: "+I2S(R2I(cb[sow]/60.))+":"+I2S(R2I(ModuloReal(cb[sow],60.)/10.))+I2S(R2I(ModuloReal(ModuloReal(cb[sow],60.),10.))))
set iow=iow+1
endloop
if cb[sow]<=0. then
set cb[sow]=120.0
endif
endfunction
function h1 takes string e1 returns nothing
local integer q1
local integer a1
local integer n1
local integer d1
local integer f1
local real R1
local integer T1
local integer Y1
local integer G1
local integer g1
set Xb[Lb]=e1
set Lb=Lb+1
set q1=0
set a1=23
loop
exitwhen q1>a1
set sc[q1]=ic[q1]
set tc[q1]=0
set q1=q1+1
endloop
set n1=R2I(fS*0.5/10.0)+1
set d1=0
set f1=R2I(20)-1
loop
exitwhen d1>f1
set R1=d1*0.5
set Xb[Lb]="when calling alloc_Economy_CallbackSingle_line34 in Economy, line 34"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set T1=YO
set GO[T1]=644
else
call I1("Out of memory: Could not create Economy_CallbackSingle_line34.","when calling error in Economy, line 34")
set T1=0
endif
else
set TO=TO-1
set T1=RO[TO]
set GO[T1]=644
endif
set Lb=Lb-1
set lb[T1]=d1
set bb[T1]=n1
set e1="when calling doAfter in Economy, line 34"
set Xb[Lb]="when calling doAfter in Economy, line 34"
set Lb=Lb+1
call jB(iww("when calling getTimer in ClosureTimers, line 27"),R1,T1,"when calling doAfter in ClosureTimers, line 27")
set Lb=Lb-1
set Y1=fS-1
set G1=(d1+1)*n1-1
if Y1<2147483647 then
set g1=Y1
else
set g1=2147483647
endif
if G1<g1 then
set g1=G1
endif
exitwhen g1==fS-1
set d1=d1+1
endloop
set Lb=Lb-1
endfunction
function aOw takes integer Kow,integer Low,string Xow returns nothing
local integer Cow
local integer Vow
local multiboard Bow
local integer Now
local integer Mow
local integer wOw
local integer uOw
local integer rOw
local boolean sOw
local integer tOw
local integer iOw
local integer SOw
local string cOw
local integer oOw
local integer OOw
local boolean lOw
local integer bOw
local integer yOw
local integer pOw
local player eOw
local playerstate qOw
set Xb[Lb]=Xow
set Lb=Lb+1
set Sc=Sc+1
set Cow=0
set Vow=23
loop
exitwhen Cow>Vow
set rOw=uo[Cow]
set Xb[Lb]="when calling isInGame in Economy, line 57"
set Lb=Lb+1
if ll[rOw]==0 then
if rOw==0 then
call I1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call I1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set sOw=Pb[rOw]
set Lb=Lb-1
if sOw then
set Bow=Cc[Cow]
set tOw=Pc[0]
set Kow=Pc[1]
set Xow=jww(sc[Cow])
call MultiboardSetItemValue(MultiboardGetItem(Bow,Kow,tOw),Xow)
set iOw=Ac[0]
set SOw=Ac[1]
set Low=uo[Cow]
set Xb[Lb]="when calling getUpkeep in Economy, line 60"
set Lb=Lb+1
if ll[Low]==0 then
if Low==0 then
call I1("Nullpointer exception when calling PlayerStats.getUpkeep","when calling error in PlayerStats, line 48")
else
call I1("Called PlayerStats.getUpkeep on invalid object.","when calling error in PlayerStats, line 48")
endif
endif
set oOw=Db[Low]
set Lb=Lb-1
set cOw=jww(oOw)
call MultiboardSetItemValue(MultiboardGetItem(Bow,SOw,iOw),cOw)
endif
set Cow=Cow+1
endloop
if Sc==R2I(12) then
set Sc=0
set Now=0
set Mow=23
loop
exitwhen Now>Mow
set OOw=uo[Now]
set Xb[Lb]="when calling isInGame in Economy, line 65"
set Lb=Lb+1
if ll[OOw]==0 then
if OOw==0 then
call I1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call I1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set lOw=Pb[OOw]
set Lb=Lb-1
if lOw then
set wOw=GetPlayerState(ro[Now],PLAYER_STATE_RESOURCE_GOLD)
set uOw=GetPlayerState(ro[Now],PLAYER_STATE_RESOURCE_LUMBER)
set eOw=ro[Now]
set qOw=PLAYER_STATE_RESOURCE_GOLD
set pOw=wOw+sc[Now]
set bOw=uo[Now]
set Xb[Lb]="when calling getUpkeep in Economy, line 68"
set Lb=Lb+1
if ll[bOw]==0 then
if bOw==0 then
call I1("Nullpointer exception when calling PlayerStats.getUpkeep","when calling error in PlayerStats, line 48")
else
call I1("Called PlayerStats.getUpkeep on invalid object.","when calling error in PlayerStats, line 48")
endif
endif
set yOw=Db[bOw]
set Lb=Lb-1
call SetPlayerState(eOw,qOw,pOw+yOw)
call SetPlayerState(ro[Now],PLAYER_STATE_RESOURCE_LUMBER,uOw+tc[Now])
endif
set Now=Now+1
endloop
endif
call h1("when calling countIncomeForAll in Economy, line 71")
set Lb=Lb-1
set Bow=null
set eOw=null
set qOw=null
endfunction
function kcw takes integer bcw,integer ycw,string pcw returns nothing
local integer ecw
local real qcw
local integer acw
local real ncw
local integer dcw
local real fcw
local integer Rcw
local real Tcw
local integer Ycw
local real Gcw
local integer gcw
local integer hcw
local integer Fcw
set Xb[Lb]=pcw
set Lb=Lb+1
set qcw=Tl[tdw(dS,2,"when calling get in City, line 155")]
if GetRandomReal(0.0,1.0)<=qcw then
set acw=Nl[bcw]
set Xb[Lb]="when calling addModifier in City, line 156"
set Lb=Lb+1
if qO[acw]==0 then
if acw==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(acw,2,"when calling addModifier in City, line 365")
set Lb=Lb-1
endif
set ncw=Tl[tdw(dS,5,"when calling get in City, line 157")]
if GetRandomReal(0.0,1.0)<=ncw then
set dcw=Nl[bcw]
set Xb[Lb]="when calling addModifier in City, line 158"
set Lb=Lb+1
if qO[dcw]==0 then
if dcw==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(dcw,5,"when calling addModifier in City, line 365")
set Lb=Lb-1
endif
set fcw=Tl[tdw(dS,7,"when calling get in City, line 159")]
if GetRandomReal(0.0,1.0)<=fcw then
set Rcw=Nl[bcw]
set Xb[Lb]="when calling addModifier in City, line 160"
set Lb=Lb+1
if qO[Rcw]==0 then
if Rcw==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(Rcw,7,"when calling addModifier in City, line 365")
set Lb=Lb-1
endif
set Tcw=Tl[tdw(dS,3,"when calling get in City, line 161")]
if GetRandomReal(0.0,1.0)<=Tcw then
set Ycw=Nl[bcw]
set Xb[Lb]="when calling addModifier in City, line 162"
set Lb=Lb+1
if qO[Ycw]==0 then
if Ycw==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(Ycw,3,"when calling addModifier in City, line 365")
set Lb=Lb-1
endif
set Gcw=Tl[tdw(dS,4,"when calling get in City, line 163")]
if GetRandomReal(0.0,1.0)<=Gcw then
set gcw=Nl[bcw]
set Xb[Lb]="when calling addModifier in City, line 164"
set Lb=Lb+1
if qO[gcw]==0 then
if gcw==0 then
call I1("Nullpointer exception when calling City.addModifier","when calling error in City, line 365")
else
call I1("Called City.addModifier on invalid object.","when calling error in City, line 365")
endif
endif
call ytw(gcw,4,"when calling addModifier in City, line 365")
set Lb=Lb-1
endif
set hcw=Jl[Nl[bcw]]
set Xb[Lb]="when calling iterator in City, line 166"
set Lb=Lb+1
set ycw=dbw(hcw,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set ecw=ycw
loop
exitwhen Tb[Gb[ecw]]==Yb[ecw]
set Gb[ecw]=Tb[Gb[ecw]]
set Fcw=Nl[bcw]
set Xb[Lb]="when calling getCityModifierOnLongCount in City, line 167"
set Lb=Lb+1
if qO[Fcw]==0 then
if Fcw==0 then
call I1("Nullpointer exception when calling City.getCityModifierOnLongCount","when calling error in City, line 411")
else
call I1("Called City.getCityModifierOnLongCount on invalid object.","when calling error in City, line 411")
endif
endif
set Lb=Lb-1
endloop
set Xb[Lb]="when calling close in City, line 166"
set Lb=Lb+1
if hb[ecw]then
call edw(ecw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1-1
endfunction
function kyw takes integer Tyw,integer Yyw,string Gyw returns nothing
local integer gyw
local boolean hyw
local integer Fyw
set Xb[Lb]=Gyw
set Lb=Lb+1
set Yyw=0
set gyw=23
loop
exitwhen Yyw>gyw
set Tyw=uo[Yyw]
set Xb[Lb]="when calling isInGame in MultiboardCityUpdate, line 27"
set Lb=Lb+1
if ll[Tyw]==0 then
if Tyw==0 then
call I1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call I1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set hyw=Pb[Tyw]
set Lb=Lb-1
if hyw then
set Fyw=uo[Yyw]
set Gyw="when calling refreshMultiboardCity in MultiboardCityUpdate, line 28"
set Xb[Lb]="when calling refreshMultiboardCity in MultiboardCityUpdate, line 28"
set Lb=Lb+1
if ll[Fyw]==0 then
if Fyw==0 then
call I1("Nullpointer exception when calling PlayerStats.refreshMultiboardCity","when calling error in PlayerStats, line 71")
else
call I1("Called PlayerStats.refreshMultiboardCity on invalid object.","when calling error in PlayerStats, line 71")
endif
endif
call oew(Fyw,"when calling refreshMultiboardCity in PlayerStats, line 71")
set Lb=Lb-1
endif
set Yyw=Yyw+1
endloop
set Lb=Lb-1
endfunction
function Ciw takes integer Aiw,integer Diw,real Hiw,string Jiw returns nothing
local integer Kiw
local real Liw
local integer Xiw
set Xb[Lb]=Jiw
set Lb=Lb+1
set Kiw=El[Aiw]
set Xiw=El[Aiw]
set Liw=Hiw*GetRandomReal(kdw(oS[Diw],0,"when calling get in City, line 398")/1000.,kdw(oS[Diw],1,"when calling get in City, line 398")/1000.)*El[Aiw]
set El[Aiw]=Xiw+R2I(Liw)
set Zl[Aiw]=Zl[Aiw]+(El[Aiw]-Kiw)
set Lb=Lb-1
endfunction
function uSw takes integer Viw,integer Biw,string Niw returns nothing
local integer Miw
local real wSw
set Xb[Lb]=Niw
set Lb=Lb+1
set Miw=Yl[tdw(dS,Biw,"when calling get in City, line 403")]
set wSw=Gl[tdw(dS,Biw,"when calling get in City, line 404")]
set Xb[Lb]="when calling addPopulation in City, line 405"
set Lb=Lb+1
if qO[Viw]==0 then
if Viw==0 then
call I1("Nullpointer exception when calling City.addPopulation","when calling error in City, line 396")
else
call I1("Called City.addPopulation on invalid object.","when calling error in City, line 396")
endif
endif
call Ciw(Viw,Miw,wSw,"when calling addPopulation in City, line 396")
set Lb=Lb-1
if Rl[tdw(dS,Biw,"when calling get in City, line 407")]==false then
set Pl[Viw]=Pl[Viw]-fl[tdw(dS,Biw,"when calling get in City, line 408")]*5.0/dl[tdw(dS,Biw,"when calling get in City, line 408")]
endif
set Lb=Lb-1
endfunction
function lcw takes integer NSw,integer MSw,string wcw returns nothing
local integer ucw
local integer rcw
local integer scw
local integer tcw
local real icw
local integer Scw
local integer ccw
local integer ocw
local integer Ocw
set Xb[Lb]=wcw
set Lb=Lb+1
set Ul[Bl[NSw]]=Ul[Bl[NSw]]+GetRandomReal(-0.0001,0.00015)*Ul[Bl[NSw]]
set ucw=El[Bl[NSw]]
set Ocw=El[Bl[NSw]]
set icw=Pow(El[Bl[NSw]]*Ul[Bl[NSw]],0.8)*FS[Dl[Bl[NSw]]]
set El[Bl[NSw]]=Ocw+R2I(icw)
set rcw=El[Bl[NSw]]-ucw
set scw=GetRandomInt(R2I(-(0.25*rcw)),R2I(0.25*rcw))
set El[Bl[NSw]]=El[Bl[NSw]]+scw
set Zl[Bl[NSw]]=El[Bl[NSw]]-ucw
set Scw=Jl[Bl[NSw]]
set Xb[Lb]="when calling iterator in City, line 149"
set Lb=Lb+1
set ccw=dbw(Scw,"when calling new_LLIterator in LinkedList, line 165")
set Lb=Lb-1
set tcw=ccw
loop
exitwhen Tb[Gb[tcw]]==Yb[tcw]
set Gb[tcw]=Tb[Gb[tcw]]
set MSw=fb[Gb[tcw]]
set ocw=Bl[NSw]
set Xb[Lb]="when calling getCityModifierOnFastCount in City, line 150"
set Lb=Lb+1
if qO[ocw]==0 then
if ocw==0 then
call I1("Nullpointer exception when calling City.getCityModifierOnFastCount","when calling error in City, line 402")
else
call I1("Called City.getCityModifierOnFastCount on invalid object.","when calling error in City, line 402")
endif
endif
call uSw(ocw,MSw,"when calling getCityModifierOnFastCount in City, line 402")
set Lb=Lb-1
endloop
set Xb[Lb]="when calling close in City, line 149"
set Lb=Lb+1
if hb[tcw]then
call edw(tcw,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 450")
endif
set Lb=Lb-1-1
endfunction
function snw takes integer Maw,integer wnw,string unw returns nothing
local force rnw
set Xb[Lb]=unw
set Lb=Lb+1
if kO[Maw]==0 then
if Maw==0 then
call I1("Nullpointer exception when calling CallbackPeriodic.call","when calling error in ClosureTimers, line 130")
else
call I1("Called CallbackPeriodic.call on invalid object.","when calling error in ClosureTimers, line 130")
endif
endif
if kO[Maw]<=634 then
if kO[Maw]<=632 then
if kO[Maw]<=631 then
call lcw(Maw,wnw,"when calling City_City_call_line138 in ClosureTimers, line 130")
else
call kcw(Maw,wnw,"when calling City_City_call_line154 in ClosureTimers, line 130")
endif
elseif kO[Maw]<=633 then
set rnw=bj_FORCE_ALL_PLAYERS
if IsPlayerInForce(GetLocalPlayer(),rnw) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,20.0,"Enjoying the map? Join the |cffe100ffofficial CoE discord channel|r! Link: |cffffff00discord.gg/V6kmxsy|r")
endif
else
call Sow(Maw,wnw)
endif
elseif kO[Maw]<=636 then
if kO[Maw]<=635 then
call Jow(Maw,wnw,"when calling Economy_call_line47 in ClosureTimers, line 130")
else
call aOw(Maw,wnw,"when calling Economy_call_line54 in ClosureTimers, line 130")
endif
else
call kyw(Maw,wnw,"when calling MultiboardCityUpdate_call_line25 in ClosureTimers, line 130")
endif
set Lb=Lb-1
set rnw=null
endfunction
function rvw takes nothing returns nothing
local integer uvw
set Lb=0
set Xb[Lb]="ClosureTimers, line 135"
set Lb=Lb+1
set uvw=rww(GetExpiredTimer(),"when calling getData in ClosureTimers, line 138")
call snw(uvw,uvw,"when calling call in ClosureTimers, line 139")
set Lb=Lb-1
endfunction
function rE takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function sE takes nothing returns boolean
if not rE() then
return false
endif
return true
endfunction
function sH takes nothing returns nothing
local integer VD=1
local integer BD=1747988787
local player ND=GetOwningPlayer(GetConstructedStructure())
local rect rH=bj_mapInitialPlayableArea
local location uH=Location(GetRectCenterX(rH),GetRectCenterY(rH))
local location MD=Location(GetLocationX(uH)+100000000.00,GetLocationY(uH)+1000000000.00)
local real wH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set VD=VD-1
exitwhen VD<0
call CreateUnitAtLocSaveLast(ND,BD,MD,wH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call UnitRemoveAbility(bj_lastCreatedUnit,1093677905)
call ShowUnit(bj_lastCreatedUnit,false)
set e[GetPlayerId(GetOwningPlayer(GetConstructedStructure()))+1]=true
set ND=null
set MD=null
set uH=null
set rH=null
endfunction
function sL takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function sU takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989825,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989817,0)
endfunction
function sW takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989082,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989072,0)
endfunction
function sj takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988792 then
return false
endif
return true
endfunction
function Pcw takes integer Zcw returns nothing
local integer Ucw
local trigger Icw
call TriggerAddAction(xS,Bf)
call TriggerAddAction(vS,Nf)
call TriggerAddAction(mS,Mf)
set Zcw=0
set Ucw=bj_MAX_PLAYERS-1
loop
exitwhen Zcw>Ucw
call TriggerRegisterPlayerEvent(vS,ro[Zcw],EVENT_PLAYER_LEAVE)
set Icw=mS
call TriggerRegisterPlayerEvent(Icw,ro[Zcw],EVENT_PLAYER_ARROW_DOWN_DOWN)
call TriggerRegisterPlayerEvent(Icw,ro[Zcw],EVENT_PLAYER_ARROW_DOWN_UP)
call TriggerRegisterPlayerEvent(Icw,ro[Zcw],EVENT_PLAYER_ARROW_UP_DOWN)
call TriggerRegisterPlayerEvent(Icw,ro[Zcw],EVENT_PLAYER_ARROW_UP_UP)
call TriggerRegisterPlayerEvent(Icw,ro[Zcw],EVENT_PLAYER_ARROW_LEFT_DOWN)
call TriggerRegisterPlayerEvent(Icw,ro[Zcw],EVENT_PLAYER_ARROW_LEFT_UP)
call TriggerRegisterPlayerEvent(Icw,ro[Zcw],EVENT_PLAYER_ARROW_RIGHT_DOWN)
call TriggerRegisterPlayerEvent(Icw,ro[Zcw],EVENT_PLAYER_ARROW_RIGHT_UP)
call TriggerRegisterPlayerEvent(Icw,ro[Zcw],EVENT_PLAYER_END_CINEMATIC)
call TriggerRegisterPlayerChatEvent(Icw,ro[Zcw],"",false)
set Zcw=Zcw+1
endloop
call E0w(EVENT_PLAYER_UNIT_SPELL_EFFECT,null,wR,null)
set Icw=null
endfunction
function Qaw takes integer xaw,integer vaw,string maw returns nothing
set Xb[Lb]=maw
set Lb=Lb+1
if qO[xaw]==0 then
if xaw==0 then
call I1("Nullpointer exception when calling City.getCityModifierOnRemove","when calling error in City, line 420")
else
call I1("Called City.getCityModifierOnRemove on invalid object.","when calling error in City, line 420")
endif
endif
set Xb[Lb]="when calling getCityModifierOnRemove in City, line 420"
set Lb=Lb+1
if Rl[tdw(dS,vaw,"when calling get in City, line 421")]then
set Pl[xaw]=Pl[xaw]-fl[tdw(dS,vaw,"when calling get in City, line 422")]
endif
set Al[xaw]=Al[xaw]-gl[tdw(dS,vaw,"when calling get in City, line 423")]
set Lb=Lb-1-1
endfunction
function bdw takes integer Odw,string ldw returns nothing
set Xb[Lb]=ldw
set Lb=Lb+1
if VO[Odw]==0 then
if Odw==0 then
call I1("Nullpointer exception when calling LLEntry.LLEntry","when calling error in LinkedList, line 396")
else
call I1("Called LLEntry.LLEntry on invalid object.","when calling error in LinkedList, line 396")
endif
endif
set Xb[Lb]="when calling destroyLLEntry in LinkedList, line 396"
set Lb=Lb+1
set Xb[Lb]="when calling dealloc_LLEntry in LinkedList, line 396"
set Lb=Lb+1
if VO[Odw]==0 then
call I1("Double free: object of type LLEntry","when calling error in LinkedList, line 396")
else
set LO[XO]=Odw
set XO=XO+1
set VO[Odw]=0
endif
set Lb=Lb-1-1-1
endfunction
function mdw takes integer jdw,integer xdw,string vdw returns nothing
set Xb[Lb]=vdw
set Lb=Lb+1
if tl[jdw]==0 then
if jdw==0 then
call I1("Nullpointer exception when calling LinkedList.removeEntry","when calling error in LinkedList, line 373")
else
call I1("Called LinkedList.removeEntry on invalid object.","when calling error in LinkedList, line 373")
endif
endif
set Xb[Lb]="when calling removeEntry in LinkedList, line 373"
set Lb=Lb+1
set Tb[Rb[xdw]]=Tb[xdw]
set Rb[Tb[xdw]]=Rb[xdw]
call bdw(xdw,"when calling dispatch_LLEntry_destroyLLEntry in LinkedList, line 376")
set kb[jdw]=kb[jdw]-1
set Lb=Lb-1-1
endfunction
function Qbw takes integer jbw,integer xbw,string vbw returns nothing
local integer mbw
set Xb[Lb]=vbw
set Lb=Lb+1
set mbw=Tb[Fb[jbw]]
loop
exitwhen mbw==Fb[jbw]
if fb[mbw]==xbw then
call mdw(jbw,mbw,"when calling removeEntry in LinkedList, line 126")
set Lb=Lb-1
return
endif
set mbw=Tb[mbw]
endloop
set Lb=Lb-1
endfunction
function Piw takes integer Qiw,integer Wiw,string Eiw returns boolean
local integer Ziw
local boolean Uiw
local integer Iiw
set Xb[Lb]=Eiw
set Lb=Lb+1
set Ziw=Jl[Qiw]
set Xb[Lb]="when calling has in City, line 375"
set Lb=Lb+1
if tl[Ziw]==0 then
if Ziw==0 then
call I1("Nullpointer exception when calling LinkedList.has","when calling error in LinkedList, line 103")
else
call I1("Called LinkedList.has on invalid object.","when calling error in LinkedList, line 103")
endif
endif
set Uiw=kbw(Ziw,Wiw)
set Lb=Lb-1
if not Uiw then
set Lb=Lb-1
return false
endif
set Iiw=Jl[Qiw]
set Xb[Lb]="when calling remove in City, line 377"
set Lb=Lb+1
if tl[Iiw]==0 then
if Iiw==0 then
call I1("Nullpointer exception when calling LinkedList.remove","when calling error in LinkedList, line 122")
else
call I1("Called LinkedList.remove on invalid object.","when calling error in LinkedList, line 122")
endif
endif
call Qbw(Iiw,Wiw,"when calling remove in LinkedList, line 122")
set Lb=Lb-1
call Qaw(Qiw,Wiw,"when calling getCityModifierOnRemove in City, line 378")
set Lb=Lb-1
return true
endfunction
function J8 takes multiboard U8,integer I8,integer P8,real A8,string D8 returns nothing
local multiboarditem H8=MultiboardGetItem(U8,P8,I8)
call MultiboardSetItemWidth(H8,A8)
call MultiboardSetItemValue(H8,D8)
set H8=null
endfunction
function X5 takes string W5 returns multiboard
local multiboard E5
local integer Z5
local integer U5
local integer I5
local integer P5
local integer A5
local integer D5
local integer H5
local integer J5
local string K5
local real L5
set Xb[Lb]=W5
set Lb=Lb+1
set E5=CreateMultiboardBJ(6,10,"Income: 2:00")
call MultiboardMinimize(E5,true)
call MultiboardSetItemsStyle(E5,true,false)
set Z5=0
set U5=23
loop
exitwhen Z5>U5
if so==ro[Z5]then
call MultiboardDisplay(E5,false)
endif
set Z5=Z5+1
endloop
set I5=0
set P5=9
loop
exitwhen I5>P5
set A5=0
set D5=5
loop
exitwhen A5>D5
set L5=kdw(Ic[I5],A5,"when calling get in MultiboardCityUpdate, line 14")/1000.
set H5=kdw(Xc[I5],A5,"when calling get in MultiboardCityUpdate, line 14")
set Xb[Lb]="when calling stringFromIndex in MultiboardCityUpdate, line 14"
set Lb=Lb+1
set J5=Ao
set Xb[Lb]="when calling loadString in TypeCasting, line 35"
set Lb=Lb+1
if HO[J5]==0 then
if J5==0 then
call I1("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call I1("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set K5=LoadStr(Zo,J5,H5)
set Lb=Lb-1
set W5=K5
set Lb=Lb-1
call J8(E5,A5,I5,L5,K5)
set A5=A5+1
endloop
set I5=I5+1
endloop
set Lb=Lb-1
set oR=E5
set E5=null
return oR
endfunction
function Ryw takes integer yyw,string pyw returns nothing
local integer eyw
local integer qyw
local integer ayw
local integer nyw
local boolean dyw
local multiboard fyw
set Xb[Lb]=pyw
set Lb=Lb+1
set eyw=0
set qyw=23
loop
exitwhen eyw>qyw
set yyw=uo[eyw]
set pyw="when calling isInGame in MultiboardCityUpdate, line 20"
set Xb[Lb]="when calling isInGame in MultiboardCityUpdate, line 20"
set Lb=Lb+1
if ll[yyw]==0 then
if yyw==0 then
call I1("Nullpointer exception when calling PlayerStats.isInGame","when calling error in PlayerStats, line 42")
else
call I1("Called PlayerStats.isInGame on invalid object.","when calling error in PlayerStats, line 42")
endif
endif
set dyw=Pb[yyw]
set Lb=Lb-1
if dyw then
set Cc[eyw]=X5("when calling createCoEMultiboard in MultiboardCityUpdate, line 21")
endif
set eyw=eyw+1
endloop
set ayw=0
set nyw=23
loop
exitwhen ayw>nyw
set fyw=Cc[ayw]
if so==ro[ayw]then
call MultiboardDisplay(fyw,true)
endif
set ayw=ayw+1
endloop
set Lb=Lb-1
set fyw=null
endfunction
function spw takes integer upw returns nothing
local group rpw
call TriggerRegisterEnterRegion(CreateTrigger(),mc,Filter(rR))
call E0w(EVENT_PLAYER_UNIT_ISSUED_ORDER,null,sR,null)
call GroupEnumUnitsInRect(Nc,vc,null)
call ForGroup(Nc,tR)
set rpw=Nc
call GroupClear(rpw)
call DestroyGroup(rpw)
set rpw=null
endfunction
function aB takes group bB,integer yB,string pB returns nothing
local group eB
local unit qB
set Xb[Lb]=pB
set Lb=Lb+1
set eB=bB
loop
exitwhen FirstOfGroup(eB)==null
set qB=FirstOfGroup(eB)
call GroupRemoveUnit(eB,qB)
call Naw(yB,qB,"when calling callback in ClosureForGroups, line 40")
endloop
call Xaw(yB,"when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 41")
set Lb=Lb-1
set eB=null
set qB=null
endfunction
function t0w takes string u0w returns nothing
local group r0w
local integer s0w
set Xb[Lb]=u0w
set Lb=Lb+1
call RemoveUnit(bo)
set r0w=lo
set Xb[Lb]="when calling alloc_Preloader_ForGroupCallback_line45 in Preloader, line 45"
set Lb=Lb+1
if nO==0 then
if dO<32768 then
set dO=dO+1
set s0w=dO
set fO[s0w]=692
else
call I1("Out of memory: Could not create Preloader_ForGroupCallback_line45.","when calling error in Preloader, line 45")
set s0w=0
endif
else
set nO=nO-1
set s0w=aO[nO]
set fO[s0w]=692
endif
set Lb=Lb-1
call aB(r0w,s0w,"when calling forEachFrom in Preloader, line 45")
call DestroyGroup(lo)
set lo=null
set Lb=Lb-1
set r0w=null
endfunction
function tsw takes string ssw returns nothing
endfunction
function vOw takes integer FOw,string kOw returns nothing
local integer jOw
local timer xOw
set Xb[Lb]=kOw
set Lb=Lb+1
call IssueImmediateOrderById(yb[FOw],852261)
set Xb[Lb]="when calling alloc_Garissons_CallbackSingle_line14 in Garissons, line 14"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set jOw=YO
set GO[jOw]=646
else
call I1("Out of memory: Could not create Garissons_CallbackSingle_line14.","when calling error in Garissons, line 14")
set jOw=0
endif
else
set TO=TO-1
set jOw=RO[TO]
set GO[jOw]=646
endif
set Lb=Lb-1
set pb[jOw]=yb[FOw]
set Xb[Lb]="when calling doAfter in Garissons, line 14"
set Lb=Lb+1
set xOw=iww("when calling getTimer in ClosureTimers, line 27")
set Xb[Lb]="when calling doAfter in ClosureTimers, line 27"
set Lb=Lb+1
call fnw(jOw,xOw,0.01,"when calling start in ClosureTimers, line 16")
set Lb=Lb-1-1-1
set xOw=null
endfunction
function xow takes integer yow,string pow returns nothing
local integer eow
local integer qow
local integer aow
local integer now
local integer dow
local integer fow
local integer Row
local unit Tow
local player Yow
local integer Gow
local unit gow
local integer how
local integer Fow
local boolean kow
local integer jow
set Xb[Lb]=pow
set Lb=Lb+1
set eow=lb[yow]*bb[yow]
set now=fS-1
set dow=(lb[yow]+1)*bb[yow]-1
if now<2147483647 then
set fow=now
else
set fow=2147483647
endif
if dow<fow then
set fow=dow
endif
set qow=fow
loop
exitwhen eow>qow
set Row=kS[eow]
set pow="when calling getCityUnit in Economy, line 36"
set Xb[Lb]="when calling getCityUnit in Economy, line 36"
set Lb=Lb+1
if qO[Row]==0 then
if Row==0 then
call I1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call I1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set Tow=kl[Row]
set Lb=Lb-1
set aow=GetPlayerId(GetOwningPlayer(Tow))
set Gow=kS[eow]
set Xb[Lb]="when calling getCityUnit in Economy, line 37"
set Lb=Lb+1
if qO[Gow]==0 then
if Gow==0 then
call I1("Nullpointer exception when calling City.getCityUnit","when calling error in City, line 188")
else
call I1("Called City.getCityUnit on invalid object.","when calling error in City, line 188")
endif
endif
set gow=kl[Gow]
set Lb=Lb-1
set Yow=GetOwningPlayer(gow)
if GetPlayerSlotState(Yow)==PLAYER_SLOT_STATE_PLAYING then
set kow=GetPlayerController(Yow)==MAP_CONTROL_USER
else
set kow=false
endif
if kow then
set jow=sc[aow]
set how=kS[eow]
set Xb[Lb]="when calling countTax in Economy, line 38"
set Lb=Lb+1
if qO[how]==0 then
if how==0 then
call I1("Nullpointer exception when calling City.countTax","when calling error in City, line 279")
else
call I1("Called City.countTax on invalid object.","when calling error in City, line 279")
endif
endif
set Fow=liw(how,"when calling countTax in City, line 279")
set Lb=Lb-1
set sc[aow]=jow+Fow
endif
set eow=eow+1
endloop
set Lb=Lb-1
set Tow=null
set Yow=null
set gow=null
endfunction
function enw takes integer Onw,string lnw returns nothing
local integer bnw
local integer ynw
local integer pnw
set Xb[Lb]=lnw
set Lb=Lb+1
if GO[Onw]==0 then
if Onw==0 then
call I1("Nullpointer exception when calling CallbackSingle.call","when calling error in ClosureTimers, line 109")
else
call I1("Called CallbackSingle.call on invalid object.","when calling error in ClosureTimers, line 109")
endif
endif
if GO[Onw]<=646 then
if GO[Onw]<=642 then
if GO[Onw]<=640 then
if GO[Onw]<=639 then
set Xb[Lb]="when calling City_City_call_line370 in ClosureTimers, line 109"
set Lb=Lb+1
set bnw=Xl[Onw]
set ynw=Cl[Onw]
set Xb[Lb]="when calling removeModifier in City, line 371"
set Lb=Lb+1
if qO[bnw]==0 then
if bnw==0 then
call I1("Nullpointer exception when calling City.removeModifier","when calling error in City, line 374")
else
call I1("Called City.removeModifier on invalid object.","when calling error in City, line 374")
endif
endif
call Piw(bnw,ynw,"when calling removeModifier in City, line 374")
set Lb=Lb-1-1
else
call Pcw(Onw)
endif
elseif GO[Onw]<=641 then
set XS=XS+50
else
set XS=XS*2
endif
elseif GO[Onw]<=644 then
if GO[Onw]<=643 then
set XS=XS/2
set pnw=XS
if pnw!=250 then
call tsw("Expected <"+I2S(250)+">, Actual <"+I2S(pnw)+">")
endif
else
call xow(Onw,"when calling Economy_call_line34 in ClosureTimers, line 109")
endif
elseif GO[Onw]<=645 then
call vOw(Onw,"when calling Garissons_call_line12 in ClosureTimers, line 109")
else
call IssueImmediateOrderById(pb[Onw],851974)
endif
elseif GO[Onw]<=650 then
if GO[Onw]<=648 then
if GO[Onw]<=647 then
call IssueImmediateOrderById(nb[Onw],851976)
else
call IssuePointOrderById(mb[Onw],Qb[Onw],Wb[Onw],Eb[Onw])
endif
elseif GO[Onw]<=649 then
call Ryw(Onw,"when calling MultiboardCityUpdate_call_line18 in ClosureTimers, line 109")
else
call IssueImmediateOrderById(Zb[Onw],851976)
endif
elseif GO[Onw]<=652 then
if GO[Onw]<=651 then
call spw(Onw)
else
set Xb[Lb]="when calling Preloader_call_line54 in ClosureTimers, line 109"
set Lb=Lb+1
call t0w("when calling finishPreload in Preloader, line 54")
set Lb=Lb-1
endif
else
call IssueImmediateOrderById(Jb[Onw],851976)
endif
set Lb=Lb-1
endfunction
function oww takes timer Sww,string cww returns nothing
set Xb[Lb]=cww
set Lb=Lb+1
if Sww==null then
call I1("Trying to release a null timer","when calling error in TimerUtils, line 37")
set Lb=Lb-1
return
endif
if rww(Sww,"when calling getData in TimerUtils, line 39")==679645218 then
call I1("ReleaseTimer: Double free!","when calling error in TimerUtils, line 40")
set Lb=Lb-1
return
endif
call Vww(Sww,679645218,"when calling setData in TimerUtils, line 42")
call PauseTimer(Sww)
set Uo[Io]=Sww
set Io=Io+1
set Lb=Lb-1
endfunction
function row takes integer wow,string uow returns nothing
set Xb[Lb]=uow
set Lb=Lb+1
set Xb[Lb]="when calling CallbackSingle_onDestroy in ClosureTimers, line 123"
set Lb=Lb+1
call oww(Sb[wow],"when calling release in ClosureTimers, line 124")
set Lb=Lb-1
set Xb[Lb]="when calling dealloc_CallbackSingle in ClosureTimers, line 123"
set Lb=Lb+1
if GO[wow]==0 then
call I1("Double free: object of type CallbackSingle","when calling error in ClosureTimers, line 107")
else
set RO[TO]=wow
set TO=TO+1
set GO[wow]=0
endif
set Lb=Lb-1-1
endfunction
function mB takes string xB returns nothing
local integer vB
set Xb[Lb]=xB
set Lb=Lb+1
set vB=rww(GetExpiredTimer(),"when calling getData in ClosureTimers, line 119")
call enw(vB,"when calling call in ClosureTimers, line 120")
set Xb[Lb]="when calling dispatch_CallbackSingle_destroyCallbackSingle in ClosureTimers, line 121"
set Lb=Lb+1
if GO[vB]==0 then
if vB==0 then
call I1("Nullpointer exception when calling CallbackSingle.CallbackSingle","when calling error in ClosureTimers, line 107")
else
call I1("Called CallbackSingle.CallbackSingle on invalid object.","when calling error in ClosureTimers, line 107")
endif
endif
call row(vB,"when calling destroyCallbackSingle in ClosureTimers, line 107")
set Lb=Lb-1-1
endfunction
function svw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureTimers, line 114"
set Lb=Lb+1
call mB("when calling staticCallback in ClosureTimers, line 114")
set Lb=Lb-1
endfunction
function sx takes nothing returns boolean
if GetUnitTypeId(GetDyingUnit())!=1747988793 then
return false
endif
return true
endfunction
function sD takes nothing returns boolean
if GetResearched()!=1378890052 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890052,true)!=2 then
return false
endif
return true
endfunction
function tD takes nothing returns boolean
if not sD() then
return false
endif
return true
endfunction
function tE takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989812,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989811,0)
endfunction
function sK takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747990356 then
return false
endif
return true
endfunction
function tK takes nothing returns boolean
if not sK() then
return false
endif
return true
endfunction
function sQ takes nothing returns boolean
if GetResearched()!=1378889802 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889802,true)!=1 then
return false
endif
return true
endfunction
function tQ takes nothing returns boolean
if not sQ() then
return false
endif
return true
endfunction
function u4 takes nothing returns boolean
return true
endfunction
function uI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989826,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989828,0)
endfunction
function wP takes nothing returns boolean
if GetResearched()!=1378889780 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889780,true)!=1 then
return false
endif
return true
endfunction
function uP takes nothing returns boolean
if not wP() then
return false
endif
return true
endfunction
function uX takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677634)
endfunction
function wZ takes nothing returns boolean
if GetResearched()!=1378889809 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889809,true)!=1 then
return false
endif
return true
endfunction
function uZ takes nothing returns boolean
if not wZ() then
return false
endif
return true
endfunction
function DX takes string PX returns boolean
local integer AX
set Xb[Lb]=PX
set Lb=Lb+1
set cS=plw("when calling new_HashMap in CityBaseTaxes, line 5")
set AX=cS
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 9"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747988529,20)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 10"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747988530,50)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 11"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747988531,120)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 12"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747990326,20)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 13"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747990327,50)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 14"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747990328,120)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 15"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747990084,20)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 16"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747990085,50)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 17"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747990086,120)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 18"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747989590,20)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 19"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747989591,50)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 20"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747989592,120)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 22"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747989555,5)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 23"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747989297,10)
set Lb=Lb-1
set Xb[Lb]="when calling saveInt in CityBaseTaxes, line 24"
set Lb=Lb+1
if HO[AX]==0 then
if AX==0 then
call I1("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call I1("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call SaveInteger(Zo,AX,1747989325,30)
set Lb=Lb-1-1
return true
endfunction
function uxw takes nothing returns boolean
set Lb=0
return DX("CityBaseTaxes, line 1")
endfunction
function vG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989047 then
return false
endif
return true
endfunction
function vH takes nothing returns nothing
local integer GH=1
local integer gH=1752461175
local player hH=GetOwningPlayer(GetTriggerUnit())
local rect xH=bj_mapInitialPlayableArea
local location jH=Location(GetRectCenterX(xH),GetRectCenterY(xH))
local location FH=Location(GetLocationX(jH)+100000000.00,GetLocationY(jH)+100000000.00)
local real kH=bj_UNIT_FACING
call GroupClear(bj_lastCreatedGroup)
loop
set GH=GH-1
exitwhen GH<0
call CreateUnitAtLocSaveLast(hH,gH,FH,kH)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
call ShowUnit(bj_lastCreatedUnit,false)
set hH=null
set FH=null
set jH=null
set xH=null
endfunction
function xL takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989592 then
return false
endif
return true
endfunction
function vL takes nothing returns boolean
if not xL() then
return false
endif
return true
endfunction
function vP takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990584,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990593,0)
endfunction
function xU takes nothing returns boolean
if GetResearched()!=1378890034 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890034,true)!=1 then
return false
endif
return true
endfunction
function vU takes nothing returns boolean
if not xU() then
return false
endif
return true
endfunction
function xW takes nothing returns boolean
if GetResearched()!=1378889812 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889812,true)!=1 then
return false
endif
return true
endfunction
function vW takes nothing returns boolean
if not xW() then
return false
endif
return true
endfunction
function vX takes nothing returns boolean
set SS=ro[PLAYER_NEUTRAL_PASSIVE]
return true
endfunction
function vZ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989574,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989573,0)
endfunction
function vg takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747990089 then
return false
endif
return true
endfunction
function vh takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989078 then
return false
endif
return true
endfunction
function vk takes nothing returns nothing
local player fk=GetOwningPlayer(GetSpellTargetUnit())
local playerstate Rk=PLAYER_STATE_RESOURCE_GOLD
local playerstate Tk
local playerstate Yk
local player Gk
local force gk
local location hk
local real Fk
local real kk
local player jk
local force xk
if Rk==PLAYER_STATE_RESOURCE_GOLD then
set Tk=PLAYER_STATE_GOLD_GATHERED
call SetPlayerState(fk,Tk,GetPlayerState(fk,Tk)+250)
elseif Rk==PLAYER_STATE_RESOURCE_LUMBER then
set Yk=PLAYER_STATE_LUMBER_GATHERED
call SetPlayerState(fk,Yk,GetPlayerState(fk,Yk)+250)
endif
call SetPlayerState(fk,Rk,GetPlayerState(fk,Rk)+250)
call RemoveUnit(GetSpellAbilityUnit())
set Gk=GetOwningPlayer(GetSpellTargetUnit())
set gk=CreateForce()
call ForceAddPlayer(gk,Gk)
if IsPlayerInForce(GetLocalPlayer(),gk) then
call DisplayTextToPlayer(GetLocalPlayer(),0.,0.,"TRIGSTR_1230")
endif
set y=GetUnitLoc(GetSpellTargetUnit())
set jk=GetOwningPlayer(GetSpellTargetUnit())
set xk=CreateForce()
call ForceAddPlayer(xk,jk)
set hk=y
set Fk=GetLocationX(hk)
set kk=GetLocationY(hk)
if IsPlayerInForce(GetLocalPlayer(),xk) then
call PingMinimap(Fk,kk,2.00)
endif
call RemoveLocation(y)
set fk=null
set Rk=null
set Tk=null
set Yk=null
set Gk=null
set gk=null
set hk=null
set jk=null
set xk=null
endfunction
function D9 takes string v9 returns boolean
local playerunitevent m9
local playerunitevent Q9
local playerunitevent W9
local integer E9
local integer Z9
local integer U9
local integer I9
local integer P9
local integer A9
set Xb[Lb]=v9
set Lb=Lb+1
set m9=EVENT_PLAYER_UNIT_DEATH
set Xb[Lb]="when calling alloc_OreCapture_EventListener_line9 in OreCapture, line 9"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set E9=cO
set oO[E9]=680
else
call I1("Out of memory: Could not create OreCapture_EventListener_line9.","when calling error in OreCapture, line 9")
set E9=0
endif
else
set SO=SO-1
set E9=iO[SO]
set oO[E9]=680
endif
set Lb=Lb-1
set Ml[E9]=0
set wb[E9]=0
set ub[E9]=0
set Xb[Lb]="when calling add in OreCapture, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set Z9=QS[GetHandleId(m9)]
if Z9==0 then
set Z9=QV(m9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[E9]=Z9
if US[Ml[E9]]!=0 then
set ub[US[Ml[E9]]]=E9
set wb[E9]=US[Ml[E9]]
endif
set US[Ml[E9]]=E9
set Lb=Lb-1
set Q9=EVENT_PLAYER_UNIT_UPGRADE_FINISH
set Xb[Lb]="when calling alloc_OreCapture_EventListener_line14 in OreCapture, line 14"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set U9=cO
set oO[U9]=678
else
call I1("Out of memory: Could not create OreCapture_EventListener_line14.","when calling error in OreCapture, line 14")
set U9=0
endif
else
set SO=SO-1
set U9=iO[SO]
set oO[U9]=678
endif
set Lb=Lb-1
set Ml[U9]=0
set wb[U9]=0
set ub[U9]=0
set Xb[Lb]="when calling add in OreCapture, line 14"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set I9=QS[GetHandleId(Q9)]
if I9==0 then
set I9=QV(Q9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[U9]=I9
if US[Ml[U9]]!=0 then
set ub[US[Ml[U9]]]=U9
set wb[U9]=US[Ml[U9]]
endif
set US[Ml[U9]]=U9
set Lb=Lb-1
set W9=EVENT_PLAYER_UNIT_ATTACKED
set Xb[Lb]="when calling alloc_OreCapture_EventListener_line21 in OreCapture, line 21"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set P9=cO
set oO[P9]=679
else
call I1("Out of memory: Could not create OreCapture_EventListener_line21.","when calling error in OreCapture, line 21")
set P9=0
endif
else
set SO=SO-1
set P9=iO[SO]
set oO[P9]=679
endif
set Lb=Lb-1
set Ml[P9]=0
set wb[P9]=0
set ub[P9]=0
set Xb[Lb]="when calling add in OreCapture, line 21"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set A9=QS[GetHandleId(W9)]
if A9==0 then
set A9=QV(W9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[P9]=A9
if US[Ml[P9]]!=0 then
set ub[US[Ml[P9]]]=P9
set wb[P9]=US[Ml[P9]]
endif
set US[Ml[P9]]=P9
set Lb=Lb-1-1
set m9=null
set Q9=null
set W9=null
return true
endfunction
function vxw takes nothing returns boolean
set Lb=0
return D9("OreCapture, line 1")
endfunction
function w4 takes nothing returns boolean
return true
endfunction
function wA takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990607,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990583,0)
endfunction
function MU takes nothing returns boolean
if GetResearched()!=1378890033 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890033,true)!=2 then
return false
endif
return true
endfunction
function wI takes nothing returns boolean
if not MU() then
return false
endif
return true
endfunction
function ML takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747988531 then
return false
endif
return true
endfunction
function wX takes nothing returns boolean
if not ML() then
return false
endif
return true
endfunction
function wm takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988561,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747988784,0)
endfunction
function Jaw takes integer Aaw,unit Daw,string Haw returns nothing
set Xb[Lb]=Haw
set Lb=Lb+1
if xO[Aaw]==0 then
if Aaw==0 then
call I1("Nullpointer exception when calling OnCastListener.fire","when calling error in ClosureEvents, line 56")
else
call I1("Called OnCastListener.fire on invalid object.","when calling error in ClosureEvents, line 56")
endif
endif
set Lb=Lb-1
endfunction
function OB takes string tB returns nothing
local unit iB
local integer SB
local integer cB
local integer oB
set Xb[Lb]=tB
set Lb=Lb+1
set iB=GetTriggerUnit()
set SB=GetSpellAbilityId()
if Xnw(ZS,GetHandleId(iB),"when calling has in ClosureEvents, line 189") then
set cB=tdw(ZS,GetHandleId(iB),"when calling get in ClosureEvents, line 190")
loop
exitwhen cB==0
if tb[cB]==-1 or tb[cB]==SB then
call Jaw(cB,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 193")
endif
set cB=rb[cB]
endloop
endif
if Xnw(ES,SB,"when calling has in ClosureEvents, line 195") then
set oB=tdw(ES,SB,"when calling get in ClosureEvents, line 196")
loop
exitwhen oB==0
if ib[oB]==null or ib[oB]==iB then
call Jaw(oB,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 199")
endif
set oB=rb[oB]
endloop
endif
set Lb=Lb-1
set iB=null
endfunction
function wvw takes nothing returns nothing
set Lb=0
set Xb[Lb]="ClosureEvents, line 308"
set Lb=Lb+1
call OB("when calling onSpellEffect in ClosureEvents, line 308")
set Lb=Lb-1
endfunction
function fV takes string nV returns boolean
local integer dV
set Xb[Lb]=nV
set Lb=Lb+1
set jS=ConvertPlayerEvent(96)
set ES=plw("when calling new_HashMap in ClosureEvents, line 99")
set ZS=plw("when calling new_HashMap in ClosureEvents, line 100")
set xS=CreateTrigger()
set vS=CreateTrigger()
set mS=CreateTrigger()
call TriggerAddCondition(Do,Condition(Wf))
call TriggerAddCondition(Ho,Condition(Ef))
set Xb[Lb]="when calling alloc_ClosureEvents_CallbackSingle_line290 in ClosureEvents, line 290"
set Lb=Lb+1
if TO==0 then
if YO<32768 then
set YO=YO+1
set dV=YO
set GO[dV]=640
else
call I1("Out of memory: Could not create ClosureEvents_CallbackSingle_line290.","when calling error in ClosureEvents, line 290")
set dV=0
endif
else
set TO=TO-1
set dV=RO[TO]
set GO[dV]=640
endif
set Lb=Lb-1
set Xb[Lb]="when calling nullTimer in ClosureEvents, line 290"
set Lb=Lb+1
set Xb[Lb]="when calling doAfter in ClosureTimers, line 33"
set Lb=Lb+1
call jB(iww("when calling getTimer in ClosureTimers, line 27"),0.,dV,"when calling doAfter in ClosureTimers, line 27")
set Lb=Lb-1-1-1
return true
endfunction
function wxw takes nothing returns boolean
set Lb=0
return fV("ClosureEvents, line 1")
endfunction
function x9 takes nothing returns nothing
call h9(GetEnumUnit())
endfunction
function xD takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())==1747988535 then
call ReplaceUnitBJ(GetEnumUnit(),1747988788,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990325 then
call ReplaceUnitBJ(GetEnumUnit(),1747990324,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747989594 then
call ReplaceUnitBJ(GetEnumUnit(),1747990097,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988784 then
call ReplaceUnitBJ(GetEnumUnit(),1747988561,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988563 then
call ReplaceUnitBJ(GetEnumUnit(),1747988565,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988562 then
call ReplaceUnitBJ(GetEnumUnit(),1747988566,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747988564 then
call ReplaceUnitBJ(GetEnumUnit(),1747988567,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990104 then
call ReplaceUnitBJ(GetEnumUnit(),1747990321,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990105 then
call ReplaceUnitBJ(GetEnumUnit(),1747990322,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990106 then
call ReplaceUnitBJ(GetEnumUnit(),1747990323,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747989811 then
call ReplaceUnitBJ(GetEnumUnit(),1747989812,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990095 then
call ReplaceUnitBJ(GetEnumUnit(),1747990098,bj_UNIT_STATE_METHOD_RELATIVE)
endif
if GetUnitTypeId(GetEnumUnit())==1747990096 then
call ReplaceUnitBJ(GetEnumUnit(),1747990099,bj_UNIT_STATE_METHOD_RELATIVE)
endif
endfunction
function xI takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989835,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747989836,0)
endfunction
function jP takes nothing returns boolean
if GetResearched()!=1378890049 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378890049,true)!=1 then
return false
endif
return true
endfunction
function xP takes nothing returns boolean
if not jP() then
return false
endif
return true
endfunction
function jY takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit())!=1747989044 then
return false
endif
if GetUnitStatePercent(GetTriggerUnit(),UNIT_STATE_LIFE,UNIT_STATE_MAX_LIFE)>80.00 then
return false
endif
return true
endfunction
function xY takes nothing returns boolean
if not jY() then
return false
endif
return true
endfunction
function jZ takes nothing returns boolean
if GetResearched()!=1378889810 then
return false
endif
if GetPlayerTechCount(GetOwningPlayer(GetResearchingUnit()),1378889810,true)!=2 then
return false
endif
return true
endfunction
function xZ takes nothing returns boolean
if not jZ() then
return false
endif
return true
endfunction
function d9 takes string e9 returns boolean
local playerevent q9
local integer a9
local integer n9
set Xb[Lb]=e9
set Lb=Lb+1
set q9=EVENT_PLAYER_LEAVE
set Xb[Lb]="when calling alloc_OnPlayerLeave_EventListener_line5 in OnPlayerLeave, line 5"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set a9=cO
set oO[a9]=677
else
call I1("Out of memory: Could not create OnPlayerLeave_EventListener_line5.","when calling error in OnPlayerLeave, line 5")
set a9=0
endif
else
set SO=SO-1
set a9=iO[SO]
set oO[a9]=677
endif
set Lb=Lb-1
set Ml[a9]=0
set wb[a9]=0
set ub[a9]=0
set Xb[Lb]="when calling add in OnPlayerLeave, line 5"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set n9=QS[GetHandleId(q9)]
if n9==0 then
set n9=QV(q9,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[a9]=n9
if US[Ml[a9]]!=0 then
set ub[US[Ml[a9]]]=a9
set wb[a9]=US[Ml[a9]]
endif
set US[Ml[a9]]=a9
set Lb=Lb-1-1
set q9=null
return true
endfunction
function xxw takes nothing returns boolean
set Lb=0
return d9("OnPlayerLeave, line 1")
endfunction
function y4 takes nothing returns boolean
return true
endfunction
function y9 takes nothing returns boolean
return true
endfunction
function yD takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990598,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1747990597,0)
endfunction
function oG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988826 then
return false
endif
return true
endfunction
function OG takes nothing returns boolean
if not oG() then
return false
endif
return true
endfunction
function lG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747989079 then
return false
endif
return true
endfunction
function bG takes nothing returns boolean
if not lG() then
return false
endif
return true
endfunction
function SG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988824 then
return false
endif
return true
endfunction
function cG takes nothing returns boolean
if not SG() then
return false
endif
return true
endfunction
function tG takes nothing returns boolean
if GetSpellAbilityId()!=1093677624 then
return false
endif
if GetUnitTypeId(GetSpellAbilityUnit())!=1747988825 then
return false
endif
return true
endfunction
function iG takes nothing returns boolean
if not tG() then
return false
endif
return true
endfunction
function yG takes nothing returns nothing
if iG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989047,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if cG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989046,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if OG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989077,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
if bG() then
call ReplaceUnitBJ(GetSpellAbilityUnit(),1747989078,bj_UNIT_STATE_METHOD_RELATIVE)
call SetUnitAnimation(bj_lastReplacedUnit,"Death Alternate")
endif
endfunction
function yK takes nothing returns nothing
call UnitAddAbility(GetTriggerUnit(),1093677896)
endfunction
function yQ takes nothing returns nothing
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651826,-1)
call SetPlayerTechMaxAllowed(GetOwningPlayer(GetResearchingUnit()),1848651824,0)
endfunction
function bC takes string CX returns boolean
local trigger VX
local playerunitevent BX
local playerunitevent NX
local integer MX
local integer wC
local player uC
local location rC
local real sC
local integer tC
local integer iC
local trigger SC
local playerunitevent cC
local integer oC
local integer OC
local integer lC
set Xb[Lb]=CX
set Lb=Lb+1
if Fc then
set MX=5
set wC=1747988553
set uC=ro[0]
set rC=Location(-3000.0,1700.0)
set sC=0.
call GroupClear(bj_lastCreatedGroup)
loop
set MX=MX-1
exitwhen MX<0
call CreateUnitAtLocSaveLast(uC,wC,rC,sC)
call GroupAddUnit(bj_lastCreatedGroup,bj_lastCreatedUnit)
endloop
endif
set BX=EVENT_PLAYER_UNIT_SELECTED
set Xb[Lb]="when calling alloc_CityManage_EventListener_line9 in CityManage, line 9"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set tC=cO
set oO[tC]=666
else
call I1("Out of memory: Could not create CityManage_EventListener_line9.","when calling error in CityManage, line 9")
set tC=0
endif
else
set SO=SO-1
set tC=iO[SO]
set oO[tC]=666
endif
set Lb=Lb-1
set Ml[tC]=0
set wb[tC]=0
set ub[tC]=0
set Xb[Lb]="when calling add in CityManage, line 9"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set iC=QS[GetHandleId(BX)]
if iC==0 then
set iC=QV(BX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[tC]=iC
if US[Ml[tC]]!=0 then
set ub[US[Ml[tC]]]=tC
set wb[tC]=US[Ml[tC]]
endif
set US[Ml[tC]]=tC
set Lb=Lb-1
set VX=CreateTrigger()
call TriggerAddCondition(VX,Condition(mf))
call TriggerAddAction(VX,Qf)
set SC=VX
set cC=EVENT_PLAYER_UNIT_SPELL_CAST
set oC=0
loop
call TriggerRegisterPlayerUnitEvent(SC,Player(oC),cC,null)
set oC=oC+1
exitwhen oC==bj_MAX_PLAYER_SLOTS
endloop
set NX=EVENT_PLAYER_UNIT_ATTACKED
set Xb[Lb]="when calling alloc_CityManage_EventListener_line34 in CityManage, line 34"
set Lb=Lb+1
if SO==0 then
if cO<32768 then
set cO=cO+1
set OC=cO
set oO[OC]=665
else
call I1("Out of memory: Could not create CityManage_EventListener_line34.","when calling error in CityManage, line 34")
set OC=0
endif
else
set SO=SO-1
set OC=iO[SO]
set oO[OC]=665
endif
set Lb=Lb-1
set Ml[OC]=0
set wb[OC]=0
set ub[OC]=0
set Xb[Lb]="when calling add in CityManage, line 34"
set Lb=Lb+1
set Xb[Lb]="when calling toIntId in ClosureEvents, line 112"
set Lb=Lb+1
set lC=QS[GetHandleId(NX)]
if lC==0 then
set lC=QV(NX,"when calling registerEventId in ClosureEvents, line 229")
endif
set Lb=Lb-1
set Ml[OC]=lC
if US[Ml[OC]]!=0 then
set ub[US[Ml[OC]]]=OC
set wb[OC]=US[Ml[OC]]
endif
set US[Ml[OC]]=OC
set Lb=Lb-1-1
set VX=null
set BX=null
set NX=null
set uC=null
set rC=null
set SC=null
set cC=null
return true
endfunction
function yxw takes nothing returns boolean
set Lb=0
return bC("CityManage, line 1")
endfunction
function pR takes nothing returns nothing
set w=null
set u=null
set s=null
set t=null
set i=null
set S=null
set c=null
set o=null
set O=null
set l=null
set b=null
set y=null
set q=null
set a=null
set n=null
set d=null
set f=null
set R=null
set T=null
set Y=null
set G=null
set g=null
set h=null
set F=null
set k=null
set j=null
set x=null
set v=null
set m=null
set Q=null
set W=null
set E=null
set Z=null
set U=null
set I=null
set P=null
set A=null
set D=null
set H=null
set J=null
set K=null
set L=null
set X=null
set C=null
set V=null
set B=null
set N=null
set M=null
set ww=null
set uw=null
set rw=null
set sw=null
set tw=null
set iw=null
set Sw=null
set cw=null
set ow=null
set Ow=null
set lw=null
set bw=null
set yw=null
set pw=null
set ew=null
set qw=null
set aw=null
set nw=null
set dw=null
set fw=null
set Rw=null
set Tw=null
set Yw=null
set Gw=null
set gw=null
set hw=null
set Fw=null
set kw=null
set jw=null
set xw=null
set vw=null
set mw=null
set Qw=null
set Ww=null
set Ew=null
set Zw=null
set Uw=null
set Iw=null
set Pw=null
set Aw=null
set Dw=null
set Hw=null
set Jw=null
set Kw=null
set Lw=null
set Xw=null
set Cw=null
set Vw=null
set Bw=null
set Nw=null
set Mw=null
set wu=null
set uu=null
set ru=null
set su=null
set tu=null
set iu=null
set Su=null
set cu=null
set ou=null
set Ou=null
set lu=null
set bu=null
set yu=null
set pu=null
set eu=null
set qu=null
set au=null
set nu=null
set du=null
set fu=null
set Ru=null
set Tu=null
set Yu=null
set Gu=null
set gu=null
set hu=null
set Fu=null
set ku=null
set ju=null
set xu=null
set vu=null
set mu=null
set Qu=null
set Wu=null
set Eu=null
set Zu=null
set Uu=null
set Iu=null
set Pu=null
set Au=null
set Du=null
set Hu=null
set Ju=null
set Ku=null
set Lu=null
set Xu=null
set Cu=null
set Vu=null
set Bu=null
set Nu=null
set Mu=null
set wr=null
set ur=null
set rr=null
set sr=null
set tr=null
set ir=null
set Sr=null
set cr=null
set lr=null
set br=null
set yr=null
set pr=null
set er=null
set qr=null
set ar=null
set nr=null
set dr=null
set fr=null
set Rr=null
set Tr=null
set Yr=null
set Gr=null
set gr=null
set hr=null
set Fr=null
set kr=null
set jr=null
set xr=null
set vr=null
set mr=null
set Qr=null
set Wr=null
set Er=null
set Zr=null
set Ur=null
set Ir=null
set Pr=null
set Ar=null
set Dr=null
set Hr=null
set Jr=null
set Kr=null
set Lr=null
set Xr=null
set Cr=null
set Vr=null
set Br=null
set Nr=null
set Mr=null
set ws=null
set us=null
set rs=null
set ss=null
set ts=null
set is=null
set Ss=null
set cs=null
set os=null
set Os=null
set ls=null
set bs=null
set ys=null
set ps=null
set es=null
set qs=null
set as=null
set ns=null
set ds=null
set fs=null
set Rs=null
set Ts=null
set Ys=null
set Gs=null
set gs=null
set hs=null
set Fs=null
set ks=null
set js=null
set xs=null
set vs=null
set ms=null
set Qs=null
set Ws=null
set Es=null
set Zs=null
set Us=null
set Is=null
set Ps=null
set As=null
set Ds=null
set Hs=null
set Js=null
set Ks=null
set Ls=null
set Xs=null
set Cs=null
set Vs=null
set Bs=null
set Ns=null
set Ms=null
set wt=null
set ut=null
set rt=null
set st=null
set tt=null
set St=null
set ct=null
set ot=null
set Ot=null
set lt=null
set bt=null
set yt=null
set pt=null
set et=null
set qt=null
set at=null
set nt=null
set dt=null
set ft=null
set Rt=null
set Tt=null
set Yt=null
set Gt=null
set gt=null
set ht=null
set Ft=null
set kt=null
set jt=null
set xt=null
set vt=null
set mt=null
set Qt=null
set Wt=null
set Et=null
set Zt=null
set Ut=null
set It=null
set Pt=null
set At=null
set Dt=null
set Ht=null
set Jt=null
set Kt=null
set Lt=null
set Xt=null
set Ct=null
set Vt=null
set Bt=null
set Nt=null
set Mt=null
set wi=null
set ui=null
set ri=null
set si=null
set ti=null
set ii=null
set Si=null
set ci=null
set oi=null
set Oi=null
set li=null
set bi=null
set yi=null
set pi=null
set ei=null
set qi=null
set ai=null
set ni=null
set di=null
set fi=null
set Ri=null
set Ti=null
set Yi=null
set Gi=null
set gi=null
set hi=null
set Fi=null
set ki=null
set ji=null
set xi=null
set vi=null
set mi=null
set Qi=null
set Wi=null
set Ei=null
set Zi=null
set Ui=null
set Ii=null
set Pi=null
set Ai=null
set Di=null
set Hi=null
set Ji=null
set Ki=null
set Li=null
set Xi=null
set Ci=null
set Vi=null
set Bi=null
set Ni=null
set Mi=null
set wS=null
set uS=null
set rS=null
set sS=null
set Yy=function ET
set Gy=function PT
set gy=function HT
set hy=function LT
set Fy=function MT
set ky=function iY
set jy=function bY
set xy=function nY
set vy=function GY
set my=function xY
set Qy=function ZY
set Wy=function HY
set Ey=function LY
set Zy=function NY
set Uy=function MY
set Iy=function yG
set Py=function hG
set Ay=function QG
set Dy=function vG
set Hy=function JG
set Jy=function NG
set Ky=function VG
set Ly=function og
set Xy=function qg
set Cy=function pg
set Vy=function hg
set By=function Qg
set Ny=function vg
set My=function Jg
set wp=function Ng
set up=function Vg
set rp=function oh
set sp=function qh
set tp=function ph
set ip=function hh
set Sp=function Qh
set cp=function vh
set op=function Jh
set Op=function Nh
set lp=function Vh
set bp=function oF
set yp=function qF
set pp=function fF
set ep=function GF
set qp=function kF
set ap=function mF
set np=function KF
set dp=function MF
set fp=function bk
set Rp=function dk
set Tp=function vk
set Yp=function Ik
set Gp=function Nk
set gp=function sj
set hp=function qj
set Fp=function Rj
set kp=function Qj
set jp=function Ij
set xp=function Nj
set vp=function sx
set mp=function qx
set Qp=function Yx
set Wp=function Ex
set Ep=function Hx
set Zp=function rv
set Up=function ov
set Ip=function Rv
set Pp=function hv
set Ap=function Iv
set Dp=function Kv
set Hp=function Lv
set Jp=function Mv
set Kp=function wm
set Lp=function Sm
set Xp=function cm
set Cp=function pm
set Vp=function em
set Bp=function Rm
set Np=function Tm
set Mp=function km
set we=function jm
set ue=function Em
set re=function Zm
set se=function Hm
set te=function Jm
set ie=function Bm
set Se=function Nm
set ce=function tQ
set oe=function iQ
set Oe=function bQ
set le=function yQ
set be=function dQ
set ye=function fQ
set pe=function hQ
set ee=function FQ
set qe=function QQ
set ae=function WQ
set ne=function AQ
set de=function DQ
set fe=function CQ
set Re=function VQ
set Te=function rW
set Ye=function sW
set Ge=function OW
set ge=function lW
set he=function aW
set Fe=function nW
set ke=function GW
set je=function gW
set xe=function vW
set ve=function mW
set me=function IW
set Qe=function PW
set We=function KW
set Ee=function LW
set Ze=function VW
set Ue=function BW
set Ie=function sE
set Pe=function tE
set Ae=function lE
set De=function bE
set He=function nE
set Je=function dE
set Ke=function gE
set Le=function hE
set Xe=function mE
set Ce=function QE
set Ve=function PE
set Be=function AE
set Ne=function XE
set Me=function CE
set wq=function uZ
set uq=function rZ
set rq=function oZ
set sq=function OZ
set tq=function qZ
set iq=function aZ
set Sq=function YZ
set cq=function GZ
set oq=function xZ
set Oq=function vZ
set lq=function UZ
set bq=function IZ
set yq=function KZ
set pq=function LZ
set eq=function NZ
set qq=function MZ
set aq=function rU
set nq=function sU
set dq=function OU
set fq=function lU
set Rq=function aU
set Tq=function nU
set Yq=function GU
set Gq=function gU
set gq=function vU
set hq=function mU
set Fq=function IU
set kq=function PU
set jq=function LU
set xq=function XU
set vq=function wI
set mq=function uI
set Qq=function cI
set Wq=function oI
set Eq=function eI
set Zq=function qI
set Uq=function TI
set Iq=function YI
set Pq=function jI
set Aq=function xI
set Dq=function ZI
set Hq=function UI
set Jq=function JI
set Kq=function KI
set Lq=function BI
set Xq=function NI
set Cq=function uP
set Vq=function rP
set Bq=function oP
set Nq=function OP
set Mq=function qP
set wa=function aP
set ua=function YP
set ra=function GP
set sa=function xP
set ta=function vP
set ia=function UP
set Sa=function IP
set ca=function KP
set oa=function LP
set Oa=function MP
set la=function wA
set ba=function SA
set ya=function cA
set pa=function pA
set ea=function eA
set qa=function RA
set aa=function TA
set na=function kA
set da=function jA
set fa=function EA
set Ra=function ZA
set Ta=function HA
set Ya=function JA
set Ga=function BA
set ga=function NA
set ha=function tD
set Fa=function iD
set ka=function bD
set ja=function yD
set xa=function dD
set va=function fD
set ma=function gD
set Qa=function hD
set Wa=function jD
set Ea=function xD
set Za=function kD
set Ua=function ZD
set Ia=function DD
set Pa=function CD
set Aa=function sH
set Da=function OH
set Ha=function nH
set Ja=function YH
set Ka=function vH
set La=function UH
set Xa=function LH
set Ca=function MH
set Va=function cJ
set Ba=function pJ
set Na=function eJ
set Ma=function RJ
set wn=function TJ
set un=function kJ
set rn=function jJ
set sn=function EJ
set tn=function ZJ
set Sn=function HJ
set cn=function JJ
set on=function BJ
set On=function NJ
set ln=function tK
set bn=function iK
set yn=function bK
set pn=function yK
set en=function dK
set qn=function fK
set an=function hK
set nn=function FK
set dn=function QK
set fn=function WK
set Rn=function AK
set Tn=function DK
set Yn=function CK
set Gn=function VK
set gn=function rL
set hn=function sL
set Fn=function OL
set kn=function lL
set jn=function aL
set xn=function nL
set vn=function GL
set mn=function gL
set Qn=function vL
set Wn=function mL
set En=function IL
set Zn=function PL
set Un=function LL
set In=function XL
set Pn=function wX
set An=function uX
set Dn=function DT
set Hn=function cv
set Jn=function n0w
set Kn=function w4
set Ln=function hww
set Xn=function eX
set Cn=function nrw
set Vn=function J2
set Bn=function K9
set Nn=function i0w
set Mn=function vX
set wd=function A1
set ud=function p4
set rd=function F1
set sd=function K2
set td=function l0w
set id=function Eww
set Sd=function X9
set cd=function Ijw
set od=function C1
set Od=function u4
set ld=function rsw
set bd=function Pjw
set yd=function lB
set pd=function Ajw
set ed=function Hjw
set qd=function pX
set ad=function Z8
set nd=function B1
set dd=function Jjw
set fd=function Kjw
set Rd=function Ljw
set Td=function GB
set Yd=function Zww
set Gd=function QX
set gd=function L3
set hd=function M1
set Fd=function p9
set kd=function Gww
set jd=function gww
set xd=function Hww_2
set vd=function Jww
set md=function Xjw
set Qd=function Kww
set Wd=function f2
set Ed=function Cjw
set Zd=function Vjw
set Ud=function y9
set Id=function Bjw
set Pd=function Njw
set Ad=function Mjw
set Dd=function Lww
set Hd=function wxw
set Jd=function W2
set Kd=function P1
set Ld=function Www
set Xd=function uxw
set Cd=function P0w
set Vd=function cxw
set Bd=function oxw
set Nd=function L9
set Md=function e4
set wf=function Oxw
set uf=function nX
set rf=function mX
set sf=function lxw
set tf=function bxw
set Sf=function yxw
set cf=function pxw
set of=function exw
set Of=function N1
set lf=function nxw
set bf=function lN
set yf=function dxw
set pf=function fxw
set ef=function Rxw
set qf=function Txw
set af=function jM
set nf=function Yxw
set df=function Gxw
set ff=function y4
set Rf=function gxw
set Tf=function hxw
set Yf=function Fxw
set Gf=function kxw
set gf=function jxw
set hf=function xxw
set Ff=function vxw
set kf=function mxw
set jf=function Qxw
set xf=function Wxw
set vf=function Exw
set mf=function eC
set Qf=function Zxw
set Wf=function XV
set Ef=function Uxw
set Zf=function Ixw
set Uf=function Axw
set If=function lM
set Pf=function Dxw
set Af=function V1
set Df=function Hxw
set Hf=function Jxw
set Jf=function D1
set Kf=function d2
set Lf=function Kxw
set Xf=function Xxw
set Cf=function Cxw
set Vf=function Vxw
set Bf=function Bxw
set Nf=function Nxw
set Mf=function Mxw
set wR=function wvw
set uR=function svw
set rR=function F9
set sR=function j9
set tR=function x9
set iR=function rvw
set SR=function Lxw
endfunction
function qR takes nothing returns nothing
local integer eR=0
set eR=0
loop
exitwhen eR>8192
call CreateGroup()
set eR=eR+1
endloop
call CreateForce()
call CreateGroup()
call CreateForce()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateForce()
call CreateForce()
call CreateForce()
call CreateTimer()
call CreateForce()
call CreateGroup()
set w=CreateGroup()
call CreateGroup()
call CreateForce()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateTimer()
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
set eR=0
loop
exitwhen eR>24
set r[eR]=0
set eR=eR+1
endloop
set s=CreateForce()
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
call CreateGroup()
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
call CreateForce()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
set l=CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
call CreateGroup()
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
set eR=0
loop
exitwhen eR>24
set eR=eR+1
endloop
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateForce()
call CreateForce()
set eR=0
loop
exitwhen eR>1
set eR=eR+1
endloop
set eR=0
loop
exitwhen eR>1
set eR=eR+1
endloop
set eR=0
loop
exitwhen eR>1
set eR=eR+1
endloop
set b=CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
call CreateGroup()
set eR=0
loop
exitwhen eR>24
set p[eR]=false
set eR=eR+1
endloop
set eR=0
loop
exitwhen eR>24
set e[eR]=false
set eR=eR+1
endloop
endfunction
function main takes nothing returns nothing
local trigger lX
local trigger bX
local trigger yX
call pR()
call SetCameraBounds((-30720.0)+GetCameraMargin(CAMERA_MARGIN_LEFT),(-30720.0)+GetCameraMargin(CAMERA_MARGIN_BOTTOM),30720.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),30720.0-GetCameraMargin(CAMERA_MARGIN_TOP),(-30720.0)+GetCameraMargin(CAMERA_MARGIN_LEFT),30720.0-GetCameraMargin(CAMERA_MARGIN_TOP),30720.0-GetCameraMargin(CAMERA_MARGIN_RIGHT),(-30720.0)+GetCameraMargin(CAMERA_MARGIN_BOTTOM))
call SetDayNightModels("Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl","Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl")
call NewSoundEnvironment("Default")
call SetAmbientDaySound("LordaeronSummerDay")
call SetAmbientNightSound("LordaeronSummerNight")
call SetMapMusic("Music",true,0)
set fs=CreateSound("Sound\\Interface\\Warning.wav",false,false,false,10,10,"")
call SetSoundParamsFromLabel(fs,"Warning")
call SetSoundDuration(fs,1903)
set q=Rect(11872.0,-24096.0,13376.0,-18304.0)
set a=Rect(14080.0,-30720.0,16256.0,-25664.0)
set n=Rect(12096.0,-26240.0,14944.0,-23776.0)
set d=Rect(-17120.0,15936.0,-15520.0,17408.0)
call Rect(-29824.0,-30080.0,-29312.0,-28672.0)
call Rect(-29216.0,-30112.0,-28672.0,-28672.0)
call Rect(-25984.0,-29760.0,-24992.0,-29504.0)
call Rect(-25984.0,-30080.0,-25472.0,-29824.0)
call Rect(-25984.0,-30400.0,-25472.0,-30144.0)
call Rect(-26464.0,-30048.0,-26176.0,-29056.0)
call Rect(-25440.0,-30368.0,-25184.0,-29856.0)
call Rect(-25184.0,-30368.0,-24928.0,-29856.0)
call Rect(-24672.0,-29568.0,-24064.0,-28800.0)
call Rect(-24704.0,-30208.0,-24064.0,-29696.0)
set f=Rect(-17408.0,22016.0,-17056.0,22368.0)
set R=Rect(-19072.0,17728.0,-18688.0,18080.0)
set T=Rect(-22464.0,22208.0,-22112.0,22560.0)
set Y=Rect(-3776.0,4416.0,-3392.0,4768.0)
set G=Rect(-3872.0,1664.0,-3456.0,2016.0)
set g=Rect(-416.0,-2592.0,-128.0,-2272.0)
set h=Rect(4992.0,-2016.0,5344.0,-1696.0)
set F=Rect(2528.0,-3168.0,2848.0,-2880.0)
set k=Rect(7744.0,-2528.0,8096.0,-2208.0)
set j=Rect(-17504.0,18080.0,-17056.0,18496.0)
set x=Rect(1024.0,-1120.0,1376.0,-800.0)
set v=Rect(-3328.0,8096.0,-2848.0,8512.0)
set m=Rect(-4704.0,11488.0,-4416.0,11776.0)
set Q=Rect(-640.0,8288.0,-160.0,8704.0)
set W=Rect(-5184.0,17120.0,-4832.0,17440.0)
set E=Rect(-96.0,12448.0,224.0,12768.0)
set Z=Rect(-2272.0,13536.0,-1984.0,13856.0)
set U=Rect(7008.0,1984.0,7456.0,2432.0)
set I=Rect(4032.0,3744.0,4416.0,4064.0)
set P=Rect(4000.0,5216.0,4320.0,5536.0)
set A=Rect(-576.0,2880.0,-224.0,3232.0)
set D=Rect(-8288.0,19776.0,-7936.0,20160.0)
set H=Rect(-6464.0,21184.0,-6080.0,21568.0)
set J=Rect(-7904.0,22048.0,-7488.0,22464.0)
set K=Rect(-5344.0,14304.0,-4960.0,14720.0)
set L=Rect(2880.0,32.0,3264.0,352.0)
set X=Rect(608.0,15680.0,992.0,16096.0)
set C=Rect(-2496.0,15872.0,-2112.0,16224.0)
set V=Rect(1056.0,10848.0,1344.0,11136.0)
set B=Rect(1600.0,6784.0,1984.0,7136.0)
set N=Rect(224.0,19296.0,544.0,19648.0)
set M=Rect(2784.0,22592.0,3200.0,22944.0)
set ww=Rect(-1984.0,19008.0,-1600.0,19360.0)
set uw=Rect(3008.0,18048.0,3392.0,18400.0)
call Rect(-28544.0,-30080.0,-28064.0,-29344.0)
call Rect(-27744.0,-30080.0,-27456.0,-29760.0)
set rw=Rect(4224.0,19488.0,4608.0,19776.0)
set sw=Rect(13056.0,4960.0,13408.0,5280.0)
set tw=Rect(5696.0,24768.0,6048.0,25088.0)
set iw=Rect(3328.0,26816.0,3680.0,27168.0)
set Sw=Rect(8608.0,26144.0,9024.0,26528.0)
set cw=Rect(6656.0,21248.0,7008.0,21600.0)
set ow=Rect(-16640.0,10368.0,-13504.0,13056.0)
set Ow=Rect(-18944.0,5312.0,-16864.0,7328.0)
set lw=Rect(-28032.0,-1120.0,-22464.0,640.0)
set bw=Rect(-27264.0,2784.0,-26208.0,3328.0)
set yw=Rect(-26912.0,-4320.0,-23872.0,-2976.0)
set pw=Rect(-19328.0,-288.0,-18592.0,1568.0)
set ew=Rect(-11936.0,7616.0,-448.0,11424.0)
set qw=Rect(-1664.0,1216.0,6848.0,7776.0)
set aw=Rect(-5472.0,24704.0,-3232.0,27616.0)
set nw=Rect(3744.0,10880.0,4064.0,11232.0)
set dw=Rect(-12064.0,11392.0,-8832.0,16576.0)
set fw=Rect(-8832.0,10176.0,23520.0,17760.0)
set Rw=Rect(4384.0,17728.0,23424.0,27040.0)
set Tw=Rect(-10688.0,17536.0,-10304.0,17888.0)
set Yw=Rect(-10688.0,-9312.0,-10336.0,-9024.0)
set Gw=Rect(17280.0,9280.0,17632.0,9632.0)
set gw=Rect(8352.0,12192.0,8672.0,12512.0)
set hw=Rect(5952.0,18400.0,6304.0,18688.0)
set Fw=Rect(9120.0,19872.0,9408.0,20192.0)
set kw=Rect(23328.0,-14080.0,30688.0,17792.0)
set jw=Rect(13984.0,-288.0,14336.0,0.0)
set xw=Rect(10624.0,-7552.0,11008.0,-7200.0)
set vw=Rect(15168.0,-5792.0,15552.0,-5408.0)
set mw=Rect(15328.0,-7712.0,15648.0,-7424.0)
set Qw=Rect(12640.0,-7104.0,12992.0,-6752.0)
set Ww=Rect(17056.0,-8800.0,17376.0,-8512.0)
set Ew=Rect(18432.0,-608.0,18784.0,-320.0)
set Zw=Rect(13760.0,-11168.0,14112.0,-10752.0)
set Uw=Rect(16768.0,-16416.0,17120.0,-16032.0)
set Iw=Rect(18880.0,-7616.0,19232.0,-7296.0)
set Pw=Rect(6816.0,-6752.0,7136.0,-6464.0)
set Aw=Rect(12512.0,-4064.0,12832.0,-3712.0)
set Dw=Rect(9056.0,-4576.0,9344.0,-4288.0)
set Hw=Rect(-26464.0,-8896.0,-26144.0,-8544.0)
set Jw=Rect(-21632.0,-8544.0,-21248.0,-8224.0)
set Kw=Rect(-16928.0,-8224.0,-16608.0,-7904.0)
set Lw=Rect(-10112.0,-11424.0,-9760.0,-11136.0)
set Xw=Rect(-7680.0,-16416.0,-7328.0,-16128.0)
set Cw=Rect(288.0,-17760.0,608.0,-17472.0)
set Vw=Rect(9248.0,-21376.0,9984.0,-20640.0)
set Bw=Rect(24704.0,-27648.0,25088.0,-27264.0)
set Nw=Rect(10816.0,-18688.0,11168.0,-18304.0)
set Mw=Rect(13056.0,-18016.0,13408.0,-17760.0)
set wu=Rect(12096.0,-21024.0,12448.0,-20704.0)
set uu=Rect(15680.0,5600.0,16032.0,5920.0)
set ru=Rect(6944.0,7648.0,7264.0,7968.0)
set su=Rect(5824.0,12256.0,6176.0,12576.0)
set tu=Rect(11200.0,7712.0,11552.0,8064.0)
set iu=Rect(12480.0,11136.0,12832.0,11456.0)
set Su=Rect(14880.0,22944.0,15200.0,23232.0)
set cu=Rect(11392.0,16768.0,11744.0,17088.0)
set ou=Rect(23840.0,96.0,24128.0,384.0)
set Ou=Rect(19488.0,11168.0,19808.0,11488.0)
set lu=Rect(20672.0,2528.0,21056.0,2848.0)
set bu=Rect(23776.0,2368.0,24160.0,2720.0)
set yu=Rect(18336.0,-13408.0,18624.0,-13120.0)
set pu=Rect(17056.0,-11648.0,17376.0,-11264.0)
set eu=Rect(15488.0,-17696.0,15840.0,-17376.0)
set qu=Rect(24896.0,-8480.0,25248.0,-8128.0)
set au=Rect(16480.0,-14368.0,16768.0,-14048.0)
set nu=Rect(17088.0,-19744.0,17440.0,-19456.0)
set du=Rect(22720.0,-10432.0,23072.0,-10048.0)
set fu=Rect(20672.0,-23232.0,21056.0,-22848.0)
set Ru=Rect(19904.0,-5920.0,20256.0,-5632.0)
set Tu=Rect(18624.0,-3936.0,18976.0,-3616.0)
set Yu=Rect(-13632.0,-14816.0,-12192.0,-13376.0)
set Gu=Rect(17760.0,-10400.0,23360.0,-1344.0)
set gu=Rect(12384.0,-5984.0,13824.0,-4352.0)
set hu=Rect(-10944.0,3968.0,-7680.0,5120.0)
set Fu=Rect(-6528.0,7808.0,-6176.0,8160.0)
set ku=Rect(-8864.0,6912.0,-8448.0,7264.0)
set ju=Rect(-11680.0,14304.0,-11264.0,14752.0)
set xu=Rect(-9760.0,12928.0,-9472.0,13280.0)
set vu=Rect(-7552.0,16928.0,-7232.0,17248.0)
set mu=Rect(-17472.0,-3328.0,-17120.0,-2976.0)
call Rect(-24576.0,-1376.0,-24224.0,-1024.0)
set Qu=Rect(23392.0,10912.0,23712.0,11232.0)
set Wu=Rect(17280.0,19456.0,17632.0,19808.0)
set Eu=Rect(-16896.0,24032.0,-16544.0,24352.0)
set Zu=Rect(-15904.0,25952.0,-15520.0,26304.0)
set Uu=Rect(-17312.0,26624.0,-16896.0,27008.0)
set Iu=Rect(-16096.0,20352.0,-15712.0,20768.0)
set Pu=Rect(-20448.0,21440.0,-20064.0,21792.0)
set Au=Rect(-22560.0,19808.0,-22272.0,20128.0)
set Du=Rect(-18752.0,19520.0,-18400.0,19872.0)
set Hu=Rect(-16128.0,16896.0,-15808.0,17248.0)
set Ju=Rect(-17952.0,15904.0,-17632.0,16224.0)
set Ku=Rect(-19936.0,16352.0,-19648.0,16672.0)
set Lu=Rect(-17248.0,12448.0,-16928.0,12832.0)
set Xu=Rect(-13728.0,11968.0,-13408.0,12352.0)
set Cu=Rect(-15232.0,10624.0,-14880.0,10976.0)
set Vu=Rect(-13856.0,7872.0,-13568.0,8256.0)
set Bu=Rect(-16192.0,5824.0,-15840.0,6208.0)
set Nu=Rect(-16864.0,3392.0,-16576.0,3776.0)
set Mu=Rect(-18880.0,5568.0,-18528.0,5920.0)
set wr=Rect(-20288.0,1216.0,-19936.0,1600.0)
set ur=Rect(-17216.0,352.0,-16896.0,736.0)
set rr=Rect(-24512.0,3744.0,-24128.0,4064.0)
set sr=Rect(-22720.0,2368.0,-22432.0,2752.0)
set tr=Rect(-23552.0,-256.0,-23200.0,128.0)
set ir=Rect(-25376.0,1312.0,-25056.0,1632.0)
set Sr=Rect(-28736.0,-192.0,-28352.0,160.0)
set cr=Rect(-21024.0,2944.0,-20704.0,3360.0)
set lr=Rect(-13792.0,2144.0,-13440.0,2592.0)
set br=Rect(-13568.0,14912.0,-13216.0,15296.0)
set yr=Rect(-12736.0,16128.0,-12352.0,16512.0)
set pr=Rect(-10880.0,3360.0,-10528.0,3712.0)
set er=Rect(-10048.0,5280.0,-9696.0,5600.0)
set qr=Rect(-6880.0,3936.0,-6560.0,4256.0)
set ar=Rect(-8224.0,3040.0,-7904.0,3392.0)
set nr=Rect(-8960.0,1760.0,-8608.0,2176.0)
set dr=Rect(-6624.0,1088.0,-6304.0,1472.0)
set fr=Rect(-7296.0,-960.0,-6944.0,-544.0)
set Rr=Rect(-23712.0,-4704.0,-23392.0,-4416.0)
set Tr=Rect(-25184.0,-3168.0,-24864.0,-2848.0)
set Yr=Rect(-21888.0,-4416.0,-21536.0,-4032.0)
set Gr=Rect(-20928.0,-2304.0,-20576.0,-1888.0)
set gr=Rect(-7776.0,11040.0,-7456.0,11392.0)
set hr=Rect(-11648.0,7072.0,-11296.0,7360.0)
set Fr=Rect(-13728.0,4992.0,-13408.0,5376.0)
set kr=Rect(-5152.0,21696.0,-4832.0,22080.0)
set jr=Rect(-5248.0,24416.0,-4960.0,24768.0)
set xr=Rect(-6688.0,28096.0,-6368.0,28480.0)
set vr=Rect(-9024.0,26496.0,-8736.0,26880.0)
set mr=Rect(-10048.0,28224.0,-9696.0,28576.0)
set Qr=Rect(-1408.0,23776.0,-1152.0,24096.0)
set Wr=Rect(-2720.0,26176.0,-2432.0,26560.0)
set Er=Rect(-28032.0,-2944.0,-27680.0,-2560.0)
set Zr=Rect(-29760.0,-10016.0,-29408.0,-9632.0)
set Ur=Rect(15296.0,-26976.0,15648.0,-26624.0)
set Ir=Rect(-20544.0,12032.0,-20160.0,12416.0)
set Pr=Rect(-18368.0,10624.0,-18016.0,11008.0)
set Ar=Rect(-10880.0,-576.0,-10528.0,-224.0)
set Dr=Rect(-11104.0,-4768.0,-10816.0,-4448.0)
set Hr=Rect(-5728.0,-2912.0,-5440.0,-2560.0)
set Jr=Rect(-3904.0,-6720.0,-3552.0,-6336.0)
set Kr=Rect(-3616.0,-3040.0,-3328.0,-2688.0)
set Lr=Rect(-7200.0,-8000.0,-6880.0,-7616.0)
set Xr=Rect(-5504.0,-9344.0,-5248.0,-9056.0)
set Cr=Rect(-11616.0,10848.0,-11296.0,11168.0)
set Vr=Rect(-1792.0,-320.0,-1440.0,64.0)
set Br=Rect(3232.0,-7488.0,3552.0,-7136.0)
set Nr=Rect(8224.0,-10496.0,8512.0,-10208.0)
set Mr=Rect(1344.0,29280.0,1696.0,29632.0)
set ws=Rect(10848.0,-2144.0,11136.0,-1824.0)
set us=Rect(-26496.0,-1568.0,-26144.0,-1248.0)
set rs=Rect(-27168.0,2528.0,-26880.0,2816.0)
set ss=Rect(-2016.0,27552.0,-1696.0,27936.0)
set ts=Rect(-3488.0,23040.0,-3200.0,23392.0)
set is=Rect(2016.0,-7904.0,2336.0,-7584.0)
set Ss=Rect(640.0,-5760.0,992.0,-5376.0)
set cs=Rect(5216.0,-12384.0,5504.0,-12064.0)
set os=Rect(18272.0,-17504.0,18656.0,-17056.0)
set Os=Rect(26848.0,-11680.0,27168.0,-11360.0)
set ls=Rect(6464.0,-4672.0,6816.0,-4288.0)
set bs=Rect(20672.0,21312.0,21024.0,21696.0)
set ys=Rect(-1824.0,5792.0,-1440.0,6144.0)
set ps=Rect(-23264.0,-8992.0,-22944.0,-8704.0)
set es=Rect(-13504.0,-8640.0,-13184.0,-8384.0)
set qs=Rect(26048.0,-2848.0,26400.0,-2528.0)
set as=Rect(28864.0,-3360.0,29152.0,-3040.0)
set ns=Rect(28064.0,2592.0,28352.0,2880.0)
set ds=Rect(27488.0,-5984.0,27808.0,-5664.0)
set sS=Rect(-30720.0,-10592.0,-29536.0,-9376.0)
call QT()
call WT()
call InitBlizzard()
call qR()
call SX()
set bX=Ts
if TriggerEvaluate(bX) then
call TriggerExecute(bX)
endif
set yX=wt
if TriggerEvaluate(yX) then
call TriggerExecute(yX)
endif
set lX=CreateTrigger()
call TriggerAddCondition(lX,Condition(Jn))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Real.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Kn))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Integer.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Ln))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package String.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Xn))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Angle.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Cn))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Vectors.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Vn))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Maths.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Bn))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Player.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Nn))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Printing.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Mn))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Basics.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(wd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package GameTimer.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(ud))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MagicFunctions.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(rd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ErrorHandling.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(sd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Matrices.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(td))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Quaternion.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(id))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Table.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Sd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Playercolor.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(cd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Colors.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(od))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Group.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Od))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Lightning.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(ld))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package WeatherEffects.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(bd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TypeCasting.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(yd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureForGroups.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(pd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LinkedList.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(ed))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Abilities.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(qd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package AbilityIds.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(ad))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MutliboardTools.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(nd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package HashList.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(dd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package EventHelper.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(fd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package RegisterEvents.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Rd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TimerUtils.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Td))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureTimers.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Yd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package TargetsAllowed.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Gd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Buildings.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(gd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Doodads.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(hd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Icons.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Fd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Objects.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(kd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Sounds.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(jd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Soundsets.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(xd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Textures.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(vd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UI.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(md))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Units.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Qd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UnitIds.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Wd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MapBounds.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Ed))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DummyRecycler.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Zd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package StringUtils.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Ud))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ObjectIds.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Id))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Preloader.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Pd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ObjectIdGenerator.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Ad))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OnUnitEnterLeave.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Dd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package UnitIndexer.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Hd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package ClosureEvents.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Jd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MathTools.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Kd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Forces.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Ld))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Strings.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Xd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityBaseTaxes.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Cd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Revolts.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Vd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package City.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Bd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Multiboards.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Nd))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package PlayerStats.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Md))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Main.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(wf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CommandTools.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(uf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package BNetName.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(rf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Bootleg.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(sf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CastleCapture.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(tf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityBuilded.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Sf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityManage.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(cf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package CityModifiers.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(of))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Clerics.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Of))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package HashSet.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(lf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package VoteKick.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(bf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Commands.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(yf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Credits.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(pf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Economy.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(ef))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package DateTime.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(qf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Debug.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(af))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Diplomacy.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(nf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Garissons.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(df))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package LimitEncampments.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(ff))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Logarithm.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Rf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MainInit.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Tf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MassControl.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Yf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package MultiboardCityUpdate.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Gf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package NoShipsNearRivers.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(gf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package NoStarvationOnBoat.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(hf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OnPlayerLeave.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(Ff))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package OreCapture.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(kf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package RangeChecks.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(jf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Religion.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(xf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Taxation.")
endif
call TriggerClearConditions(lX)
call TriggerAddCondition(lX,Condition(vf))
if not TriggerEvaluate(lX) then
call DisplayTimedTextToPlayer(GetLocalPlayer(),0.,0.,45.,"Could not initialize package Upkeep.")
endif
call TriggerClearConditions(lX)
call DestroyTrigger(lX)
set lX=null
set bX=null
set yX=null
endfunction
function OX takes nothing returns nothing
call SetStartLocPrioCount(0,19)
call SetStartLocPrio(0,0,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,9,10,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,10,11,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,11,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,12,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,13,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,14,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,15,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(1,9)
call SetStartLocPrio(1,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(2,9)
call SetStartLocPrio(2,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(3,9)
call SetStartLocPrio(3,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(4,9)
call SetStartLocPrio(4,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(5,9)
call SetStartLocPrio(5,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(6,9)
call SetStartLocPrio(6,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(7,9)
call SetStartLocPrio(7,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(8,9)
call SetStartLocPrio(8,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(9,9)
call SetStartLocPrio(9,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(10,16)
call SetStartLocPrio(10,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(10,10,12,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,11,13,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,12,14,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,13,15,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,14,16,MAP_LOC_PRIO_LOW)
call SetStartLocPrio(10,15,17,MAP_LOC_PRIO_LOW)
call SetStartLocPrioCount(11,19)
call SetStartLocPrio(11,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,10,10,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,11,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,12,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,13,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,14,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,15,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(11,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(12,5)
call SetStartLocPrio(12,0,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,1,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,2,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(12,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(13,5)
call SetStartLocPrio(13,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,1,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,2,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(13,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(14,5)
call SetStartLocPrio(14,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,2,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(14,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(15,5)
call SetStartLocPrio(15,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,2,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,3,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(15,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(16,5)
call SetStartLocPrio(16,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,2,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,3,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,4,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(17,5)
call SetStartLocPrio(17,0,12,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,1,13,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,2,14,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,3,15,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,4,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(18,1)
call SetStartLocPrio(18,0,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(19,1)
call SetStartLocPrio(19,0,18,MAP_LOC_PRIO_HIGH)
endfunction
function cX takes nothing returns nothing
call SetPlayerStartLocation(Player(0),0)
call ForcePlayerStartLocation(Player(0),0)
call SetPlayerColor(Player(0),ConvertPlayerColor(0))
call SetPlayerRacePreference(Player(0),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(0),false)
call SetPlayerController(Player(0),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(1),1)
call ForcePlayerStartLocation(Player(1),1)
call SetPlayerColor(Player(1),ConvertPlayerColor(1))
call SetPlayerRacePreference(Player(1),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(1),false)
call SetPlayerController(Player(1),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(2),2)
call ForcePlayerStartLocation(Player(2),2)
call SetPlayerColor(Player(2),ConvertPlayerColor(2))
call SetPlayerRacePreference(Player(2),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(2),false)
call SetPlayerController(Player(2),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(3),3)
call ForcePlayerStartLocation(Player(3),3)
call SetPlayerColor(Player(3),ConvertPlayerColor(3))
call SetPlayerRacePreference(Player(3),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(3),false)
call SetPlayerController(Player(3),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(4),4)
call ForcePlayerStartLocation(Player(4),4)
call SetPlayerColor(Player(4),ConvertPlayerColor(4))
call SetPlayerRacePreference(Player(4),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(4),false)
call SetPlayerController(Player(4),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(5),5)
call ForcePlayerStartLocation(Player(5),5)
call SetPlayerColor(Player(5),ConvertPlayerColor(5))
call SetPlayerRacePreference(Player(5),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(5),false)
call SetPlayerController(Player(5),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(6),6)
call ForcePlayerStartLocation(Player(6),6)
call SetPlayerColor(Player(6),ConvertPlayerColor(6))
call SetPlayerRacePreference(Player(6),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(6),false)
call SetPlayerController(Player(6),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(7),7)
call ForcePlayerStartLocation(Player(7),7)
call SetPlayerColor(Player(7),ConvertPlayerColor(7))
call SetPlayerRacePreference(Player(7),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(7),false)
call SetPlayerController(Player(7),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(8),8)
call ForcePlayerStartLocation(Player(8),8)
call SetPlayerColor(Player(8),ConvertPlayerColor(8))
call SetPlayerRacePreference(Player(8),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(8),false)
call SetPlayerController(Player(8),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(9),9)
call ForcePlayerStartLocation(Player(9),9)
call SetPlayerColor(Player(9),ConvertPlayerColor(9))
call SetPlayerRacePreference(Player(9),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(9),false)
call SetPlayerController(Player(9),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(10),10)
call ForcePlayerStartLocation(Player(10),10)
call SetPlayerColor(Player(10),ConvertPlayerColor(10))
call SetPlayerRacePreference(Player(10),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(10),false)
call SetPlayerController(Player(10),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(11),11)
call ForcePlayerStartLocation(Player(11),11)
call SetPlayerColor(Player(11),ConvertPlayerColor(11))
call SetPlayerRacePreference(Player(11),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(11),false)
call SetPlayerController(Player(11),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(12),12)
call ForcePlayerStartLocation(Player(12),12)
call SetPlayerColor(Player(12),ConvertPlayerColor(12))
call SetPlayerRacePreference(Player(12),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(12),false)
call SetPlayerController(Player(12),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(13),13)
call ForcePlayerStartLocation(Player(13),13)
call SetPlayerColor(Player(13),ConvertPlayerColor(13))
call SetPlayerRacePreference(Player(13),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(13),false)
call SetPlayerController(Player(13),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(14),14)
call ForcePlayerStartLocation(Player(14),14)
call SetPlayerColor(Player(14),ConvertPlayerColor(14))
call SetPlayerRacePreference(Player(14),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(14),false)
call SetPlayerController(Player(14),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(15),15)
call ForcePlayerStartLocation(Player(15),15)
call SetPlayerColor(Player(15),ConvertPlayerColor(15))
call SetPlayerRacePreference(Player(15),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(15),false)
call SetPlayerController(Player(15),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(16),16)
call ForcePlayerStartLocation(Player(16),16)
call SetPlayerColor(Player(16),ConvertPlayerColor(16))
call SetPlayerRacePreference(Player(16),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(16),false)
call SetPlayerController(Player(16),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(17),17)
call ForcePlayerStartLocation(Player(17),17)
call SetPlayerColor(Player(17),ConvertPlayerColor(17))
call SetPlayerRacePreference(Player(17),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(17),false)
call SetPlayerController(Player(17),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(18),18)
call ForcePlayerStartLocation(Player(18),18)
call SetPlayerColor(Player(18),ConvertPlayerColor(18))
call SetPlayerRacePreference(Player(18),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(18),false)
call SetPlayerController(Player(18),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(19),19)
call ForcePlayerStartLocation(Player(19),19)
call SetPlayerColor(Player(19),ConvertPlayerColor(19))
call SetPlayerRacePreference(Player(19),RACE_PREF_HUMAN)
call SetPlayerRaceSelectable(Player(19),false)
call SetPlayerController(Player(19),MAP_CONTROL_USER)
endfunction
function oX takes nothing returns nothing
call SetPlayerTeam(Player(0),0)
call SetPlayerTeam(Player(1),0)
call SetPlayerTeam(Player(2),0)
call SetPlayerTeam(Player(3),0)
call SetPlayerTeam(Player(4),0)
call SetPlayerTeam(Player(5),0)
call SetPlayerTeam(Player(6),0)
call SetPlayerTeam(Player(7),0)
call SetPlayerTeam(Player(8),0)
call SetPlayerTeam(Player(9),0)
call SetPlayerTeam(Player(10),0)
call SetPlayerTeam(Player(11),0)
call SetPlayerTeam(Player(12),1)
call SetPlayerTeam(Player(13),1)
call SetPlayerTeam(Player(14),1)
call SetPlayerTeam(Player(15),1)
call SetPlayerTeam(Player(16),1)
call SetPlayerTeam(Player(17),1)
call SetPlayerTeam(Player(18),1)
call SetPlayerTeam(Player(19),1)
endfunction
function config takes nothing returns nothing
call SetMapName("TRIGSTR_001")
call SetMapDescription("TRIGSTR_003")
call SetPlayers(20)
call SetTeams(20)
call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
call DefineStartLocation(0,320.0,5184.0)
call DefineStartLocation(1,320.0,5184.0)
call DefineStartLocation(2,320.0,5184.0)
call DefineStartLocation(3,320.0,5184.0)
call DefineStartLocation(4,320.0,5184.0)
call DefineStartLocation(5,320.0,5184.0)
call DefineStartLocation(6,320.0,5184.0)
call DefineStartLocation(7,320.0,5184.0)
call DefineStartLocation(8,320.0,5184.0)
call DefineStartLocation(9,320.0,5184.0)
call DefineStartLocation(10,320.0,5184.0)
call DefineStartLocation(11,320.0,5184.0)
call DefineStartLocation(12,320.0,5184.0)
call DefineStartLocation(13,320.0,5184.0)
call DefineStartLocation(14,320.0,5184.0)
call DefineStartLocation(15,320.0,5184.0)
call DefineStartLocation(16,320.0,5184.0)
call DefineStartLocation(17,320.0,5184.0)
call DefineStartLocation(18,320.0,5184.0)
call DefineStartLocation(19,320.0,5184.0)
call cX()
call oX()
call OX()
endfunction
